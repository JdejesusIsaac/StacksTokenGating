(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.StacksBlockchainApiClient = {}));
})(this, (function (exports) {
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);

    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  const _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";

  function _settle(pact, state, value) {
    if (!pact.s) {
      if (value instanceof _Pact) {
        if (value.s) {
          if (state & 1) {
            state = value.s;
          }

          value = value.v;
        } else {
          value.o = _settle.bind(null, pact, state);
          return;
        }
      }

      if (value && value.then) {
        value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
        return;
      }

      pact.s = state;
      pact.v = value;
      var observer = pact.o;

      if (observer) {
        observer(pact);
      }
    }
  }

  var _Pact = /*#__PURE__*/function () {
    function _Pact() {}

    _Pact.prototype.then = function (onFulfilled, onRejected) {
      var result = new _Pact();
      var state = this.s;

      if (state) {
        var callback = state & 1 ? onFulfilled : onRejected;

        if (callback) {
          try {
            _settle(result, 1, callback(this.v));
          } catch (e) {
            _settle(result, 2, e);
          }

          return result;
        } else {
          return this;
        }
      }

      this.o = function (_this) {
        try {
          var value = _this.v;

          if (_this.s & 1) {
            _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
          } else if (onRejected) {
            _settle(result, 1, onRejected(value));
          } else {
            _settle(result, 2, value);
          }
        } catch (e) {
          _settle(result, 2, e);
        }
      };

      return result;
    };

    return _Pact;
  }();

  function _isSettledPact(thenable) {
    return thenable instanceof _Pact && thenable.s & 1;
  }

  function _forTo(array, body, check) {
    var i = -1,
        pact,
        reject;

    function _cycle(result) {
      try {
        while (++i < array.length && (!check || !check())) {
          result = body(i);

          if (result && result.then) {
            if (_isSettledPact(result)) {
              result = result.v;
            } else {
              result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
              return;
            }
          }
        }

        if (pact) {
          _settle(pact, 1, result);
        } else {
          pact = result;
        }
      } catch (e) {
        _settle(pact || (pact = new _Pact()), 2, e);
      }
    }

    _cycle();

    return pact;
  }

  function _forOf(target, body, check) {
    if (typeof target[_iteratorSymbol] === "function") {
      var _cycle = function _cycle(result) {
        try {
          while (!(step = iterator.next()).done && (!check || !check())) {
            result = body(step.value);

            if (result && result.then) {
              if (_isSettledPact(result)) {
                result = result.v;
              } else {
                result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
                return;
              }
            }
          }

          if (pact) {
            _settle(pact, 1, result);
          } else {
            pact = result;
          }
        } catch (e) {
          _settle(pact || (pact = new _Pact()), 2, e);
        }
      };

      var iterator = target[_iteratorSymbol](),
          step,
          pact,
          reject;

      _cycle();

      if (iterator["return"]) {
        var _fixup = function _fixup(value) {
          try {
            if (!step.done) {
              iterator["return"]();
            }
          } catch (e) {}

          return value;
        };

        if (pact && pact.then) {
          return pact.then(_fixup, function (e) {
            throw _fixup(e);
          });
        }

        _fixup();
      }

      return pact;
    } // No support for Symbol.iterator


    // No support for Symbol.iterator
    if (!("length" in target)) {
      throw new TypeError("Object is not iterable");
    } // Handle live collections properly


    // Handle live collections properly
    var values = [];

    for (var i = 0; i < target.length; i++) {
      values.push(target[i]);
    }

    return _forTo(values, function (i) {
      return body(values[i]);
    }, check);
  }

  var BASE_PATH = "https://stacks-node-api.mainnet.stacks.co".replace(/\/+$/, "");

  var isBlob = function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
  };
  /**
   * This is the base class for all generated API classes.
   */


  var BaseAPI = /*#__PURE__*/function () {
    function BaseAPI(configuration) {
      var _this = this;

      if (configuration === void 0) {
        configuration = new Configuration();
      }

      this.configuration = void 0;
      this.middleware = void 0;

      this.fetchApi = function (url, init) {
        try {
          var _temp6 = function _temp6() {
            return Promise.resolve((_this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init)).then(function (response) {
              var _temp3 = _forOf(_this.middleware, function (middleware) {
                var _temp2 = function () {
                  if (middleware.post) {
                    return Promise.resolve(middleware.post({
                      fetch: _this.fetchApi,
                      url: fetchParams.url,
                      init: fetchParams.init,
                      response: response.clone()
                    })).then(function (_middleware$post) {
                      response = _middleware$post || response;
                    });
                  }
                }();

                if (_temp2 && _temp2.then) return _temp2.then(function () {});
              });

              return _temp3 && _temp3.then ? _temp3.then(function () {
                return response;
              }) : response;
            });
          };

          var fetchParams = {
            url: url,
            init: init
          };

          var _temp7 = _forOf(_this.middleware, function (middleware) {
            var _temp = function () {
              if (middleware.pre) {
                return Promise.resolve(middleware.pre(_extends({
                  fetch: _this.fetchApi
                }, fetchParams))).then(function (_middleware$pre) {
                  fetchParams = _middleware$pre || fetchParams;
                });
              }
            }();

            if (_temp && _temp.then) return _temp.then(function () {});
          });

          return Promise.resolve(_temp7 && _temp7.then ? _temp7.then(_temp6) : _temp6(_temp7));
        } catch (e) {
          return Promise.reject(e);
        }
      };

      this.configuration = configuration;
      this.middleware = configuration.middleware;
    }

    var _proto = BaseAPI.prototype;

    _proto.withMiddleware = function withMiddleware() {
      var _next$middleware;

      var next = this.clone();
      next.middleware = (_next$middleware = next.middleware).concat.apply(_next$middleware, [].slice.call(arguments));
      return next;
    };

    _proto.withPreMiddleware = function withPreMiddleware() {
      var middlewares = [].slice.call(arguments).map(function (pre) {
        return {
          pre: pre
        };
      });
      return this.withMiddleware.apply(this, middlewares);
    };

    _proto.withPostMiddleware = function withPostMiddleware() {
      var middlewares = [].slice.call(arguments).map(function (post) {
        return {
          post: post
        };
      });
      return this.withMiddleware.apply(this, middlewares);
    };

    _proto.request = function request(context, initOverrides) {
      try {
        var _this3 = this;

        var _this3$createFetchPar = _this3.createFetchParams(context, initOverrides),
            url = _this3$createFetchPar.url,
            init = _this3$createFetchPar.init;

        return Promise.resolve(_this3.fetchApi(url, init)).then(function (response) {
          if (response.status >= 200 && response.status < 300) {
            return response;
          }

          throw response;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.createFetchParams = function createFetchParams(context, initOverrides) {
      var url = this.configuration.basePath + context.path;

      if (context.query !== undefined && Object.keys(context.query).length !== 0) {
        // only add the querystring to the URL if there are query parameters.
        // this is done to avoid urls ending with a "?" character which buggy webservers
        // do not handle correctly sometimes.
        url += '?' + this.configuration.queryParamsStringify(context.query);
      }

      var body = typeof FormData !== "undefined" && context.body instanceof FormData || context.body instanceof URLSearchParams || isBlob(context.body) ? context.body : JSON.stringify(context.body);
      var headers = Object.assign({}, this.configuration.headers, context.headers);

      var init = _extends({
        method: context.method,
        headers: headers,
        body: body,
        credentials: this.configuration.credentials
      }, initOverrides);

      return {
        url: url,
        init: init
      };
    };

    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    _proto.clone = function clone() {
      var constructor = this.constructor;
      var next = new constructor(this.configuration);
      next.middleware = this.middleware.slice();
      return next;
    };

    return BaseAPI;
  }();
  var RequiredError = /*#__PURE__*/function (_Error) {
    _inheritsLoose(RequiredError, _Error);

    function RequiredError(field, msg) {
      var _this4;

      _this4 = _Error.call(this, msg) || this;
      _this4.field = void 0;
      _this4.name = "RequiredError";
      _this4.field = field;
      return _this4;
    }

    return RequiredError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  var COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|"
  };
  var Configuration = /*#__PURE__*/function () {
    function Configuration(configuration) {
      if (configuration === void 0) {
        configuration = {};
      }

      this.configuration = void 0;
      this.configuration = configuration;
    }

    _createClass(Configuration, [{
      key: "basePath",
      get: function get() {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
      }
    }, {
      key: "fetchApi",
      get: function get() {
        return this.configuration.fetchApi;
      }
    }, {
      key: "middleware",
      get: function get() {
        return this.configuration.middleware || [];
      }
    }, {
      key: "queryParamsStringify",
      get: function get() {
        return this.configuration.queryParamsStringify || querystring;
      }
    }, {
      key: "username",
      get: function get() {
        return this.configuration.username;
      }
    }, {
      key: "password",
      get: function get() {
        return this.configuration.password;
      }
    }, {
      key: "apiKey",
      get: function get() {
        var apiKey = this.configuration.apiKey;

        if (apiKey) {
          return typeof apiKey === 'function' ? apiKey : function () {
            return apiKey;
          };
        }

        return undefined;
      }
    }, {
      key: "accessToken",
      get: function get() {
        var accessToken = this.configuration.accessToken;

        if (accessToken) {
          return typeof accessToken === 'function' ? accessToken : function () {
            return Promise.resolve(accessToken);
          };
        }

        return undefined;
      }
    }, {
      key: "headers",
      get: function get() {
        return this.configuration.headers;
      }
    }, {
      key: "credentials",
      get: function get() {
        return this.configuration.credentials;
      }
    }]);

    return Configuration;
  }();
  function exists(json, key) {
    var value = json[key];
    return value !== null && value !== undefined;
  }
  function querystring(params, prefix) {
    if (prefix === void 0) {
      prefix = '';
    }

    return Object.keys(params).map(function (key) {
      var fullKey = prefix + (prefix.length ? "[" + key + "]" : key);
      var value = params[key];

      if (value instanceof Array) {
        var multiValue = value.map(function (singleValue) {
          return encodeURIComponent(String(singleValue));
        }).join("&" + encodeURIComponent(fullKey) + "=");
        return encodeURIComponent(fullKey) + "=" + multiValue;
      }

      if (value instanceof Date) {
        return encodeURIComponent(fullKey) + "=" + encodeURIComponent(value.toISOString());
      }

      if (value instanceof Object) {
        return querystring(value, fullKey);
      }

      return encodeURIComponent(fullKey) + "=" + encodeURIComponent(String(value));
    }).filter(function (part) {
      return part.length > 0;
    }).join('&');
  }
  function mapValues(data, fn) {
    return Object.keys(data).reduce(function (acc, key) {
      var _extends2;

      return _extends({}, acc, (_extends2 = {}, _extends2[key] = fn(data[key]), _extends2));
    }, {});
  }
  function canConsumeForm(consumes) {
    for (var _iterator = _createForOfIteratorHelperLoose(consumes), _step; !(_step = _iterator()).done;) {
      var consume = _step.value;

      if ('multipart/form-data' === consume.contentType) {
        return true;
      }
    }

    return false;
  }
  var JSONApiResponse = /*#__PURE__*/function () {
    function JSONApiResponse(raw, transformer) {
      if (transformer === void 0) {
        transformer = function transformer(jsonValue) {
          return jsonValue;
        };
      }

      this.raw = void 0;
      this.transformer = void 0;
      this.raw = raw;
      this.transformer = transformer;
    }

    var _proto2 = JSONApiResponse.prototype;

    _proto2.value = function value() {
      try {
        var _this6 = this;

        var _transformer2 = _this6.transformer;
        return Promise.resolve(_this6.raw.json()).then(function (_this5$raw$json) {
          return _transformer2.call(_this6, _this5$raw$json);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    return JSONApiResponse;
  }();
  var VoidApiResponse = /*#__PURE__*/function () {
    function VoidApiResponse(raw) {
      this.raw = void 0;
      this.raw = raw;
    }

    var _proto3 = VoidApiResponse.prototype;

    _proto3.value = function value() {
      return Promise.resolve(undefined);
    };

    return VoidApiResponse;
  }();
  var BlobApiResponse = /*#__PURE__*/function () {
    function BlobApiResponse(raw) {
      this.raw = void 0;
      this.raw = raw;
    }

    var _proto4 = BlobApiResponse.prototype;

    _proto4.value = function value() {
      try {
        var _this8 = this;

        return Promise.resolve(_this8.raw.blob());
      } catch (e) {
        return Promise.reject(e);
      }
    };

    return BlobApiResponse;
  }();
  var TextApiResponse = /*#__PURE__*/function () {
    function TextApiResponse(raw) {
      this.raw = void 0;
      this.raw = raw;
    }

    var _proto5 = TextApiResponse.prototype;

    _proto5.value = function value() {
      try {
        var _this10 = this;

        return Promise.resolve(_this10.raw.text());
      } catch (e) {
        return Promise.reject(e);
      }
    };

    return TextApiResponse;
  }();

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function AccountDataResponseFromJSON(json) {
    return AccountDataResponseFromJSONTyped(json);
  }
  function AccountDataResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'balance': json['balance'],
      'locked': json['locked'],
      'unlock_height': json['unlock_height'],
      'nonce': json['nonce'],
      'balance_proof': json['balance_proof'],
      'nonce_proof': json['nonce_proof']
    };
  }
  function AccountDataResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'balance': value.balance,
      'locked': value.locked,
      'unlock_height': value.unlock_height,
      'nonce': value.nonce,
      'balance_proof': value.balance_proof,
      'nonce_proof': value.nonce_proof
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function AddressAssetsListResponseFromJSON(json) {
    return AddressAssetsListResponseFromJSONTyped(json);
  }
  function AddressAssetsListResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'limit': json['limit'],
      'offset': json['offset'],
      'total': json['total'],
      'results': json['results']
    };
  }
  function AddressAssetsListResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'limit': value.limit,
      'offset': value.offset,
      'total': value.total,
      'results': value.results
    };
  }

  /* tslint:disable */
  function AddressBalanceResponseFromJSON(json) {
    return AddressBalanceResponseFromJSONTyped(json);
  }
  function AddressBalanceResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'stx': StxBalanceFromJSON(json['stx']),
      'fungible_tokens': json['fungible_tokens'],
      'non_fungible_tokens': json['non_fungible_tokens'],
      'token_offering_locked': !exists(json, 'token_offering_locked') ? undefined : AddressTokenOfferingLockedFromJSON(json['token_offering_locked'])
    };
  }
  function AddressBalanceResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'stx': StxBalanceToJSON(value.stx),
      'fungible_tokens': value.fungible_tokens,
      'non_fungible_tokens': value.non_fungible_tokens,
      'token_offering_locked': AddressTokenOfferingLockedToJSON(value.token_offering_locked)
    };
  }

  /* tslint:disable */
  function AddressNftListResponseFromJSON(json) {
    return AddressNftListResponseFromJSONTyped(json);
  }
  function AddressNftListResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'limit': json['limit'],
      'offset': json['offset'],
      'total': json['total'],
      'nft_events': json['nft_events'].map(NftEventFromJSON)
    };
  }
  function AddressNftListResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'limit': value.limit,
      'offset': value.offset,
      'total': value.total,
      'nft_events': value.nft_events.map(NftEventToJSON)
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function AddressNftListResponseValueFromJSON(json) {
    return AddressNftListResponseValueFromJSONTyped(json);
  }
  function AddressNftListResponseValueFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'hex': json['hex'],
      'repr': json['repr']
    };
  }
  function AddressNftListResponseValueToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'hex': value.hex,
      'repr': value.repr
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function AddressNoncesFromJSON(json) {
    return AddressNoncesFromJSONTyped(json);
  }
  function AddressNoncesFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'last_mempool_tx_nonce': json['last_mempool_tx_nonce'],
      'last_executed_tx_nonce': json['last_executed_tx_nonce'],
      'possible_next_nonce': json['possible_next_nonce'],
      'detected_missing_nonces': json['detected_missing_nonces']
    };
  }
  function AddressNoncesToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'last_mempool_tx_nonce': value.last_mempool_tx_nonce,
      'last_executed_tx_nonce': value.last_executed_tx_nonce,
      'possible_next_nonce': value.possible_next_nonce,
      'detected_missing_nonces': value.detected_missing_nonces
    };
  }

  /* tslint:disable */
  function AddressStxInboundListResponseFromJSON(json) {
    return AddressStxInboundListResponseFromJSONTyped(json);
  }
  function AddressStxInboundListResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'limit': json['limit'],
      'offset': json['offset'],
      'total': json['total'],
      'results': json['results'].map(InboundStxTransferFromJSON)
    };
  }
  function AddressStxInboundListResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'limit': value.limit,
      'offset': value.offset,
      'total': value.total,
      'results': value.results.map(InboundStxTransferToJSON)
    };
  }

  /* tslint:disable */
  function AddressTokenOfferingLockedFromJSON(json) {
    return AddressTokenOfferingLockedFromJSONTyped(json);
  }
  function AddressTokenOfferingLockedFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'total_locked': json['total_locked'],
      'total_unlocked': json['total_unlocked'],
      'unlock_schedule': json['unlock_schedule'].map(AddressUnlockScheduleFromJSON)
    };
  }
  function AddressTokenOfferingLockedToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'total_locked': value.total_locked,
      'total_unlocked': value.total_unlocked,
      'unlock_schedule': value.unlock_schedule.map(AddressUnlockScheduleToJSON)
    };
  }

  /* tslint:disable */
  function AddressTransactionWithTransfersFromJSON(json) {
    return AddressTransactionWithTransfersFromJSONTyped(json);
  }
  function AddressTransactionWithTransfersFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'tx': json['tx'],
      'stx_sent': json['stx_sent'],
      'stx_received': json['stx_received'],
      'stx_transfers': json['stx_transfers'].map(AddressTransactionWithTransfersStxTransfersFromJSON),
      'ft_transfers': !exists(json, 'ft_transfers') ? undefined : json['ft_transfers'].map(AddressTransactionWithTransfersFtTransfersFromJSON),
      'nft_transfers': !exists(json, 'nft_transfers') ? undefined : json['nft_transfers'].map(AddressTransactionWithTransfersNftTransfersFromJSON)
    };
  }
  function AddressTransactionWithTransfersToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'tx': value.tx,
      'stx_sent': value.stx_sent,
      'stx_received': value.stx_received,
      'stx_transfers': value.stx_transfers.map(AddressTransactionWithTransfersStxTransfersToJSON),
      'ft_transfers': value.ft_transfers === undefined ? undefined : value.ft_transfers.map(AddressTransactionWithTransfersFtTransfersToJSON),
      'nft_transfers': value.nft_transfers === undefined ? undefined : value.nft_transfers.map(AddressTransactionWithTransfersNftTransfersToJSON)
    };
  }

  /* tslint:disable */
  function AddressTransactionWithTransfersFtTransfersFromJSON(json) {
    return AddressTransactionWithTransfersFtTransfersFromJSONTyped(json);
  }
  function AddressTransactionWithTransfersFtTransfersFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'asset_identifier': json['asset_identifier'],
      'amount': json['amount'],
      'sender': !exists(json, 'sender') ? undefined : json['sender'],
      'recipient': !exists(json, 'recipient') ? undefined : json['recipient']
    };
  }
  function AddressTransactionWithTransfersFtTransfersToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'asset_identifier': value.asset_identifier,
      'amount': value.amount,
      'sender': value.sender,
      'recipient': value.recipient
    };
  }

  /* tslint:disable */
  function AddressTransactionWithTransfersNftTransfersFromJSON(json) {
    return AddressTransactionWithTransfersNftTransfersFromJSONTyped(json);
  }
  function AddressTransactionWithTransfersNftTransfersFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'asset_identifier': json['asset_identifier'],
      'value': AddressTransactionWithTransfersValueFromJSON(json['value']),
      'sender': !exists(json, 'sender') ? undefined : json['sender'],
      'recipient': !exists(json, 'recipient') ? undefined : json['recipient']
    };
  }
  function AddressTransactionWithTransfersNftTransfersToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'asset_identifier': value.asset_identifier,
      'value': AddressTransactionWithTransfersValueToJSON(value.value),
      'sender': value.sender,
      'recipient': value.recipient
    };
  }

  /* tslint:disable */
  function AddressTransactionWithTransfersStxTransfersFromJSON(json) {
    return AddressTransactionWithTransfersStxTransfersFromJSONTyped(json);
  }
  function AddressTransactionWithTransfersStxTransfersFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'amount': json['amount'],
      'sender': !exists(json, 'sender') ? undefined : json['sender'],
      'recipient': !exists(json, 'recipient') ? undefined : json['recipient']
    };
  }
  function AddressTransactionWithTransfersStxTransfersToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'amount': value.amount,
      'sender': value.sender,
      'recipient': value.recipient
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function AddressTransactionWithTransfersValueFromJSON(json) {
    return AddressTransactionWithTransfersValueFromJSONTyped(json);
  }
  function AddressTransactionWithTransfersValueFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'hex': json['hex'],
      'repr': json['repr']
    };
  }
  function AddressTransactionWithTransfersValueToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'hex': value.hex,
      'repr': value.repr
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function AddressTransactionsListResponseFromJSON(json) {
    return AddressTransactionsListResponseFromJSONTyped(json);
  }
  function AddressTransactionsListResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'limit': json['limit'],
      'offset': json['offset'],
      'total': json['total'],
      'results': json['results']
    };
  }
  function AddressTransactionsListResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'limit': value.limit,
      'offset': value.offset,
      'total': value.total,
      'results': value.results
    };
  }

  /* tslint:disable */
  function AddressTransactionsWithTransfersListResponseFromJSON(json) {
    return AddressTransactionsWithTransfersListResponseFromJSONTyped(json);
  }
  function AddressTransactionsWithTransfersListResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'limit': json['limit'],
      'offset': json['offset'],
      'total': json['total'],
      'results': json['results'].map(AddressTransactionWithTransfersFromJSON)
    };
  }
  function AddressTransactionsWithTransfersListResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'limit': value.limit,
      'offset': value.offset,
      'total': value.total,
      'results': value.results.map(AddressTransactionWithTransfersToJSON)
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function AddressUnlockScheduleFromJSON(json) {
    return AddressUnlockScheduleFromJSONTyped(json);
  }
  function AddressUnlockScheduleFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'amount': json['amount'],
      'block_height': json['block_height']
    };
  }
  function AddressUnlockScheduleToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'amount': value.amount,
      'block_height': value.block_height
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function BlockFromJSON(json) {
    return BlockFromJSONTyped(json);
  }
  function BlockFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'canonical': json['canonical'],
      'height': json['height'],
      'hash': json['hash'],
      'index_block_hash': json['index_block_hash'],
      'parent_block_hash': json['parent_block_hash'],
      'burn_block_time': json['burn_block_time'],
      'burn_block_time_iso': json['burn_block_time_iso'],
      'burn_block_hash': json['burn_block_hash'],
      'burn_block_height': json['burn_block_height'],
      'miner_txid': json['miner_txid'],
      'parent_microblock_hash': json['parent_microblock_hash'],
      'parent_microblock_sequence': json['parent_microblock_sequence'],
      'txs': json['txs'],
      'microblocks_accepted': json['microblocks_accepted'],
      'microblocks_streamed': json['microblocks_streamed'],
      'execution_cost_read_count': json['execution_cost_read_count'],
      'execution_cost_read_length': json['execution_cost_read_length'],
      'execution_cost_runtime': json['execution_cost_runtime'],
      'execution_cost_write_count': json['execution_cost_write_count'],
      'execution_cost_write_length': json['execution_cost_write_length'],
      'microblock_tx_count': json['microblock_tx_count']
    };
  }
  function BlockToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'canonical': value.canonical,
      'height': value.height,
      'hash': value.hash,
      'index_block_hash': value.index_block_hash,
      'parent_block_hash': value.parent_block_hash,
      'burn_block_time': value.burn_block_time,
      'burn_block_time_iso': value.burn_block_time_iso,
      'burn_block_hash': value.burn_block_hash,
      'burn_block_height': value.burn_block_height,
      'miner_txid': value.miner_txid,
      'parent_microblock_hash': value.parent_microblock_hash,
      'parent_microblock_sequence': value.parent_microblock_sequence,
      'txs': value.txs,
      'microblocks_accepted': value.microblocks_accepted,
      'microblocks_streamed': value.microblocks_streamed,
      'execution_cost_read_count': value.execution_cost_read_count,
      'execution_cost_read_length': value.execution_cost_read_length,
      'execution_cost_runtime': value.execution_cost_runtime,
      'execution_cost_write_count': value.execution_cost_write_count,
      'execution_cost_write_length': value.execution_cost_write_length,
      'microblock_tx_count': value.microblock_tx_count
    };
  }

  /* tslint:disable */
  function BlockListResponseFromJSON(json) {
    return BlockListResponseFromJSONTyped(json);
  }
  function BlockListResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'limit': json['limit'],
      'offset': json['offset'],
      'total': json['total'],
      'results': json['results'].map(BlockFromJSON)
    };
  }
  function BlockListResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'limit': value.limit,
      'offset': value.offset,
      'total': value.total,
      'results': value.results.map(BlockToJSON)
    };
  }

  /* tslint:disable */
  function BnsErrorFromJSON(json) {
    return BnsErrorFromJSONTyped(json);
  }
  function BnsErrorFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'error': !exists(json, 'error') ? undefined : json['error']
    };
  }
  function BnsErrorToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'error': value.error
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function BnsGetAllNamespacesResponseFromJSON(json) {
    return BnsGetAllNamespacesResponseFromJSONTyped(json);
  }
  function BnsGetAllNamespacesResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'namespaces': json['namespaces']
    };
  }
  function BnsGetAllNamespacesResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'namespaces': value.namespaces
    };
  }

  /* tslint:disable */
  function BnsGetNameInfoResponseFromJSON(json) {
    return BnsGetNameInfoResponseFromJSONTyped(json);
  }
  function BnsGetNameInfoResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'address': json['address'],
      'blockchain': json['blockchain'],
      'expire_block': !exists(json, 'expire_block') ? undefined : json['expire_block'],
      'grace_period': !exists(json, 'grace_period') ? undefined : json['grace_period'],
      'last_txid': json['last_txid'],
      'resolver': !exists(json, 'resolver') ? undefined : json['resolver'],
      'status': json['status'],
      'zonefile': json['zonefile'],
      'zonefile_hash': json['zonefile_hash']
    };
  }
  function BnsGetNameInfoResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'address': value.address,
      'blockchain': value.blockchain,
      'expire_block': value.expire_block,
      'grace_period': value.grace_period,
      'last_txid': value.last_txid,
      'resolver': value.resolver,
      'status': value.status,
      'zonefile': value.zonefile,
      'zonefile_hash': value.zonefile_hash
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function BnsGetNamePriceResponseFromJSON(json) {
    return BnsGetNamePriceResponseFromJSONTyped(json);
  }
  function BnsGetNamePriceResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'units': json['units'],
      'amount': json['amount']
    };
  }
  function BnsGetNamePriceResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'units': value.units,
      'amount': value.amount
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function BnsGetNamespacePriceResponseFromJSON(json) {
    return BnsGetNamespacePriceResponseFromJSONTyped(json);
  }
  function BnsGetNamespacePriceResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'units': json['units'],
      'amount': json['amount']
    };
  }
  function BnsGetNamespacePriceResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'units': value.units,
      'amount': value.amount
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function BnsNamesOwnByAddressResponseFromJSON(json) {
    return BnsNamesOwnByAddressResponseFromJSONTyped(json);
  }
  function BnsNamesOwnByAddressResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'names': json['names']
    };
  }
  function BnsNamesOwnByAddressResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'names': value.names
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function BurnchainRewardFromJSON(json) {
    return BurnchainRewardFromJSONTyped(json);
  }
  function BurnchainRewardFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'canonical': json['canonical'],
      'burn_block_hash': json['burn_block_hash'],
      'burn_block_height': json['burn_block_height'],
      'burn_amount': json['burn_amount'],
      'reward_recipient': json['reward_recipient'],
      'reward_amount': json['reward_amount'],
      'reward_index': json['reward_index']
    };
  }
  function BurnchainRewardToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'canonical': value.canonical,
      'burn_block_hash': value.burn_block_hash,
      'burn_block_height': value.burn_block_height,
      'burn_amount': value.burn_amount,
      'reward_recipient': value.reward_recipient,
      'reward_amount': value.reward_amount,
      'reward_index': value.reward_index
    };
  }

  /* tslint:disable */
  function BurnchainRewardListResponseFromJSON(json) {
    return BurnchainRewardListResponseFromJSONTyped(json);
  }
  function BurnchainRewardListResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'limit': json['limit'],
      'offset': json['offset'],
      'results': json['results'].map(BurnchainRewardFromJSON)
    };
  }
  function BurnchainRewardListResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'limit': value.limit,
      'offset': value.offset,
      'results': value.results.map(BurnchainRewardToJSON)
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function BurnchainRewardSlotHolderFromJSON(json) {
    return BurnchainRewardSlotHolderFromJSONTyped(json);
  }
  function BurnchainRewardSlotHolderFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'canonical': json['canonical'],
      'burn_block_hash': json['burn_block_hash'],
      'burn_block_height': json['burn_block_height'],
      'address': json['address'],
      'slot_index': json['slot_index']
    };
  }
  function BurnchainRewardSlotHolderToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'canonical': value.canonical,
      'burn_block_hash': value.burn_block_hash,
      'burn_block_height': value.burn_block_height,
      'address': value.address,
      'slot_index': value.slot_index
    };
  }

  /* tslint:disable */
  function BurnchainRewardSlotHolderListResponseFromJSON(json) {
    return BurnchainRewardSlotHolderListResponseFromJSONTyped(json);
  }
  function BurnchainRewardSlotHolderListResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'limit': json['limit'],
      'offset': json['offset'],
      'total': json['total'],
      'results': json['results'].map(BurnchainRewardSlotHolderFromJSON)
    };
  }
  function BurnchainRewardSlotHolderListResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'limit': value.limit,
      'offset': value.offset,
      'total': value.total,
      'results': value.results.map(BurnchainRewardSlotHolderToJSON)
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function BurnchainRewardsTotalFromJSON(json) {
    return BurnchainRewardsTotalFromJSONTyped(json);
  }
  function BurnchainRewardsTotalFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'reward_recipient': json['reward_recipient'],
      'reward_amount': json['reward_amount']
    };
  }
  function BurnchainRewardsTotalToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'reward_recipient': value.reward_recipient,
      'reward_amount': value.reward_amount
    };
  }

  /* tslint:disable */
  function ChainTipFromJSON(json) {
    return ChainTipFromJSONTyped(json);
  }
  function ChainTipFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'block_height': json['block_height'],
      'block_hash': json['block_hash'],
      'index_block_hash': json['index_block_hash'],
      'microblock_hash': !exists(json, 'microblock_hash') ? undefined : json['microblock_hash'],
      'microblock_sequence': !exists(json, 'microblock_sequence') ? undefined : json['microblock_sequence'],
      'burn_block_height': json['burn_block_height']
    };
  }
  function ChainTipToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'block_height': value.block_height,
      'block_hash': value.block_hash,
      'index_block_hash': value.index_block_hash,
      'microblock_hash': value.microblock_hash,
      'microblock_sequence': value.microblock_sequence,
      'burn_block_height': value.burn_block_height
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function ContractInterfaceResponseFromJSON(json) {
    return ContractInterfaceResponseFromJSONTyped(json);
  }
  function ContractInterfaceResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'functions': json['functions'],
      'variables': json['variables'],
      'maps': json['maps'],
      'fungible_tokens': json['fungible_tokens'],
      'non_fungible_tokens': json['non_fungible_tokens']
    };
  }
  function ContractInterfaceResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'functions': value.functions,
      'variables': value.variables,
      'maps': value.maps,
      'fungible_tokens': value.fungible_tokens,
      'non_fungible_tokens': value.non_fungible_tokens
    };
  }

  /* tslint:disable */
  function ContractListResponseFromJSON(json) {
    return ContractListResponseFromJSONTyped(json);
  }
  function ContractListResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'limit': json['limit'],
      'offset': json['offset'],
      'results': json['results'].map(SmartContractFromJSON)
    };
  }
  function ContractListResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'limit': value.limit,
      'offset': value.offset,
      'results': value.results.map(SmartContractToJSON)
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function ContractSourceResponseFromJSON(json) {
    return ContractSourceResponseFromJSONTyped(json);
  }
  function ContractSourceResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'source': json['source'],
      'publish_height': json['publish_height'],
      'proof': json['proof']
    };
  }
  function ContractSourceResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'source': value.source,
      'publish_height': value.publish_height,
      'proof': value.proof
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function CoreNodeInfoResponseFromJSON(json) {
    return CoreNodeInfoResponseFromJSONTyped(json);
  }
  function CoreNodeInfoResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'peer_version': json['peer_version'],
      'pox_consensus': json['pox_consensus'],
      'burn_block_height': json['burn_block_height'],
      'stable_pox_consensus': json['stable_pox_consensus'],
      'stable_burn_block_height': json['stable_burn_block_height'],
      'server_version': json['server_version'],
      'network_id': json['network_id'],
      'parent_network_id': json['parent_network_id'],
      'stacks_tip_height': json['stacks_tip_height'],
      'stacks_tip': json['stacks_tip'],
      'stacks_tip_consensus_hash': json['stacks_tip_consensus_hash'],
      'unanchored_tip': json['unanchored_tip'],
      'exit_at_block_height': json['exit_at_block_height']
    };
  }
  function CoreNodeInfoResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'peer_version': value.peer_version,
      'pox_consensus': value.pox_consensus,
      'burn_block_height': value.burn_block_height,
      'stable_pox_consensus': value.stable_pox_consensus,
      'stable_burn_block_height': value.stable_burn_block_height,
      'server_version': value.server_version,
      'network_id': value.network_id,
      'parent_network_id': value.parent_network_id,
      'stacks_tip_height': value.stacks_tip_height,
      'stacks_tip': value.stacks_tip,
      'stacks_tip_consensus_hash': value.stacks_tip_consensus_hash,
      'unanchored_tip': value.unanchored_tip,
      'exit_at_block_height': value.exit_at_block_height
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function CoreNodePoxResponseFromJSON(json) {
    return CoreNodePoxResponseFromJSONTyped(json);
  }
  function CoreNodePoxResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'contract_id': json['contract_id'],
      'first_burnchain_block_height': json['first_burnchain_block_height'],
      'min_amount_ustx': json['min_amount_ustx'],
      'registration_window_length': json['registration_window_length'],
      'rejection_fraction': json['rejection_fraction'],
      'reward_cycle_id': json['reward_cycle_id'],
      'reward_cycle_length': json['reward_cycle_length'],
      'rejection_votes_left_required': json['rejection_votes_left_required'],
      'total_liquid_supply_ustx': json['total_liquid_supply_ustx']
    };
  }
  function CoreNodePoxResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'contract_id': value.contract_id,
      'first_burnchain_block_height': value.first_burnchain_block_height,
      'min_amount_ustx': value.min_amount_ustx,
      'registration_window_length': value.registration_window_length,
      'rejection_fraction': value.rejection_fraction,
      'reward_cycle_id': value.reward_cycle_id,
      'reward_cycle_length': value.reward_cycle_length,
      'rejection_votes_left_required': value.rejection_votes_left_required,
      'total_liquid_supply_ustx': value.total_liquid_supply_ustx
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function FeeRateFromJSON(json) {
    return FeeRateFromJSONTyped(json);
  }
  function FeeRateFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'fee_rate': json['fee_rate']
    };
  }
  function FeeRateToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'fee_rate': value.fee_rate
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function FeeRateRequestFromJSON(json) {
    return FeeRateRequestFromJSONTyped(json);
  }
  function FeeRateRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'transaction': json['transaction']
    };
  }
  function FeeRateRequestToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'transaction': value.transaction
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function FungibleTokenMetadataFromJSON(json) {
    return FungibleTokenMetadataFromJSONTyped(json);
  }
  function FungibleTokenMetadataFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'token_uri': json['token_uri'],
      'name': json['name'],
      'description': json['description'],
      'image_uri': json['image_uri'],
      'image_canonical_uri': json['image_canonical_uri'],
      'symbol': json['symbol'],
      'decimals': json['decimals'],
      'tx_id': json['tx_id'],
      'sender_address': json['sender_address']
    };
  }
  function FungibleTokenMetadataToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'token_uri': value.token_uri,
      'name': value.name,
      'description': value.description,
      'image_uri': value.image_uri,
      'image_canonical_uri': value.image_canonical_uri,
      'symbol': value.symbol,
      'decimals': value.decimals,
      'tx_id': value.tx_id,
      'sender_address': value.sender_address
    };
  }

  /* tslint:disable */
  function FungibleTokensMetadataListFromJSON(json) {
    return FungibleTokensMetadataListFromJSONTyped(json);
  }
  function FungibleTokensMetadataListFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'limit': json['limit'],
      'offset': json['offset'],
      'total': json['total'],
      'results': json['results'].map(FungibleTokenMetadataFromJSON)
    };
  }
  function FungibleTokensMetadataListToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'limit': value.limit,
      'offset': value.offset,
      'total': value.total,
      'results': value.results.map(FungibleTokenMetadataToJSON)
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function GetRawTransactionResultFromJSON(json) {
    return GetRawTransactionResultFromJSONTyped(json);
  }
  function GetRawTransactionResultFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'raw_tx': json['raw_tx']
    };
  }
  function GetRawTransactionResultToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'raw_tx': value.raw_tx
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function GetStxSupplyLegacyFormatResponseFromJSON(json) {
    return GetStxSupplyLegacyFormatResponseFromJSONTyped(json);
  }
  function GetStxSupplyLegacyFormatResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'unlockedPercent': json['unlockedPercent'],
      'totalStacks': json['totalStacks'],
      'totalStacksFormatted': json['totalStacksFormatted'],
      'unlockedSupply': json['unlockedSupply'],
      'unlockedSupplyFormatted': json['unlockedSupplyFormatted'],
      'blockHeight': json['blockHeight']
    };
  }
  function GetStxSupplyLegacyFormatResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'unlockedPercent': value.unlockedPercent,
      'totalStacks': value.totalStacks,
      'totalStacksFormatted': value.totalStacksFormatted,
      'unlockedSupply': value.unlockedSupply,
      'unlockedSupplyFormatted': value.unlockedSupplyFormatted,
      'blockHeight': value.blockHeight
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function GetStxSupplyResponseFromJSON(json) {
    return GetStxSupplyResponseFromJSONTyped(json);
  }
  function GetStxSupplyResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'unlocked_percent': json['unlocked_percent'],
      'total_stx': json['total_stx'],
      'unlocked_stx': json['unlocked_stx'],
      'block_height': json['block_height']
    };
  }
  function GetStxSupplyResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'unlocked_percent': value.unlocked_percent,
      'total_stx': value.total_stx,
      'unlocked_stx': value.unlocked_stx,
      'block_height': value.block_height
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */

  /**
  * @export
  * @enum {string}
  */
  exports.InboundStxTransferTransferTypeEnum = void 0;

  (function (InboundStxTransferTransferTypeEnum) {
    InboundStxTransferTransferTypeEnum["bulk_send"] = "bulk-send";
    InboundStxTransferTransferTypeEnum["stx_transfer"] = "stx-transfer";
    InboundStxTransferTransferTypeEnum["stx_transfer_memo"] = "stx-transfer-memo";
  })(exports.InboundStxTransferTransferTypeEnum || (exports.InboundStxTransferTransferTypeEnum = {}));

  function InboundStxTransferFromJSON(json) {
    return InboundStxTransferFromJSONTyped(json);
  }
  function InboundStxTransferFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'sender': json['sender'],
      'amount': json['amount'],
      'memo': json['memo'],
      'block_height': json['block_height'],
      'tx_id': json['tx_id'],
      'transfer_type': json['transfer_type'],
      'tx_index': json['tx_index']
    };
  }
  function InboundStxTransferToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'sender': value.sender,
      'amount': value.amount,
      'memo': value.memo,
      'block_height': value.block_height,
      'tx_id': value.tx_id,
      'transfer_type': value.transfer_type,
      'tx_index': value.tx_index
    };
  }

  /* tslint:disable */
  function InlineObjectFromJSON(json) {
    return InlineObjectFromJSONTyped(json);
  }
  function InlineObjectFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'address': !exists(json, 'address') ? undefined : json['address'],
      'stacking': !exists(json, 'stacking') ? undefined : json['stacking']
    };
  }
  function InlineObjectToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'address': value.address,
      'stacking': value.stacking
    };
  }

  /* tslint:disable */
  function InlineObject1FromJSON(json) {
    return InlineObject1FromJSONTyped(json);
  }
  function InlineObject1FromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'address': !exists(json, 'address') ? undefined : json['address']
    };
  }
  function InlineObject1ToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'address': value.address
    };
  }

  /* tslint:disable */
  function MapEntryResponseFromJSON(json) {
    return MapEntryResponseFromJSONTyped(json);
  }
  function MapEntryResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'data': json['data'],
      'proof': !exists(json, 'proof') ? undefined : json['proof']
    };
  }
  function MapEntryResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'data': value.data,
      'proof': value.proof
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function MempoolTransactionListResponseFromJSON(json) {
    return MempoolTransactionListResponseFromJSONTyped(json);
  }
  function MempoolTransactionListResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'limit': json['limit'],
      'offset': json['offset'],
      'total': json['total'],
      'results': json['results']
    };
  }
  function MempoolTransactionListResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'limit': value.limit,
      'offset': value.offset,
      'total': value.total,
      'results': value.results
    };
  }

  /* tslint:disable */
  function MempoolTransactionStatsResponseFromJSON(json) {
    return MempoolTransactionStatsResponseFromJSONTyped(json);
  }
  function MempoolTransactionStatsResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'tx_type_counts': MempoolTransactionStatsResponseTxTypeCountsFromJSON(json['tx_type_counts']),
      'tx_simple_fee_averages': MempoolTransactionStatsResponseTxSimpleFeeAveragesFromJSON(json['tx_simple_fee_averages']),
      'tx_ages': MempoolTransactionStatsResponseTxAgesFromJSON(json['tx_ages']),
      'tx_byte_sizes': MempoolTransactionStatsResponseTxByteSizesFromJSON(json['tx_byte_sizes'])
    };
  }
  function MempoolTransactionStatsResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'tx_type_counts': MempoolTransactionStatsResponseTxTypeCountsToJSON(value.tx_type_counts),
      'tx_simple_fee_averages': MempoolTransactionStatsResponseTxSimpleFeeAveragesToJSON(value.tx_simple_fee_averages),
      'tx_ages': MempoolTransactionStatsResponseTxAgesToJSON(value.tx_ages),
      'tx_byte_sizes': MempoolTransactionStatsResponseTxByteSizesToJSON(value.tx_byte_sizes)
    };
  }

  /* tslint:disable */
  function MempoolTransactionStatsResponseTxAgesFromJSON(json) {
    return MempoolTransactionStatsResponseTxAgesFromJSONTyped(json);
  }
  function MempoolTransactionStatsResponseTxAgesFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'token_transfer': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSON(json['token_transfer']),
      'smart_contract': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSON(json['smart_contract']),
      'contract_call': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSON(json['contract_call']),
      'poison_microblock': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSON(json['poison_microblock'])
    };
  }
  function MempoolTransactionStatsResponseTxAgesToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'token_transfer': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferToJSON(value.token_transfer),
      'smart_contract': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferToJSON(value.smart_contract),
      'contract_call': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferToJSON(value.contract_call),
      'poison_microblock': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferToJSON(value.poison_microblock)
    };
  }

  /* tslint:disable */
  function MempoolTransactionStatsResponseTxByteSizesFromJSON(json) {
    return MempoolTransactionStatsResponseTxByteSizesFromJSONTyped(json);
  }
  function MempoolTransactionStatsResponseTxByteSizesFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'token_transfer': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSON(json['token_transfer']),
      'smart_contract': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSON(json['smart_contract']),
      'contract_call': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSON(json['contract_call']),
      'poison_microblock': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSON(json['poison_microblock'])
    };
  }
  function MempoolTransactionStatsResponseTxByteSizesToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'token_transfer': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferToJSON(value.token_transfer),
      'smart_contract': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferToJSON(value.smart_contract),
      'contract_call': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferToJSON(value.contract_call),
      'poison_microblock': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferToJSON(value.poison_microblock)
    };
  }

  /* tslint:disable */
  function MempoolTransactionStatsResponseTxSimpleFeeAveragesFromJSON(json) {
    return MempoolTransactionStatsResponseTxSimpleFeeAveragesFromJSONTyped(json);
  }
  function MempoolTransactionStatsResponseTxSimpleFeeAveragesFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'token_transfer': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSON(json['token_transfer']),
      'smart_contract': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSON(json['smart_contract']),
      'contract_call': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSON(json['contract_call']),
      'poison_microblock': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSON(json['poison_microblock'])
    };
  }
  function MempoolTransactionStatsResponseTxSimpleFeeAveragesToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'token_transfer': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferToJSON(value.token_transfer),
      'smart_contract': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferToJSON(value.smart_contract),
      'contract_call': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferToJSON(value.contract_call),
      'poison_microblock': MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferToJSON(value.poison_microblock)
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSON(json) {
    return MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSONTyped(json);
  }
  function MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'p25': json['p25'],
      'p50': json['p50'],
      'p75': json['p75'],
      'p95': json['p95']
    };
  }
  function MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'p25': value.p25,
      'p50': value.p50,
      'p75': value.p75,
      'p95': value.p95
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function MempoolTransactionStatsResponseTxTypeCountsFromJSON(json) {
    return MempoolTransactionStatsResponseTxTypeCountsFromJSONTyped(json);
  }
  function MempoolTransactionStatsResponseTxTypeCountsFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'token_transfer': json['token_transfer'],
      'smart_contract': json['smart_contract'],
      'contract_call': json['contract_call'],
      'poison_microblock': json['poison_microblock']
    };
  }
  function MempoolTransactionStatsResponseTxTypeCountsToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'token_transfer': value.token_transfer,
      'smart_contract': value.smart_contract,
      'contract_call': value.contract_call,
      'poison_microblock': value.poison_microblock
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function MicroblockFromJSON(json) {
    return MicroblockFromJSONTyped(json);
  }
  function MicroblockFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'canonical': json['canonical'],
      'microblock_canonical': json['microblock_canonical'],
      'microblock_hash': json['microblock_hash'],
      'microblock_sequence': json['microblock_sequence'],
      'microblock_parent_hash': json['microblock_parent_hash'],
      'block_height': json['block_height'],
      'parent_block_height': json['parent_block_height'],
      'parent_block_hash': json['parent_block_hash'],
      'parent_burn_block_hash': json['parent_burn_block_hash'],
      'parent_burn_block_time': json['parent_burn_block_time'],
      'parent_burn_block_time_iso': json['parent_burn_block_time_iso'],
      'parent_burn_block_height': json['parent_burn_block_height'],
      'block_hash': json['block_hash'],
      'txs': json['txs']
    };
  }
  function MicroblockToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'canonical': value.canonical,
      'microblock_canonical': value.microblock_canonical,
      'microblock_hash': value.microblock_hash,
      'microblock_sequence': value.microblock_sequence,
      'microblock_parent_hash': value.microblock_parent_hash,
      'block_height': value.block_height,
      'parent_block_height': value.parent_block_height,
      'parent_block_hash': value.parent_block_hash,
      'parent_burn_block_hash': value.parent_burn_block_hash,
      'parent_burn_block_time': value.parent_burn_block_time,
      'parent_burn_block_time_iso': value.parent_burn_block_time_iso,
      'parent_burn_block_height': value.parent_burn_block_height,
      'block_hash': value.block_hash,
      'txs': value.txs
    };
  }

  /* tslint:disable */
  function MicroblockListResponseFromJSON(json) {
    return MicroblockListResponseFromJSONTyped(json);
  }
  function MicroblockListResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'limit': json['limit'],
      'offset': json['offset'],
      'total': json['total'],
      'results': json['results'].map(MicroblockFromJSON)
    };
  }
  function MicroblockListResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'limit': value.limit,
      'offset': value.offset,
      'total': value.total,
      'results': value.results.map(MicroblockToJSON)
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function NetworkBlockTimeResponseFromJSON(json) {
    return NetworkBlockTimeResponseFromJSONTyped(json);
  }
  function NetworkBlockTimeResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'target_block_time': json['target_block_time']
    };
  }
  function NetworkBlockTimeResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'target_block_time': value.target_block_time
    };
  }

  /* tslint:disable */
  function NetworkBlockTimesResponseFromJSON(json) {
    return NetworkBlockTimesResponseFromJSONTyped(json);
  }
  function NetworkBlockTimesResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'mainnet': TargetBlockTimeFromJSON(json['mainnet']),
      'testnet': TargetBlockTimeFromJSON(json['testnet'])
    };
  }
  function NetworkBlockTimesResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'mainnet': TargetBlockTimeToJSON(value.mainnet),
      'testnet': TargetBlockTimeToJSON(value.testnet)
    };
  }

  /* tslint:disable */
  function NetworkIdentifierFromJSON(json) {
    return NetworkIdentifierFromJSONTyped(json);
  }
  function NetworkIdentifierFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'blockchain': json['blockchain'],
      'network': json['network'],
      'sub_network_identifier': !exists(json, 'sub_network_identifier') ? undefined : RosettaNetworkListResponseSubNetworkIdentifierFromJSON(json['sub_network_identifier'])
    };
  }
  function NetworkIdentifierToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'blockchain': value.blockchain,
      'network': value.network,
      'sub_network_identifier': RosettaNetworkListResponseSubNetworkIdentifierToJSON(value.sub_network_identifier)
    };
  }

  /* tslint:disable */
  function NftEventFromJSON(json) {
    return NftEventFromJSONTyped(json);
  }
  function NftEventFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'sender': !exists(json, 'sender') ? undefined : json['sender'],
      'recipient': !exists(json, 'recipient') ? undefined : json['recipient'],
      'asset_identifier': json['asset_identifier'],
      'asset_event_type': json['asset_event_type'],
      'value': AddressNftListResponseValueFromJSON(json['value']),
      'tx_id': json['tx_id'],
      'tx_index': json['tx_index'],
      'block_height': json['block_height'],
      'event_index': json['event_index']
    };
  }
  function NftEventToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'sender': value.sender,
      'recipient': value.recipient,
      'asset_identifier': value.asset_identifier,
      'asset_event_type': value.asset_event_type,
      'value': AddressNftListResponseValueToJSON(value.value),
      'tx_id': value.tx_id,
      'tx_index': value.tx_index,
      'block_height': value.block_height,
      'event_index': value.event_index
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function NonFungibleTokenHistoryEventListFromJSON(json) {
    return NonFungibleTokenHistoryEventListFromJSONTyped(json);
  }
  function NonFungibleTokenHistoryEventListFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'limit': json['limit'],
      'offset': json['offset'],
      'total': json['total'],
      'results': json['results']
    };
  }
  function NonFungibleTokenHistoryEventListToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'limit': value.limit,
      'offset': value.offset,
      'total': value.total,
      'results': value.results
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function NonFungibleTokenHoldingsListFromJSON(json) {
    return NonFungibleTokenHoldingsListFromJSONTyped(json);
  }
  function NonFungibleTokenHoldingsListFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'limit': json['limit'],
      'offset': json['offset'],
      'total': json['total'],
      'results': json['results']
    };
  }
  function NonFungibleTokenHoldingsListToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'limit': value.limit,
      'offset': value.offset,
      'total': value.total,
      'results': value.results
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function NonFungibleTokenMetadataFromJSON(json) {
    return NonFungibleTokenMetadataFromJSONTyped(json);
  }
  function NonFungibleTokenMetadataFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'token_uri': json['token_uri'],
      'name': json['name'],
      'description': json['description'],
      'image_uri': json['image_uri'],
      'image_canonical_uri': json['image_canonical_uri'],
      'tx_id': json['tx_id'],
      'sender_address': json['sender_address']
    };
  }
  function NonFungibleTokenMetadataToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'token_uri': value.token_uri,
      'name': value.name,
      'description': value.description,
      'image_uri': value.image_uri,
      'image_canonical_uri': value.image_canonical_uri,
      'tx_id': value.tx_id,
      'sender_address': value.sender_address
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function NonFungibleTokenMintListFromJSON(json) {
    return NonFungibleTokenMintListFromJSONTyped(json);
  }
  function NonFungibleTokenMintListFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'limit': json['limit'],
      'offset': json['offset'],
      'total': json['total'],
      'results': json['results']
    };
  }
  function NonFungibleTokenMintListToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'limit': value.limit,
      'offset': value.offset,
      'total': value.total,
      'results': value.results
    };
  }

  /* tslint:disable */
  function NonFungibleTokensMetadataListFromJSON(json) {
    return NonFungibleTokensMetadataListFromJSONTyped(json);
  }
  function NonFungibleTokensMetadataListFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'limit': json['limit'],
      'offset': json['offset'],
      'total': json['total'],
      'results': json['results'].map(NonFungibleTokenMetadataFromJSON)
    };
  }
  function NonFungibleTokensMetadataListToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'limit': value.limit,
      'offset': value.offset,
      'total': value.total,
      'results': value.results.map(NonFungibleTokenMetadataToJSON)
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function OtherTransactionIdentifierFromJSON(json) {
    return OtherTransactionIdentifierFromJSONTyped(json);
  }
  function OtherTransactionIdentifierFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'hash': json['hash']
    };
  }
  function OtherTransactionIdentifierToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'hash': value.hash
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function PostCoreNodeTransactionsErrorFromJSON(json) {
    return PostCoreNodeTransactionsErrorFromJSONTyped(json);
  }
  function PostCoreNodeTransactionsErrorFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'error': json['error'],
      'reason': json['reason'],
      'reason_data': json['reason_data'],
      'txid': json['txid']
    };
  }
  function PostCoreNodeTransactionsErrorToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'error': value.error,
      'reason': value.reason,
      'reason_data': value.reason_data,
      'txid': value.txid
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function ReadOnlyFunctionArgsFromJSON(json) {
    return ReadOnlyFunctionArgsFromJSONTyped(json);
  }
  function ReadOnlyFunctionArgsFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'sender': json['sender'],
      'arguments': json['arguments']
    };
  }
  function ReadOnlyFunctionArgsToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'sender': value.sender,
      'arguments': value.arguments
    };
  }

  /* tslint:disable */
  function ReadOnlyFunctionSuccessResponseFromJSON(json) {
    return ReadOnlyFunctionSuccessResponseFromJSONTyped(json);
  }
  function ReadOnlyFunctionSuccessResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'okay': json['okay'],
      'result': !exists(json, 'result') ? undefined : json['result'],
      'cause': !exists(json, 'cause') ? undefined : json['cause']
    };
  }
  function ReadOnlyFunctionSuccessResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'okay': value.okay,
      'result': value.result,
      'cause': value.cause
    };
  }

  /* tslint:disable */
  function RosettaAccountFromJSON(json) {
    return RosettaAccountFromJSONTyped(json);
  }
  function RosettaAccountFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'address': json['address'],
      'sub_account': !exists(json, 'sub_account') ? undefined : RosettaSubAccountFromJSON(json['sub_account']),
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaAccountToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'address': value.address,
      'sub_account': RosettaSubAccountToJSON(value.sub_account),
      'metadata': value.metadata
    };
  }

  /* tslint:disable */
  function RosettaAccountBalanceRequestFromJSON(json) {
    return RosettaAccountBalanceRequestFromJSONTyped(json);
  }
  function RosettaAccountBalanceRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'network_identifier': NetworkIdentifierFromJSON(json['network_identifier']),
      'account_identifier': RosettaAccountFromJSON(json['account_identifier']),
      'block_identifier': !exists(json, 'block_identifier') ? undefined : json['block_identifier']
    };
  }
  function RosettaAccountBalanceRequestToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'network_identifier': NetworkIdentifierToJSON(value.network_identifier),
      'account_identifier': RosettaAccountToJSON(value.account_identifier),
      'block_identifier': value.block_identifier
    };
  }

  /* tslint:disable */
  function RosettaAccountBalanceResponseFromJSON(json) {
    return RosettaAccountBalanceResponseFromJSONTyped(json);
  }
  function RosettaAccountBalanceResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'block_identifier': json['block_identifier'],
      'balances': json['balances'].map(RosettaAmountFromJSON),
      'coins': !exists(json, 'coins') ? undefined : json['coins'].map(RosettaCoinFromJSON),
      'metadata': !exists(json, 'metadata') ? undefined : RosettaAccountBalanceResponseMetadataFromJSON(json['metadata'])
    };
  }
  function RosettaAccountBalanceResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'block_identifier': value.block_identifier,
      'balances': value.balances.map(RosettaAmountToJSON),
      'coins': value.coins === undefined ? undefined : value.coins.map(RosettaCoinToJSON),
      'metadata': RosettaAccountBalanceResponseMetadataToJSON(value.metadata)
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function RosettaAccountBalanceResponseCoinIdentifierFromJSON(json) {
    return RosettaAccountBalanceResponseCoinIdentifierFromJSONTyped(json);
  }
  function RosettaAccountBalanceResponseCoinIdentifierFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'identifier': json['identifier']
    };
  }
  function RosettaAccountBalanceResponseCoinIdentifierToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'identifier': value.identifier
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function RosettaAccountBalanceResponseMetadataFromJSON(json) {
    return RosettaAccountBalanceResponseMetadataFromJSONTyped(json);
  }
  function RosettaAccountBalanceResponseMetadataFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'sequence_number': json['sequence_number']
    };
  }
  function RosettaAccountBalanceResponseMetadataToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'sequence_number': value.sequence_number
    };
  }

  /* tslint:disable */
  function RosettaAccountIdentifierFromJSON(json) {
    return RosettaAccountIdentifierFromJSONTyped(json);
  }
  function RosettaAccountIdentifierFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'address': json['address'],
      'sub_account': !exists(json, 'sub_account') ? undefined : RosettaSubAccountFromJSON(json['sub_account']),
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaAccountIdentifierToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'address': value.address,
      'sub_account': RosettaSubAccountToJSON(value.sub_account),
      'metadata': value.metadata
    };
  }

  /* tslint:disable */
  function RosettaAmountFromJSON(json) {
    return RosettaAmountFromJSONTyped(json);
  }
  function RosettaAmountFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'value': json['value'],
      'currency': RosettaCurrencyFromJSON(json['currency']),
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaAmountToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'value': value.value,
      'currency': RosettaCurrencyToJSON(value.currency),
      'metadata': value.metadata
    };
  }

  /* tslint:disable */
  function RosettaBlockFromJSON(json) {
    return RosettaBlockFromJSONTyped(json);
  }
  function RosettaBlockFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'block_identifier': json['block_identifier'],
      'parent_block_identifier': RosettaParentBlockIdentifierFromJSON(json['parent_block_identifier']),
      'timestamp': json['timestamp'],
      'transactions': json['transactions'].map(RosettaTransactionFromJSON),
      'metadata': !exists(json, 'metadata') ? undefined : RosettaBlockMetadata1FromJSON(json['metadata'])
    };
  }
  function RosettaBlockToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'block_identifier': value.block_identifier,
      'parent_block_identifier': RosettaParentBlockIdentifierToJSON(value.parent_block_identifier),
      'timestamp': value.timestamp,
      'transactions': value.transactions.map(RosettaTransactionToJSON),
      'metadata': RosettaBlockMetadata1ToJSON(value.metadata)
    };
  }

  /* tslint:disable */
  function RosettaBlockMetadataFromJSON(json) {
    return RosettaBlockMetadataFromJSONTyped(json);
  }
  function RosettaBlockMetadataFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'memo': !exists(json, 'memo') ? undefined : json['memo'],
      'size': !exists(json, 'size') ? undefined : json['size'],
      'lockTime': !exists(json, 'lockTime') ? undefined : json['lockTime']
    };
  }
  function RosettaBlockMetadataToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'memo': value.memo,
      'size': value.size,
      'lockTime': value.lockTime
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function RosettaBlockMetadata1FromJSON(json) {
    return RosettaBlockMetadata1FromJSONTyped(json);
  }
  function RosettaBlockMetadata1FromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'transactions_root': json['transactions_root'],
      'difficulty': json['difficulty']
    };
  }
  function RosettaBlockMetadata1ToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'transactions_root': value.transactions_root,
      'difficulty': value.difficulty
    };
  }

  /* tslint:disable */
  function RosettaBlockRequestFromJSON(json) {
    return RosettaBlockRequestFromJSONTyped(json);
  }
  function RosettaBlockRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'network_identifier': NetworkIdentifierFromJSON(json['network_identifier']),
      'block_identifier': json['block_identifier']
    };
  }
  function RosettaBlockRequestToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'network_identifier': NetworkIdentifierToJSON(value.network_identifier),
      'block_identifier': value.block_identifier
    };
  }

  /* tslint:disable */
  function RosettaBlockResponseFromJSON(json) {
    return RosettaBlockResponseFromJSONTyped(json);
  }
  function RosettaBlockResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'block': !exists(json, 'block') ? undefined : RosettaBlockFromJSON(json['block']),
      'other_transactions': !exists(json, 'other_transactions') ? undefined : json['other_transactions'].map(OtherTransactionIdentifierFromJSON)
    };
  }
  function RosettaBlockResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'block': RosettaBlockToJSON(value.block),
      'other_transactions': value.other_transactions === undefined ? undefined : value.other_transactions.map(OtherTransactionIdentifierToJSON)
    };
  }

  /* tslint:disable */
  function RosettaBlockTransactionRequestFromJSON(json) {
    return RosettaBlockTransactionRequestFromJSONTyped(json);
  }
  function RosettaBlockTransactionRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'network_identifier': NetworkIdentifierFromJSON(json['network_identifier']),
      'block_identifier': json['block_identifier'],
      'transaction_identifier': TransactionIdentifierFromJSON(json['transaction_identifier'])
    };
  }
  function RosettaBlockTransactionRequestToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'network_identifier': NetworkIdentifierToJSON(value.network_identifier),
      'block_identifier': value.block_identifier,
      'transaction_identifier': TransactionIdentifierToJSON(value.transaction_identifier)
    };
  }

  /* tslint:disable */
  function RosettaBlockTransactionResponseFromJSON(json) {
    return RosettaBlockTransactionResponseFromJSONTyped(json);
  }
  function RosettaBlockTransactionResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'transaction': RosettaTransactionFromJSON(json['transaction'])
    };
  }
  function RosettaBlockTransactionResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'transaction': RosettaTransactionToJSON(value.transaction)
    };
  }

  /* tslint:disable */
  function RosettaCoinFromJSON(json) {
    return RosettaCoinFromJSONTyped(json);
  }
  function RosettaCoinFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'coin_identifier': RosettaAccountBalanceResponseCoinIdentifierFromJSON(json['coin_identifier']),
      'amount': RosettaAmountFromJSON(json['amount'])
    };
  }
  function RosettaCoinToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'coin_identifier': RosettaAccountBalanceResponseCoinIdentifierToJSON(value.coin_identifier),
      'amount': RosettaAmountToJSON(value.amount)
    };
  }

  /* tslint:disable */
  /**
  * @export
  * @enum {string}
  */

  exports.RosettaCoinChangeCoinActionEnum = void 0;

  (function (RosettaCoinChangeCoinActionEnum) {
    RosettaCoinChangeCoinActionEnum["created"] = "coin_created";
    RosettaCoinChangeCoinActionEnum["spent"] = "coin_spent";
  })(exports.RosettaCoinChangeCoinActionEnum || (exports.RosettaCoinChangeCoinActionEnum = {}));

  function RosettaCoinChangeFromJSON(json) {
    return RosettaCoinChangeFromJSONTyped(json);
  }
  function RosettaCoinChangeFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'coin_identifier': RosettaAccountBalanceResponseCoinIdentifierFromJSON(json['coin_identifier']),
      'coin_action': json['coin_action']
    };
  }
  function RosettaCoinChangeToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'coin_identifier': RosettaAccountBalanceResponseCoinIdentifierToJSON(value.coin_identifier),
      'coin_action': value.coin_action
    };
  }

  /* tslint:disable */
  function RosettaConstructionCombineRequestFromJSON(json) {
    return RosettaConstructionCombineRequestFromJSONTyped(json);
  }
  function RosettaConstructionCombineRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'network_identifier': NetworkIdentifierFromJSON(json['network_identifier']),
      'unsigned_transaction': json['unsigned_transaction'],
      'signatures': json['signatures'].map(RosettaSignatureFromJSON)
    };
  }
  function RosettaConstructionCombineRequestToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'network_identifier': NetworkIdentifierToJSON(value.network_identifier),
      'unsigned_transaction': value.unsigned_transaction,
      'signatures': value.signatures.map(RosettaSignatureToJSON)
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function RosettaConstructionCombineResponseFromJSON(json) {
    return RosettaConstructionCombineResponseFromJSONTyped(json);
  }
  function RosettaConstructionCombineResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'signed_transaction': json['signed_transaction']
    };
  }
  function RosettaConstructionCombineResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'signed_transaction': value.signed_transaction
    };
  }

  /* tslint:disable */
  function RosettaConstructionDeriveRequestFromJSON(json) {
    return RosettaConstructionDeriveRequestFromJSONTyped(json);
  }
  function RosettaConstructionDeriveRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'network_identifier': NetworkIdentifierFromJSON(json['network_identifier']),
      'public_key': RosettaPublicKeyFromJSON(json['public_key']),
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaConstructionDeriveRequestToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'network_identifier': NetworkIdentifierToJSON(value.network_identifier),
      'public_key': RosettaPublicKeyToJSON(value.public_key),
      'metadata': value.metadata
    };
  }

  /* tslint:disable */
  function RosettaConstructionDeriveResponseFromJSON(json) {
    return RosettaConstructionDeriveResponseFromJSONTyped(json);
  }
  function RosettaConstructionDeriveResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'address': !exists(json, 'address') ? undefined : json['address'],
      'account_identifier': !exists(json, 'account_identifier') ? undefined : RosettaAccountIdentifierFromJSON(json['account_identifier']),
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaConstructionDeriveResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'address': value.address,
      'account_identifier': RosettaAccountIdentifierToJSON(value.account_identifier),
      'metadata': value.metadata
    };
  }

  /* tslint:disable */
  function RosettaConstructionHashRequestFromJSON(json) {
    return RosettaConstructionHashRequestFromJSONTyped(json);
  }
  function RosettaConstructionHashRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'network_identifier': NetworkIdentifierFromJSON(json['network_identifier']),
      'signed_transaction': json['signed_transaction']
    };
  }
  function RosettaConstructionHashRequestToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'network_identifier': NetworkIdentifierToJSON(value.network_identifier),
      'signed_transaction': value.signed_transaction
    };
  }

  /* tslint:disable */
  function RosettaConstructionHashResponseFromJSON(json) {
    return RosettaConstructionHashResponseFromJSONTyped(json);
  }
  function RosettaConstructionHashResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'transaction_identifier': TransactionIdentifierFromJSON(json['transaction_identifier']),
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaConstructionHashResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'transaction_identifier': TransactionIdentifierToJSON(value.transaction_identifier),
      'metadata': value.metadata
    };
  }

  /* tslint:disable */
  function RosettaConstructionMetadataRequestFromJSON(json) {
    return RosettaConstructionMetadataRequestFromJSONTyped(json);
  }
  function RosettaConstructionMetadataRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'network_identifier': NetworkIdentifierFromJSON(json['network_identifier']),
      'options': RosettaOptionsFromJSON(json['options']),
      'public_keys': !exists(json, 'public_keys') ? undefined : json['public_keys'].map(RosettaPublicKeyFromJSON)
    };
  }
  function RosettaConstructionMetadataRequestToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'network_identifier': NetworkIdentifierToJSON(value.network_identifier),
      'options': RosettaOptionsToJSON(value.options),
      'public_keys': value.public_keys === undefined ? undefined : value.public_keys.map(RosettaPublicKeyToJSON)
    };
  }

  /* tslint:disable */
  function RosettaConstructionMetadataResponseFromJSON(json) {
    return RosettaConstructionMetadataResponseFromJSONTyped(json);
  }
  function RosettaConstructionMetadataResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'metadata': RosettaConstructionMetadataResponseMetadataFromJSON(json['metadata']),
      'suggested_fee': !exists(json, 'suggested_fee') ? undefined : json['suggested_fee'].map(RosettaAmountFromJSON)
    };
  }
  function RosettaConstructionMetadataResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'metadata': RosettaConstructionMetadataResponseMetadataToJSON(value.metadata),
      'suggested_fee': value.suggested_fee === undefined ? undefined : value.suggested_fee.map(RosettaAmountToJSON)
    };
  }

  /* tslint:disable */
  function RosettaConstructionMetadataResponseMetadataFromJSON(json) {
    return RosettaConstructionMetadataResponseMetadataFromJSONTyped(json);
  }
  function RosettaConstructionMetadataResponseMetadataFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'account_sequence': !exists(json, 'account_sequence') ? undefined : json['account_sequence'],
      'recent_block_hash': !exists(json, 'recent_block_hash') ? undefined : json['recent_block_hash']
    };
  }
  function RosettaConstructionMetadataResponseMetadataToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'account_sequence': value.account_sequence,
      'recent_block_hash': value.recent_block_hash
    };
  }

  /* tslint:disable */
  function RosettaConstructionParseRequestFromJSON(json) {
    return RosettaConstructionParseRequestFromJSONTyped(json);
  }
  function RosettaConstructionParseRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'network_identifier': NetworkIdentifierFromJSON(json['network_identifier']),
      'signed': json['signed'],
      'transaction': json['transaction']
    };
  }
  function RosettaConstructionParseRequestToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'network_identifier': NetworkIdentifierToJSON(value.network_identifier),
      'signed': value.signed,
      'transaction': value.transaction
    };
  }

  /* tslint:disable */
  function RosettaConstructionParseResponseFromJSON(json) {
    return RosettaConstructionParseResponseFromJSONTyped(json);
  }
  function RosettaConstructionParseResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'operations': json['operations'].map(RosettaOperationFromJSON),
      'signers': !exists(json, 'signers') ? undefined : json['signers'],
      'account_identifier_signers': !exists(json, 'account_identifier_signers') ? undefined : json['account_identifier_signers'].map(RosettaAccountIdentifierFromJSON),
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaConstructionParseResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'operations': value.operations.map(RosettaOperationToJSON),
      'signers': value.signers,
      'account_identifier_signers': value.account_identifier_signers === undefined ? undefined : value.account_identifier_signers.map(RosettaAccountIdentifierToJSON),
      'metadata': value.metadata
    };
  }

  /* tslint:disable */
  function RosettaConstructionPayloadResponseFromJSON(json) {
    return RosettaConstructionPayloadResponseFromJSONTyped(json);
  }
  function RosettaConstructionPayloadResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'unsigned_transaction': json['unsigned_transaction'],
      'payloads': json['payloads'].map(SigningPayloadFromJSON)
    };
  }
  function RosettaConstructionPayloadResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'unsigned_transaction': value.unsigned_transaction,
      'payloads': value.payloads.map(SigningPayloadToJSON)
    };
  }

  /* tslint:disable */
  function RosettaConstructionPayloadsRequestFromJSON(json) {
    return RosettaConstructionPayloadsRequestFromJSONTyped(json);
  }
  function RosettaConstructionPayloadsRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'network_identifier': NetworkIdentifierFromJSON(json['network_identifier']),
      'operations': json['operations'].map(RosettaOperationFromJSON),
      'public_keys': !exists(json, 'public_keys') ? undefined : json['public_keys'].map(RosettaPublicKeyFromJSON),
      'metadata': !exists(json, 'metadata') ? undefined : RosettaConstructionMetadataResponseMetadataFromJSON(json['metadata'])
    };
  }
  function RosettaConstructionPayloadsRequestToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'network_identifier': NetworkIdentifierToJSON(value.network_identifier),
      'operations': value.operations.map(RosettaOperationToJSON),
      'public_keys': value.public_keys === undefined ? undefined : value.public_keys.map(RosettaPublicKeyToJSON),
      'metadata': RosettaConstructionMetadataResponseMetadataToJSON(value.metadata)
    };
  }

  /* tslint:disable */
  function RosettaConstructionPreprocessRequestFromJSON(json) {
    return RosettaConstructionPreprocessRequestFromJSONTyped(json);
  }
  function RosettaConstructionPreprocessRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'network_identifier': NetworkIdentifierFromJSON(json['network_identifier']),
      'operations': json['operations'].map(RosettaOperationFromJSON),
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata'],
      'max_fee': !exists(json, 'max_fee') ? undefined : json['max_fee'].map(RosettaMaxFeeAmountFromJSON),
      'suggested_fee_multiplier': !exists(json, 'suggested_fee_multiplier') ? undefined : json['suggested_fee_multiplier']
    };
  }
  function RosettaConstructionPreprocessRequestToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'network_identifier': NetworkIdentifierToJSON(value.network_identifier),
      'operations': value.operations.map(RosettaOperationToJSON),
      'metadata': value.metadata,
      'max_fee': value.max_fee === undefined ? undefined : value.max_fee.map(RosettaMaxFeeAmountToJSON),
      'suggested_fee_multiplier': value.suggested_fee_multiplier
    };
  }

  /* tslint:disable */
  function RosettaConstructionPreprocessResponseFromJSON(json) {
    return RosettaConstructionPreprocessResponseFromJSONTyped(json);
  }
  function RosettaConstructionPreprocessResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'options': !exists(json, 'options') ? undefined : RosettaOptionsFromJSON(json['options']),
      'required_public_keys': !exists(json, 'required_public_keys') ? undefined : json['required_public_keys'].map(RosettaAccountFromJSON)
    };
  }
  function RosettaConstructionPreprocessResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'options': RosettaOptionsToJSON(value.options),
      'required_public_keys': value.required_public_keys === undefined ? undefined : value.required_public_keys.map(RosettaAccountToJSON)
    };
  }

  /* tslint:disable */
  function RosettaConstructionSubmitRequestFromJSON(json) {
    return RosettaConstructionSubmitRequestFromJSONTyped(json);
  }
  function RosettaConstructionSubmitRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'network_identifier': NetworkIdentifierFromJSON(json['network_identifier']),
      'signed_transaction': json['signed_transaction']
    };
  }
  function RosettaConstructionSubmitRequestToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'network_identifier': NetworkIdentifierToJSON(value.network_identifier),
      'signed_transaction': value.signed_transaction
    };
  }

  /* tslint:disable */
  function RosettaConstructionSubmitResponseFromJSON(json) {
    return RosettaConstructionSubmitResponseFromJSONTyped(json);
  }
  function RosettaConstructionSubmitResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'transaction_identifier': TransactionIdentifierFromJSON(json['transaction_identifier']),
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaConstructionSubmitResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'transaction_identifier': TransactionIdentifierToJSON(value.transaction_identifier),
      'metadata': value.metadata
    };
  }

  /* tslint:disable */
  function RosettaCurrencyFromJSON(json) {
    return RosettaCurrencyFromJSONTyped(json);
  }
  function RosettaCurrencyFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'symbol': json['symbol'],
      'decimals': json['decimals'],
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaCurrencyToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'symbol': value.symbol,
      'decimals': value.decimals,
      'metadata': value.metadata
    };
  }

  /* tslint:disable */
  function RosettaErrorFromJSON(json) {
    return RosettaErrorFromJSONTyped(json);
  }
  function RosettaErrorFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'code': json['code'],
      'message': json['message'],
      'retriable': json['retriable'],
      'details': !exists(json, 'details') ? undefined : RosettaErrorDetailsFromJSON(json['details'])
    };
  }
  function RosettaErrorToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'code': value.code,
      'message': value.message,
      'retriable': value.retriable,
      'details': RosettaErrorDetailsToJSON(value.details)
    };
  }

  /* tslint:disable */
  function RosettaErrorDetailsFromJSON(json) {
    return RosettaErrorDetailsFromJSONTyped(json);
  }
  function RosettaErrorDetailsFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'address': !exists(json, 'address') ? undefined : json['address'],
      'error': !exists(json, 'error') ? undefined : json['error']
    };
  }
  function RosettaErrorDetailsToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'address': value.address,
      'error': value.error
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function RosettaErrorNoDetailsFromJSON(json) {
    return RosettaErrorNoDetailsFromJSONTyped(json);
  }
  function RosettaErrorNoDetailsFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'code': json['code'],
      'message': json['message'],
      'retriable': json['retriable']
    };
  }
  function RosettaErrorNoDetailsToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'code': value.code,
      'message': value.message,
      'retriable': value.retriable
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function RosettaGenesisBlockIdentifierFromJSON(json) {
    return RosettaGenesisBlockIdentifierFromJSONTyped(json);
  }
  function RosettaGenesisBlockIdentifierFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'index': json['index'],
      'hash': json['hash']
    };
  }
  function RosettaGenesisBlockIdentifierToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'index': value.index,
      'hash': value.hash
    };
  }

  /* tslint:disable */
  function RosettaMaxFeeAmountFromJSON(json) {
    return RosettaMaxFeeAmountFromJSONTyped(json);
  }
  function RosettaMaxFeeAmountFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'value': json['value'],
      'currency': RosettaCurrencyFromJSON(json['currency']),
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaMaxFeeAmountToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'value': value.value,
      'currency': RosettaCurrencyToJSON(value.currency),
      'metadata': value.metadata
    };
  }

  /* tslint:disable */
  function RosettaMempoolRequestFromJSON(json) {
    return RosettaMempoolRequestFromJSONTyped(json);
  }
  function RosettaMempoolRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'network_identifier': NetworkIdentifierFromJSON(json['network_identifier']),
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaMempoolRequestToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'network_identifier': NetworkIdentifierToJSON(value.network_identifier),
      'metadata': value.metadata
    };
  }

  /* tslint:disable */
  function RosettaMempoolResponseFromJSON(json) {
    return RosettaMempoolResponseFromJSONTyped(json);
  }
  function RosettaMempoolResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'transaction_identifiers': json['transaction_identifiers'].map(TransactionIdentifierFromJSON),
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaMempoolResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'transaction_identifiers': value.transaction_identifiers.map(TransactionIdentifierToJSON),
      'metadata': value.metadata
    };
  }

  /* tslint:disable */
  function RosettaMempoolTransactionRequestFromJSON(json) {
    return RosettaMempoolTransactionRequestFromJSONTyped(json);
  }
  function RosettaMempoolTransactionRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'network_identifier': NetworkIdentifierFromJSON(json['network_identifier']),
      'transaction_identifier': TransactionIdentifierFromJSON(json['transaction_identifier'])
    };
  }
  function RosettaMempoolTransactionRequestToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'network_identifier': NetworkIdentifierToJSON(value.network_identifier),
      'transaction_identifier': TransactionIdentifierToJSON(value.transaction_identifier)
    };
  }

  /* tslint:disable */
  function RosettaMempoolTransactionResponseFromJSON(json) {
    return RosettaMempoolTransactionResponseFromJSONTyped(json);
  }
  function RosettaMempoolTransactionResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'transaction': RosettaTransactionFromJSON(json['transaction']),
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaMempoolTransactionResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'transaction': RosettaTransactionToJSON(value.transaction),
      'metadata': value.metadata
    };
  }

  /* tslint:disable */
  function RosettaNetworkListResponseFromJSON(json) {
    return RosettaNetworkListResponseFromJSONTyped(json);
  }
  function RosettaNetworkListResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'network_identifiers': json['network_identifiers'].map(NetworkIdentifierFromJSON)
    };
  }
  function RosettaNetworkListResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'network_identifiers': value.network_identifiers.map(NetworkIdentifierToJSON)
    };
  }

  /* tslint:disable */
  function RosettaNetworkListResponseSubNetworkIdentifierFromJSON(json) {
    return RosettaNetworkListResponseSubNetworkIdentifierFromJSONTyped(json);
  }
  function RosettaNetworkListResponseSubNetworkIdentifierFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'network': json['network'],
      'metadata': !exists(json, 'metadata') ? undefined : RosettaNetworkListResponseSubNetworkIdentifierMetadataFromJSON(json['metadata'])
    };
  }
  function RosettaNetworkListResponseSubNetworkIdentifierToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'network': value.network,
      'metadata': RosettaNetworkListResponseSubNetworkIdentifierMetadataToJSON(value.metadata)
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function RosettaNetworkListResponseSubNetworkIdentifierMetadataFromJSON(json) {
    return RosettaNetworkListResponseSubNetworkIdentifierMetadataFromJSONTyped(json);
  }
  function RosettaNetworkListResponseSubNetworkIdentifierMetadataFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'producer': json['producer']
    };
  }
  function RosettaNetworkListResponseSubNetworkIdentifierMetadataToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'producer': value.producer
    };
  }

  /* tslint:disable */
  function RosettaNetworkOptionsResponseFromJSON(json) {
    return RosettaNetworkOptionsResponseFromJSONTyped(json);
  }
  function RosettaNetworkOptionsResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'version': RosettaNetworkOptionsResponseVersionFromJSON(json['version']),
      'allow': RosettaNetworkOptionsResponseAllowFromJSON(json['allow'])
    };
  }
  function RosettaNetworkOptionsResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'version': RosettaNetworkOptionsResponseVersionToJSON(value.version),
      'allow': RosettaNetworkOptionsResponseAllowToJSON(value.allow)
    };
  }

  /* tslint:disable */
  function RosettaNetworkOptionsResponseAllowFromJSON(json) {
    return RosettaNetworkOptionsResponseAllowFromJSONTyped(json);
  }
  function RosettaNetworkOptionsResponseAllowFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'operation_statuses': json['operation_statuses'].map(RosettaOperationStatusFromJSON),
      'operation_types': json['operation_types'],
      'errors': json['errors'].map(RosettaErrorNoDetailsFromJSON),
      'historical_balance_lookup': json['historical_balance_lookup']
    };
  }
  function RosettaNetworkOptionsResponseAllowToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'operation_statuses': value.operation_statuses.map(RosettaOperationStatusToJSON),
      'operation_types': value.operation_types,
      'errors': value.errors.map(RosettaErrorNoDetailsToJSON),
      'historical_balance_lookup': value.historical_balance_lookup
    };
  }

  /* tslint:disable */
  function RosettaNetworkOptionsResponseVersionFromJSON(json) {
    return RosettaNetworkOptionsResponseVersionFromJSONTyped(json);
  }
  function RosettaNetworkOptionsResponseVersionFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'rosetta_version': json['rosetta_version'],
      'node_version': json['node_version'],
      'middleware_version': !exists(json, 'middleware_version') ? undefined : json['middleware_version'],
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaNetworkOptionsResponseVersionToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'rosetta_version': value.rosetta_version,
      'node_version': value.node_version,
      'middleware_version': value.middleware_version,
      'metadata': value.metadata
    };
  }

  /* tslint:disable */
  function RosettaNetworkStatusResponseFromJSON(json) {
    return RosettaNetworkStatusResponseFromJSONTyped(json);
  }
  function RosettaNetworkStatusResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'current_block_identifier': json['current_block_identifier'],
      'current_block_timestamp': json['current_block_timestamp'],
      'genesis_block_identifier': RosettaGenesisBlockIdentifierFromJSON(json['genesis_block_identifier']),
      'oldest_block_identifier': !exists(json, 'oldest_block_identifier') ? undefined : RosettaOldestBlockIdentifierFromJSON(json['oldest_block_identifier']),
      'sync_status': !exists(json, 'sync_status') ? undefined : RosettaSyncStatusFromJSON(json['sync_status']),
      'peers': json['peers'].map(RosettaPeersFromJSON)
    };
  }
  function RosettaNetworkStatusResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'current_block_identifier': value.current_block_identifier,
      'current_block_timestamp': value.current_block_timestamp,
      'genesis_block_identifier': RosettaGenesisBlockIdentifierToJSON(value.genesis_block_identifier),
      'oldest_block_identifier': RosettaOldestBlockIdentifierToJSON(value.oldest_block_identifier),
      'sync_status': RosettaSyncStatusToJSON(value.sync_status),
      'peers': value.peers.map(RosettaPeersToJSON)
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function RosettaOldestBlockIdentifierFromJSON(json) {
    return RosettaOldestBlockIdentifierFromJSONTyped(json);
  }
  function RosettaOldestBlockIdentifierFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'index': json['index'],
      'hash': json['hash']
    };
  }
  function RosettaOldestBlockIdentifierToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'index': value.index,
      'hash': value.hash
    };
  }

  /* tslint:disable */
  function RosettaOperationFromJSON(json) {
    return RosettaOperationFromJSONTyped(json);
  }
  function RosettaOperationFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'operation_identifier': RosettaOperationIdentifierFromJSON(json['operation_identifier']),
      'related_operations': !exists(json, 'related_operations') ? undefined : json['related_operations'].map(RosettaRelatedOperationFromJSON),
      'type': json['type'],
      'status': !exists(json, 'status') ? undefined : json['status'],
      'account': !exists(json, 'account') ? undefined : RosettaAccountFromJSON(json['account']),
      'amount': !exists(json, 'amount') ? undefined : RosettaAmountFromJSON(json['amount']),
      'coin_change': !exists(json, 'coin_change') ? undefined : RosettaCoinChangeFromJSON(json['coin_change']),
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaOperationToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'operation_identifier': RosettaOperationIdentifierToJSON(value.operation_identifier),
      'related_operations': value.related_operations === undefined ? undefined : value.related_operations.map(RosettaRelatedOperationToJSON),
      'type': value.type,
      'status': value.status,
      'account': RosettaAccountToJSON(value.account),
      'amount': RosettaAmountToJSON(value.amount),
      'coin_change': RosettaCoinChangeToJSON(value.coin_change),
      'metadata': value.metadata
    };
  }

  /* tslint:disable */
  function RosettaOperationIdentifierFromJSON(json) {
    return RosettaOperationIdentifierFromJSONTyped(json);
  }
  function RosettaOperationIdentifierFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'index': json['index'],
      'network_index': !exists(json, 'network_index') ? undefined : json['network_index']
    };
  }
  function RosettaOperationIdentifierToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'index': value.index,
      'network_index': value.network_index
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function RosettaOperationStatusFromJSON(json) {
    return RosettaOperationStatusFromJSONTyped(json);
  }
  function RosettaOperationStatusFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'status': json['status'],
      'successful': json['successful']
    };
  }
  function RosettaOperationStatusToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'status': value.status,
      'successful': value.successful
    };
  }

  /* tslint:disable */
  function RosettaOptionsFromJSON(json) {
    return RosettaOptionsFromJSONTyped(json);
  }
  function RosettaOptionsFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'sender_address': !exists(json, 'sender_address') ? undefined : json['sender_address'],
      'type': !exists(json, 'type') ? undefined : json['type'],
      'status': !exists(json, 'status') ? undefined : json['status'],
      'token_transfer_recipient_address': !exists(json, 'token_transfer_recipient_address') ? undefined : json['token_transfer_recipient_address'],
      'amount': !exists(json, 'amount') ? undefined : json['amount'],
      'symbol': !exists(json, 'symbol') ? undefined : json['symbol'],
      'decimals': !exists(json, 'decimals') ? undefined : json['decimals'],
      'gas_limit': !exists(json, 'gas_limit') ? undefined : json['gas_limit'],
      'gas_price': !exists(json, 'gas_price') ? undefined : json['gas_price'],
      'suggested_fee_multiplier': !exists(json, 'suggested_fee_multiplier') ? undefined : json['suggested_fee_multiplier'],
      'max_fee': !exists(json, 'max_fee') ? undefined : json['max_fee'],
      'fee': !exists(json, 'fee') ? undefined : json['fee'],
      'size': !exists(json, 'size') ? undefined : json['size'],
      'memo': !exists(json, 'memo') ? undefined : json['memo'],
      'number_of_cycles': !exists(json, 'number_of_cycles') ? undefined : json['number_of_cycles'],
      'contract_address': !exists(json, 'contract_address') ? undefined : json['contract_address'],
      'contract_name': !exists(json, 'contract_name') ? undefined : json['contract_name'],
      'burn_block_height': !exists(json, 'burn_block_height') ? undefined : json['burn_block_height'],
      'delegate_to': !exists(json, 'delegate_to') ? undefined : json['delegate_to'],
      'pox_addr': !exists(json, 'pox_addr') ? undefined : json['pox_addr']
    };
  }
  function RosettaOptionsToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'sender_address': value.sender_address,
      'type': value.type,
      'status': value.status,
      'token_transfer_recipient_address': value.token_transfer_recipient_address,
      'amount': value.amount,
      'symbol': value.symbol,
      'decimals': value.decimals,
      'gas_limit': value.gas_limit,
      'gas_price': value.gas_price,
      'suggested_fee_multiplier': value.suggested_fee_multiplier,
      'max_fee': value.max_fee,
      'fee': value.fee,
      'size': value.size,
      'memo': value.memo,
      'number_of_cycles': value.number_of_cycles,
      'contract_address': value.contract_address,
      'contract_name': value.contract_name,
      'burn_block_height': value.burn_block_height,
      'delegate_to': value.delegate_to,
      'pox_addr': value.pox_addr
    };
  }

  /* tslint:disable */
  function RosettaOptionsRequestFromJSON(json) {
    return RosettaOptionsRequestFromJSONTyped(json);
  }
  function RosettaOptionsRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'network_identifier': NetworkIdentifierFromJSON(json['network_identifier']),
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaOptionsRequestToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'network_identifier': NetworkIdentifierToJSON(value.network_identifier),
      'metadata': value.metadata
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function RosettaParentBlockIdentifierFromJSON(json) {
    return RosettaParentBlockIdentifierFromJSONTyped(json);
  }
  function RosettaParentBlockIdentifierFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'index': json['index'],
      'hash': json['hash']
    };
  }
  function RosettaParentBlockIdentifierToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'index': value.index,
      'hash': value.hash
    };
  }

  /* tslint:disable */
  function RosettaPeersFromJSON(json) {
    return RosettaPeersFromJSONTyped(json);
  }
  function RosettaPeersFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'peer_id': json['peer_id'],
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaPeersToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'peer_id': value.peer_id,
      'metadata': value.metadata
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */

  /**
  * @export
  * @enum {string}
  */
  exports.RosettaPublicKeyCurveTypeEnum = void 0;

  (function (RosettaPublicKeyCurveTypeEnum) {
    RosettaPublicKeyCurveTypeEnum["secp256k1"] = "secp256k1";
    RosettaPublicKeyCurveTypeEnum["edwards25519"] = "edwards25519";
  })(exports.RosettaPublicKeyCurveTypeEnum || (exports.RosettaPublicKeyCurveTypeEnum = {}));

  function RosettaPublicKeyFromJSON(json) {
    return RosettaPublicKeyFromJSONTyped(json);
  }
  function RosettaPublicKeyFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'hex_bytes': json['hex_bytes'],
      'curve_type': json['curve_type']
    };
  }
  function RosettaPublicKeyToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'hex_bytes': value.hex_bytes,
      'curve_type': value.curve_type
    };
  }

  /* tslint:disable */
  function RosettaRelatedOperationFromJSON(json) {
    return RosettaRelatedOperationFromJSONTyped(json);
  }
  function RosettaRelatedOperationFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'index': json['index'],
      'network_index': !exists(json, 'network_index') ? undefined : json['network_index']
    };
  }
  function RosettaRelatedOperationToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'index': value.index,
      'network_index': value.network_index
    };
  }

  /* tslint:disable */
  /**
  * @export
  * @enum {string}
  */

  exports.RosettaSignatureSignatureTypeEnum = void 0;

  (function (RosettaSignatureSignatureTypeEnum) {
    RosettaSignatureSignatureTypeEnum["ecdsa"] = "ecdsa";
    RosettaSignatureSignatureTypeEnum["ecdsa_recovery"] = "ecdsa_recovery";
    RosettaSignatureSignatureTypeEnum["ed25519"] = "ed25519";
    RosettaSignatureSignatureTypeEnum["schnorr_1"] = "schnorr_1";
    RosettaSignatureSignatureTypeEnum["schnorr_poseidon"] = "schnorr_poseidon";
  })(exports.RosettaSignatureSignatureTypeEnum || (exports.RosettaSignatureSignatureTypeEnum = {}));

  function RosettaSignatureFromJSON(json) {
    return RosettaSignatureFromJSONTyped(json);
  }
  function RosettaSignatureFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'signing_payload': SigningPayloadFromJSON(json['signing_payload']),
      'public_key': RosettaPublicKeyFromJSON(json['public_key']),
      'signature_type': json['signature_type'],
      'hex_bytes': json['hex_bytes']
    };
  }
  function RosettaSignatureToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'signing_payload': SigningPayloadToJSON(value.signing_payload),
      'public_key': RosettaPublicKeyToJSON(value.public_key),
      'signature_type': value.signature_type,
      'hex_bytes': value.hex_bytes
    };
  }

  /* tslint:disable */
  function RosettaStatusRequestFromJSON(json) {
    return RosettaStatusRequestFromJSONTyped(json);
  }
  function RosettaStatusRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'network_identifier': NetworkIdentifierFromJSON(json['network_identifier']),
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaStatusRequestToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'network_identifier': NetworkIdentifierToJSON(value.network_identifier),
      'metadata': value.metadata
    };
  }

  /* tslint:disable */
  function RosettaSubAccountFromJSON(json) {
    return RosettaSubAccountFromJSONTyped(json);
  }
  function RosettaSubAccountFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'address': json['address'],
      'metadata': !exists(json, 'metadata') ? undefined : json['metadata']
    };
  }
  function RosettaSubAccountToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'address': value.address,
      'metadata': value.metadata
    };
  }

  /* tslint:disable */
  function RosettaSyncStatusFromJSON(json) {
    return RosettaSyncStatusFromJSONTyped(json);
  }
  function RosettaSyncStatusFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'current_index': json['current_index'],
      'target_index': !exists(json, 'target_index') ? undefined : json['target_index'],
      'stage': !exists(json, 'stage') ? undefined : json['stage'],
      'synced': !exists(json, 'synced') ? undefined : json['synced']
    };
  }
  function RosettaSyncStatusToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'current_index': value.current_index,
      'target_index': value.target_index,
      'stage': value.stage,
      'synced': value.synced
    };
  }

  /* tslint:disable */
  function RosettaTransactionFromJSON(json) {
    return RosettaTransactionFromJSONTyped(json);
  }
  function RosettaTransactionFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'transaction_identifier': TransactionIdentifierFromJSON(json['transaction_identifier']),
      'operations': json['operations'].map(RosettaOperationFromJSON),
      'metadata': !exists(json, 'metadata') ? undefined : RosettaBlockMetadataFromJSON(json['metadata'])
    };
  }
  function RosettaTransactionToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'transaction_identifier': TransactionIdentifierToJSON(value.transaction_identifier),
      'operations': value.operations.map(RosettaOperationToJSON),
      'metadata': RosettaBlockMetadataToJSON(value.metadata)
    };
  }

  /* tslint:disable */
  function RunFaucetResponseFromJSON(json) {
    return RunFaucetResponseFromJSONTyped(json);
  }
  function RunFaucetResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'success': json['success'],
      'txId': !exists(json, 'txId') ? undefined : json['txId'],
      'txRaw': !exists(json, 'txRaw') ? undefined : json['txRaw']
    };
  }
  function RunFaucetResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'success': value.success,
      'txId': value.txId,
      'txRaw': value.txRaw
    };
  }

  /* tslint:disable */
  function ServerStatusResponseFromJSON(json) {
    return ServerStatusResponseFromJSONTyped(json);
  }
  function ServerStatusResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'server_version': !exists(json, 'server_version') ? undefined : json['server_version'],
      'status': json['status'],
      'pox_v1_unlock_height': !exists(json, 'pox_v1_unlock_height') ? undefined : json['pox_v1_unlock_height'],
      'chain_tip': !exists(json, 'chain_tip') ? undefined : ChainTipFromJSON(json['chain_tip'])
    };
  }
  function ServerStatusResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'server_version': value.server_version,
      'status': value.status,
      'pox_v1_unlock_height': value.pox_v1_unlock_height,
      'chain_tip': ChainTipToJSON(value.chain_tip)
    };
  }

  /* tslint:disable */
  /**
  * @export
  * @enum {string}
  */

  exports.SigningPayloadSignatureTypeEnum = void 0;

  (function (SigningPayloadSignatureTypeEnum) {
    SigningPayloadSignatureTypeEnum["ecdsa"] = "ecdsa";
    SigningPayloadSignatureTypeEnum["ecdsa_recovery"] = "ecdsa_recovery";
    SigningPayloadSignatureTypeEnum["ed25519"] = "ed25519";
    SigningPayloadSignatureTypeEnum["schnorr_1"] = "schnorr_1";
    SigningPayloadSignatureTypeEnum["schnorr_poseidon"] = "schnorr_poseidon";
  })(exports.SigningPayloadSignatureTypeEnum || (exports.SigningPayloadSignatureTypeEnum = {}));

  function SigningPayloadFromJSON(json) {
    return SigningPayloadFromJSONTyped(json);
  }
  function SigningPayloadFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'address': !exists(json, 'address') ? undefined : json['address'],
      'account_identifier': !exists(json, 'account_identifier') ? undefined : RosettaAccountFromJSON(json['account_identifier']),
      'hex_bytes': json['hex_bytes'],
      'signature_type': !exists(json, 'signature_type') ? undefined : json['signature_type']
    };
  }
  function SigningPayloadToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'address': value.address,
      'account_identifier': RosettaAccountToJSON(value.account_identifier),
      'hex_bytes': value.hex_bytes,
      'signature_type': value.signature_type
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function SmartContractFromJSON(json) {
    return SmartContractFromJSONTyped(json);
  }
  function SmartContractFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'tx_id': json['tx_id'],
      'canonical': json['canonical'],
      'contract_id': json['contract_id'],
      'block_height': json['block_height'],
      'source_code': json['source_code'],
      'abi': json['abi']
    };
  }
  function SmartContractToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'tx_id': value.tx_id,
      'canonical': value.canonical,
      'contract_id': value.contract_id,
      'block_height': value.block_height,
      'source_code': value.source_code,
      'abi': value.abi
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function StxBalanceFromJSON(json) {
    return StxBalanceFromJSONTyped(json);
  }
  function StxBalanceFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'balance': json['balance'],
      'total_sent': json['total_sent'],
      'total_received': json['total_received'],
      'total_fees_sent': json['total_fees_sent'],
      'total_miner_rewards_received': json['total_miner_rewards_received'],
      'lock_tx_id': json['lock_tx_id'],
      'locked': json['locked'],
      'lock_height': json['lock_height'],
      'burnchain_lock_height': json['burnchain_lock_height'],
      'burnchain_unlock_height': json['burnchain_unlock_height']
    };
  }
  function StxBalanceToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'balance': value.balance,
      'total_sent': value.total_sent,
      'total_received': value.total_received,
      'total_fees_sent': value.total_fees_sent,
      'total_miner_rewards_received': value.total_miner_rewards_received,
      'lock_tx_id': value.lock_tx_id,
      'locked': value.locked,
      'lock_height': value.lock_height,
      'burnchain_lock_height': value.burnchain_lock_height,
      'burnchain_unlock_height': value.burnchain_unlock_height
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function TargetBlockTimeFromJSON(json) {
    return TargetBlockTimeFromJSONTyped(json);
  }
  function TargetBlockTimeFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'target_block_time': json['target_block_time']
    };
  }
  function TargetBlockTimeToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'target_block_time': value.target_block_time
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function TransactionEventsResponseFromJSON(json) {
    return TransactionEventsResponseFromJSONTyped(json);
  }
  function TransactionEventsResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'limit': json['limit'],
      'offset': json['offset'],
      'results': json['results']
    };
  }
  function TransactionEventsResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'limit': value.limit,
      'offset': value.offset,
      'results': value.results
    };
  }

  /* tslint:disable */
  function TransactionFeeEstimateRequestFromJSON(json) {
    return TransactionFeeEstimateRequestFromJSONTyped(json);
  }
  function TransactionFeeEstimateRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'transaction_payload': json['transaction_payload'],
      'estimated_len': !exists(json, 'estimated_len') ? undefined : json['estimated_len']
    };
  }
  function TransactionFeeEstimateRequestToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'transaction_payload': value.transaction_payload,
      'estimated_len': value.estimated_len
    };
  }

  /* tslint:disable */
  function TransactionFeeEstimateResponseFromJSON(json) {
    return TransactionFeeEstimateResponseFromJSONTyped(json);
  }
  function TransactionFeeEstimateResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'estimated_cost_scalar': json['estimated_cost_scalar'],
      'cost_scalar_change_by_byte': !exists(json, 'cost_scalar_change_by_byte') ? undefined : json['cost_scalar_change_by_byte'],
      'estimated_cost': TransactionFeeEstimateResponseEstimatedCostFromJSON(json['estimated_cost']),
      'estimations': !exists(json, 'estimations') ? undefined : json['estimations'].map(TransactionFeeEstimateResponseEstimationsFromJSON)
    };
  }
  function TransactionFeeEstimateResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'estimated_cost_scalar': value.estimated_cost_scalar,
      'cost_scalar_change_by_byte': value.cost_scalar_change_by_byte,
      'estimated_cost': TransactionFeeEstimateResponseEstimatedCostToJSON(value.estimated_cost),
      'estimations': value.estimations === undefined ? undefined : value.estimations.map(TransactionFeeEstimateResponseEstimationsToJSON)
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function TransactionFeeEstimateResponseEstimatedCostFromJSON(json) {
    return TransactionFeeEstimateResponseEstimatedCostFromJSONTyped(json);
  }
  function TransactionFeeEstimateResponseEstimatedCostFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'read_count': json['read_count'],
      'read_length': json['read_length'],
      'runtime': json['runtime'],
      'write_count': json['write_count'],
      'write_length': json['write_length']
    };
  }
  function TransactionFeeEstimateResponseEstimatedCostToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'read_count': value.read_count,
      'read_length': value.read_length,
      'runtime': value.runtime,
      'write_count': value.write_count,
      'write_length': value.write_length
    };
  }

  /* tslint:disable */
  function TransactionFeeEstimateResponseEstimationsFromJSON(json) {
    return TransactionFeeEstimateResponseEstimationsFromJSONTyped(json);
  }
  function TransactionFeeEstimateResponseEstimationsFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'fee_rate': !exists(json, 'fee_rate') ? undefined : json['fee_rate'],
      'fee': !exists(json, 'fee') ? undefined : json['fee']
    };
  }
  function TransactionFeeEstimateResponseEstimationsToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'fee_rate': value.fee_rate,
      'fee': value.fee
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function TransactionIdentifierFromJSON(json) {
    return TransactionIdentifierFromJSONTyped(json);
  }
  function TransactionIdentifierFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'hash': json['hash']
    };
  }
  function TransactionIdentifierToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'hash': value.hash
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function TransactionResultsFromJSON(json) {
    return TransactionResultsFromJSONTyped(json);
  }
  function TransactionResultsFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'limit': json['limit'],
      'offset': json['offset'],
      'total': json['total'],
      'results': json['results']
    };
  }
  function TransactionResultsToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'limit': value.limit,
      'offset': value.offset,
      'total': value.total,
      'results': value.results
    };
  }

  /* tslint:disable */

  /* eslint-disable */

  /**
   * Stacks Blockchain API
   * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
   *
   * The version of the OpenAPI document: STACKS_API_VERSION
   *
   *
   * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
   * https://openapi-generator.tech
   * Do not edit the class manually.
   */
  function UnanchoredTransactionListResponseFromJSON(json) {
    return UnanchoredTransactionListResponseFromJSONTyped(json);
  }
  function UnanchoredTransactionListResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }

    return {
      'total': json['total'],
      'results': json['results']
    };
  }
  function UnanchoredTransactionListResponseToJSON(value) {
    if (value === undefined) {
      return undefined;
    }

    if (value === null) {
      return null;
    }

    return {
      'total': value.total,
      'results': value.results
    };
  }

  /**
   *
   */

  var AccountsApi = /*#__PURE__*/function (_runtime$BaseAPI) {
    _inheritsLoose(AccountsApi, _runtime$BaseAPI);

    function AccountsApi() {
      return _runtime$BaseAPI.apply(this, arguments) || this;
    }

    var _proto = AccountsApi.prototype;

    /**
     * Retrieves a list of all assets events associated with an account or a Contract Identifier. This includes Transfers, Mints.
     * Get account assets
     */
    _proto.getAccountAssetsRaw = function getAccountAssetsRaw(requestParameters, initOverrides) {
      try {
        var _this2 = this;

        if (requestParameters.principal === null || requestParameters.principal === undefined) {
          throw new RequiredError('principal', 'Required parameter requestParameters.principal was null or undefined when calling getAccountAssets.');
        }

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.unanchored !== undefined) {
          queryParameters['unanchored'] = requestParameters.unanchored;
        }

        if (requestParameters.untilBlock !== undefined) {
          queryParameters['until_block'] = requestParameters.untilBlock;
        }

        var headerParameters = {};
        return Promise.resolve(_this2.request({
          path: "/extended/v1/address/{principal}/assets".replace("{" + "principal" + "}", encodeURIComponent(String(requestParameters.principal))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return AddressAssetsListResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of all assets events associated with an account or a Contract Identifier. This includes Transfers, Mints.
     * Get account assets
     */
    ;

    _proto.getAccountAssets = function getAccountAssets(requestParameters, initOverrides) {
      try {
        var _this4 = this;

        return Promise.resolve(_this4.getAccountAssetsRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves total account balance information for a given Address or Contract Identifier. This includes the balances of  STX Tokens, Fungible Tokens and Non-Fungible Tokens for the account.
     * Get account balances
     */
    ;

    _proto.getAccountBalanceRaw = function getAccountBalanceRaw(requestParameters, initOverrides) {
      try {
        var _this6 = this;

        if (requestParameters.principal === null || requestParameters.principal === undefined) {
          throw new RequiredError('principal', 'Required parameter requestParameters.principal was null or undefined when calling getAccountBalance.');
        }

        var queryParameters = {};

        if (requestParameters.unanchored !== undefined) {
          queryParameters['unanchored'] = requestParameters.unanchored;
        }

        if (requestParameters.untilBlock !== undefined) {
          queryParameters['until_block'] = requestParameters.untilBlock;
        }

        var headerParameters = {};
        return Promise.resolve(_this6.request({
          path: "/extended/v1/address/{principal}/balances".replace("{" + "principal" + "}", encodeURIComponent(String(requestParameters.principal))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return AddressBalanceResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves total account balance information for a given Address or Contract Identifier. This includes the balances of  STX Tokens, Fungible Tokens and Non-Fungible Tokens for the account.
     * Get account balances
     */
    ;

    _proto.getAccountBalance = function getAccountBalance(requestParameters, initOverrides) {
      try {
        var _this8 = this;

        return Promise.resolve(_this8.getAccountBalanceRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of STX transfers with memos to the given principal. This includes regular transfers from a stx-transfer transaction type, and transfers from contract-call transactions a the `send-many-memo` bulk sending contract.
     * Get inbound STX transfers
     */
    ;

    _proto.getAccountInboundRaw = function getAccountInboundRaw(requestParameters, initOverrides) {
      try {
        var _this10 = this;

        if (requestParameters.principal === null || requestParameters.principal === undefined) {
          throw new RequiredError('principal', 'Required parameter requestParameters.principal was null or undefined when calling getAccountInbound.');
        }

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.height !== undefined) {
          queryParameters['height'] = requestParameters.height;
        }

        if (requestParameters.unanchored !== undefined) {
          queryParameters['unanchored'] = requestParameters.unanchored;
        }

        if (requestParameters.untilBlock !== undefined) {
          queryParameters['until_block'] = requestParameters.untilBlock;
        }

        var headerParameters = {};
        return Promise.resolve(_this10.request({
          path: "/extended/v1/address/{principal}/stx_inbound".replace("{" + "principal" + "}", encodeURIComponent(String(requestParameters.principal))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return AddressStxInboundListResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of STX transfers with memos to the given principal. This includes regular transfers from a stx-transfer transaction type, and transfers from contract-call transactions a the `send-many-memo` bulk sending contract.
     * Get inbound STX transfers
     */
    ;

    _proto.getAccountInbound = function getAccountInbound(requestParameters, initOverrides) {
      try {
        var _this12 = this;

        return Promise.resolve(_this12.getAccountInboundRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the account data for a given Account or a Contract Identifier  Where balance is the hex encoding of a unsigned 128-bit integer (big-endian), nonce is an unsigned 64-bit integer, and the proofs are provided as hex strings.  For non-existent accounts, this does not return a 404 error, rather it returns an object with balance and nonce of 0.
     * Get account info
     */
    ;

    _proto.getAccountInfoRaw = function getAccountInfoRaw(requestParameters, initOverrides) {
      try {
        var _this14 = this;

        if (requestParameters.principal === null || requestParameters.principal === undefined) {
          throw new RequiredError('principal', 'Required parameter requestParameters.principal was null or undefined when calling getAccountInfo.');
        }

        var queryParameters = {};

        if (requestParameters.proof !== undefined) {
          queryParameters['proof'] = requestParameters.proof;
        }

        if (requestParameters.tip !== undefined) {
          queryParameters['tip'] = requestParameters.tip;
        }

        var headerParameters = {};
        return Promise.resolve(_this14.request({
          path: "/v2/accounts/{principal}".replace("{" + "principal" + "}", encodeURIComponent(String(requestParameters.principal))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return AccountDataResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the account data for a given Account or a Contract Identifier  Where balance is the hex encoding of a unsigned 128-bit integer (big-endian), nonce is an unsigned 64-bit integer, and the proofs are provided as hex strings.  For non-existent accounts, this does not return a 404 error, rather it returns an object with balance and nonce of 0.
     * Get account info
     */
    ;

    _proto.getAccountInfo = function getAccountInfo(requestParameters, initOverrides) {
      try {
        var _this16 = this;

        return Promise.resolve(_this16.getAccountInfoRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * **NOTE:** This endpoint is deprecated in favor of [Non-Fungible Token holdings](#operation/get_nft_holdings).  Retrieves a list of all nfts owned by an address, contains the clarity value of the identifier of the nft.
     * Get nft events
     */
    ;

    _proto.getAccountNftRaw = function getAccountNftRaw(requestParameters, initOverrides) {
      try {
        var _this18 = this;

        if (requestParameters.principal === null || requestParameters.principal === undefined) {
          throw new RequiredError('principal', 'Required parameter requestParameters.principal was null or undefined when calling getAccountNft.');
        }

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.unanchored !== undefined) {
          queryParameters['unanchored'] = requestParameters.unanchored;
        }

        if (requestParameters.untilBlock !== undefined) {
          queryParameters['until_block'] = requestParameters.untilBlock;
        }

        var headerParameters = {};
        return Promise.resolve(_this18.request({
          path: "/extended/v1/address/{principal}/nft_events".replace("{" + "principal" + "}", encodeURIComponent(String(requestParameters.principal))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return AddressNftListResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * **NOTE:** This endpoint is deprecated in favor of [Non-Fungible Token holdings](#operation/get_nft_holdings).  Retrieves a list of all nfts owned by an address, contains the clarity value of the identifier of the nft.
     * Get nft events
     */
    ;

    _proto.getAccountNft = function getAccountNft(requestParameters, initOverrides) {
      try {
        var _this20 = this;

        return Promise.resolve(_this20.getAccountNftRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the latest nonce values used by an account by inspecting the mempool, microblock transactions, and anchored transactions.
     * Get the latest nonce used by an account
     */
    ;

    _proto.getAccountNoncesRaw = function getAccountNoncesRaw(requestParameters, initOverrides) {
      try {
        var _this22 = this;

        if (requestParameters.principal === null || requestParameters.principal === undefined) {
          throw new RequiredError('principal', 'Required parameter requestParameters.principal was null or undefined when calling getAccountNonces.');
        }

        var queryParameters = {};

        if (requestParameters.blockHeight !== undefined) {
          queryParameters['block_height'] = requestParameters.blockHeight;
        }

        if (requestParameters.blockHash !== undefined) {
          queryParameters['block_hash'] = requestParameters.blockHash;
        }

        var headerParameters = {};
        return Promise.resolve(_this22.request({
          path: "/extended/v1/address/{principal}/nonces".replace("{" + "principal" + "}", encodeURIComponent(String(requestParameters.principal))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return AddressNoncesFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the latest nonce values used by an account by inspecting the mempool, microblock transactions, and anchored transactions.
     * Get the latest nonce used by an account
     */
    ;

    _proto.getAccountNonces = function getAccountNonces(requestParameters, initOverrides) {
      try {
        var _this24 = this;

        return Promise.resolve(_this24.getAccountNoncesRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves STX token balance for a given Address or Contract Identifier.
     * Get account STX balance
     */
    ;

    _proto.getAccountStxBalanceRaw = function getAccountStxBalanceRaw(requestParameters, initOverrides) {
      try {
        var _this26 = this;

        if (requestParameters.principal === null || requestParameters.principal === undefined) {
          throw new RequiredError('principal', 'Required parameter requestParameters.principal was null or undefined when calling getAccountStxBalance.');
        }

        var queryParameters = {};

        if (requestParameters.unanchored !== undefined) {
          queryParameters['unanchored'] = requestParameters.unanchored;
        }

        if (requestParameters.untilBlock !== undefined) {
          queryParameters['until_block'] = requestParameters.untilBlock;
        }

        var headerParameters = {};
        return Promise.resolve(_this26.request({
          path: "/extended/v1/address/{principal}/stx".replace("{" + "principal" + "}", encodeURIComponent(String(requestParameters.principal))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves STX token balance for a given Address or Contract Identifier.
     * Get account STX balance
     */
    ;

    _proto.getAccountStxBalance = function getAccountStxBalance(requestParameters, initOverrides) {
      try {
        var _this28 = this;

        return Promise.resolve(_this28.getAccountStxBalanceRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of all Transactions for a given Address or Contract Identifier. More information on Transaction types can be found [here](https://docs.stacks.co/understand-stacks/transactions#types).  If you need to actively monitor new transactions for an address or contract id, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates.
     * Get account transactions
     */
    ;

    _proto.getAccountTransactionsRaw = function getAccountTransactionsRaw(requestParameters, initOverrides) {
      try {
        var _this30 = this;

        if (requestParameters.principal === null || requestParameters.principal === undefined) {
          throw new RequiredError('principal', 'Required parameter requestParameters.principal was null or undefined when calling getAccountTransactions.');
        }

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.height !== undefined) {
          queryParameters['height'] = requestParameters.height;
        }

        if (requestParameters.unanchored !== undefined) {
          queryParameters['unanchored'] = requestParameters.unanchored;
        }

        if (requestParameters.untilBlock !== undefined) {
          queryParameters['until_block'] = requestParameters.untilBlock;
        }

        var headerParameters = {};
        return Promise.resolve(_this30.request({
          path: "/extended/v1/address/{principal}/transactions".replace("{" + "principal" + "}", encodeURIComponent(String(requestParameters.principal))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return AddressTransactionsListResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of all Transactions for a given Address or Contract Identifier. More information on Transaction types can be found [here](https://docs.stacks.co/understand-stacks/transactions#types).  If you need to actively monitor new transactions for an address or contract id, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates.
     * Get account transactions
     */
    ;

    _proto.getAccountTransactions = function getAccountTransactions(requestParameters, initOverrides) {
      try {
        var _this32 = this;

        return Promise.resolve(_this32.getAccountTransactionsRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieve all transactions for an account or contract identifier including STX transfers for each transaction.
     * Get account transactions including STX transfers for each transaction.
     */
    ;

    _proto.getAccountTransactionsWithTransfersRaw = function getAccountTransactionsWithTransfersRaw(requestParameters, initOverrides) {
      try {
        var _this34 = this;

        if (requestParameters.principal === null || requestParameters.principal === undefined) {
          throw new RequiredError('principal', 'Required parameter requestParameters.principal was null or undefined when calling getAccountTransactionsWithTransfers.');
        }

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.height !== undefined) {
          queryParameters['height'] = requestParameters.height;
        }

        if (requestParameters.unanchored !== undefined) {
          queryParameters['unanchored'] = requestParameters.unanchored;
        }

        if (requestParameters.untilBlock !== undefined) {
          queryParameters['until_block'] = requestParameters.untilBlock;
        }

        var headerParameters = {};
        return Promise.resolve(_this34.request({
          path: "/extended/v1/address/{principal}/transactions_with_transfers".replace("{" + "principal" + "}", encodeURIComponent(String(requestParameters.principal))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return AddressTransactionsWithTransfersListResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieve all transactions for an account or contract identifier including STX transfers for each transaction.
     * Get account transactions including STX transfers for each transaction.
     */
    ;

    _proto.getAccountTransactionsWithTransfers = function getAccountTransactionsWithTransfers(requestParameters, initOverrides) {
      try {
        var _this36 = this;

        return Promise.resolve(_this36.getAccountTransactionsWithTransfersRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves transaction details for a given Transaction Id `tx_id`, for a given account or contract Identifier.
     * Get account transaction information for specific transaction
     */
    ;

    _proto.getSingleTransactionWithTransfersRaw = function getSingleTransactionWithTransfersRaw(requestParameters, initOverrides) {
      try {
        var _this38 = this;

        if (requestParameters.principal === null || requestParameters.principal === undefined) {
          throw new RequiredError('principal', 'Required parameter requestParameters.principal was null or undefined when calling getSingleTransactionWithTransfers.');
        }

        if (requestParameters.txId === null || requestParameters.txId === undefined) {
          throw new RequiredError('txId', 'Required parameter requestParameters.txId was null or undefined when calling getSingleTransactionWithTransfers.');
        }

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this38.request({
          path: "/extended/v1/address/{principal}/{tx_id}/with_transfers".replace("{" + "principal" + "}", encodeURIComponent(String(requestParameters.principal))).replace("{" + "tx_id" + "}", encodeURIComponent(String(requestParameters.txId))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return AddressTransactionWithTransfersFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves transaction details for a given Transaction Id `tx_id`, for a given account or contract Identifier.
     * Get account transaction information for specific transaction
     */
    ;

    _proto.getSingleTransactionWithTransfers = function getSingleTransactionWithTransfers(requestParameters, initOverrides) {
      try {
        var _this40 = this;

        return Promise.resolve(_this40.getSingleTransactionWithTransfersRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    return AccountsApi;
  }(BaseAPI);

  /**
   *
   */

  var BlocksApi = /*#__PURE__*/function (_runtime$BaseAPI) {
    _inheritsLoose(BlocksApi, _runtime$BaseAPI);

    function BlocksApi() {
      return _runtime$BaseAPI.apply(this, arguments) || this;
    }

    var _proto = BlocksApi.prototype;

    /**
     * Retrieves block details of a specific block for a given burnchain block hash
     * Get block by burnchain block hash
     */
    _proto.getBlockByBurnBlockHashRaw = function getBlockByBurnBlockHashRaw(requestParameters, initOverrides) {
      try {
        var _this2 = this;

        if (requestParameters.burnBlockHash === null || requestParameters.burnBlockHash === undefined) {
          throw new RequiredError('burnBlockHash', 'Required parameter requestParameters.burnBlockHash was null or undefined when calling getBlockByBurnBlockHash.');
        }

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this2.request({
          path: "/extended/v1/block/by_burn_block_hash/{burn_block_hash}".replace("{" + "burn_block_hash" + "}", encodeURIComponent(String(requestParameters.burnBlockHash))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return BlockFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves block details of a specific block for a given burnchain block hash
     * Get block by burnchain block hash
     */
    ;

    _proto.getBlockByBurnBlockHash = function getBlockByBurnBlockHash(requestParameters, initOverrides) {
      try {
        var _this4 = this;

        return Promise.resolve(_this4.getBlockByBurnBlockHashRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves block details of a specific block for a given burn chain height
     * Get block by burnchain height
     */
    ;

    _proto.getBlockByBurnBlockHeightRaw = function getBlockByBurnBlockHeightRaw(requestParameters, initOverrides) {
      try {
        var _this6 = this;

        if (requestParameters.burnBlockHeight === null || requestParameters.burnBlockHeight === undefined) {
          throw new RequiredError('burnBlockHeight', 'Required parameter requestParameters.burnBlockHeight was null or undefined when calling getBlockByBurnBlockHeight.');
        }

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this6.request({
          path: "/extended/v1/block/by_burn_block_height/{burn_block_height}".replace("{" + "burn_block_height" + "}", encodeURIComponent(String(requestParameters.burnBlockHeight))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return BlockFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves block details of a specific block for a given burn chain height
     * Get block by burnchain height
     */
    ;

    _proto.getBlockByBurnBlockHeight = function getBlockByBurnBlockHeight(requestParameters, initOverrides) {
      try {
        var _this8 = this;

        return Promise.resolve(_this8.getBlockByBurnBlockHeightRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves block details of a specific block for a given chain height. You can use the hash from your latest block (\'get_block_list\' API) to get your block details.
     * Get block by hash
     */
    ;

    _proto.getBlockByHashRaw = function getBlockByHashRaw(requestParameters, initOverrides) {
      try {
        var _this10 = this;

        if (requestParameters.hash === null || requestParameters.hash === undefined) {
          throw new RequiredError('hash', 'Required parameter requestParameters.hash was null or undefined when calling getBlockByHash.');
        }

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this10.request({
          path: "/extended/v1/block/{hash}".replace("{" + "hash" + "}", encodeURIComponent(String(requestParameters.hash))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return BlockFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves block details of a specific block for a given chain height. You can use the hash from your latest block (\'get_block_list\' API) to get your block details.
     * Get block by hash
     */
    ;

    _proto.getBlockByHash = function getBlockByHash(requestParameters, initOverrides) {
      try {
        var _this12 = this;

        return Promise.resolve(_this12.getBlockByHashRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves block details of a specific block at a given block height
     * Get block by height
     */
    ;

    _proto.getBlockByHeightRaw = function getBlockByHeightRaw(requestParameters, initOverrides) {
      try {
        var _this14 = this;

        if (requestParameters.height === null || requestParameters.height === undefined) {
          throw new RequiredError('height', 'Required parameter requestParameters.height was null or undefined when calling getBlockByHeight.');
        }

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this14.request({
          path: "/extended/v1/block/by_height/{height}".replace("{" + "height" + "}", encodeURIComponent(String(requestParameters.height))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return BlockFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves block details of a specific block at a given block height
     * Get block by height
     */
    ;

    _proto.getBlockByHeight = function getBlockByHeight(requestParameters, initOverrides) {
      try {
        var _this16 = this;

        return Promise.resolve(_this16.getBlockByHeightRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of recently mined blocks  If you need to actively monitor new blocks, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates.
     * Get recent blocks
     */
    ;

    _proto.getBlockListRaw = function getBlockListRaw(requestParameters, initOverrides) {
      try {
        var _this18 = this;

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        var headerParameters = {};
        return Promise.resolve(_this18.request({
          path: "/extended/v1/block",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return BlockListResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of recently mined blocks  If you need to actively monitor new blocks, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates.
     * Get recent blocks
     */
    ;

    _proto.getBlockList = function getBlockList(requestParameters, initOverrides) {
      try {
        var _this20 = this;

        return Promise.resolve(_this20.getBlockListRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    return BlocksApi;
  }(BaseAPI);

  /**
   *
   */

  var FaucetsApi = /*#__PURE__*/function (_runtime$BaseAPI) {
    _inheritsLoose(FaucetsApi, _runtime$BaseAPI);

    function FaucetsApi() {
      return _runtime$BaseAPI.apply(this, arguments) || this;
    }

    var _proto = FaucetsApi.prototype;

    /**
     * Add 1 BTC token to the specified testnet BTC address.  The endpoint returns the transaction ID, which you can use to view the transaction in a testnet Bitcoin block explorer. The tokens are delivered once the transaction has been included in a block.  **Note:** This is a testnet only endpoint. This endpoint will not work on the mainnet.
     * Add testnet BTC tokens to address
     */
    _proto.runFaucetBtcRaw = function runFaucetBtcRaw(requestParameters, initOverrides) {
      try {
        var _this2 = this;

        if (requestParameters.address === null || requestParameters.address === undefined) {
          throw new RequiredError('address', 'Required parameter requestParameters.address was null or undefined when calling runFaucetBtc.');
        }

        var queryParameters = {};

        if (requestParameters.address !== undefined) {
          queryParameters['address'] = requestParameters.address;
        }

        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this2.request({
          path: "/extended/v1/faucets/btc",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: InlineObject1ToJSON(requestParameters.inlineObject1)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return RunFaucetResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Add 1 BTC token to the specified testnet BTC address.  The endpoint returns the transaction ID, which you can use to view the transaction in a testnet Bitcoin block explorer. The tokens are delivered once the transaction has been included in a block.  **Note:** This is a testnet only endpoint. This endpoint will not work on the mainnet.
     * Add testnet BTC tokens to address
     */
    ;

    _proto.runFaucetBtc = function runFaucetBtc(requestParameters, initOverrides) {
      try {
        var _this4 = this;

        return Promise.resolve(_this4.runFaucetBtcRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Add 500 STX tokens to the specified testnet address. Testnet STX addresses begin with `ST`. If the `stacking` parameter is set to `true`, the faucet will add the required number of tokens for individual stacking to the specified testnet address.  The endpoint returns the transaction ID, which you can use to view the transaction in the [Stacks Explorer](https://explorer.stacks.co/?chain=testnet). The tokens are delivered once the transaction has been included in an anchor block.  A common reason for failed faucet transactions is that the faucet has run out of tokens. If you are experiencing failed faucet transactions to a testnet address, you can get help in [Discord](https://stacks.chat).  **Note:** This is a testnet only endpoint. This endpoint will not work on the mainnet.
     * Get STX testnet tokens
     */
    ;

    _proto.runFaucetStxRaw = function runFaucetStxRaw(requestParameters, initOverrides) {
      try {
        var _this6 = this;

        if (requestParameters.address === null || requestParameters.address === undefined) {
          throw new RequiredError('address', 'Required parameter requestParameters.address was null or undefined when calling runFaucetStx.');
        }

        var queryParameters = {};

        if (requestParameters.address !== undefined) {
          queryParameters['address'] = requestParameters.address;
        }

        if (requestParameters.stacking !== undefined) {
          queryParameters['stacking'] = requestParameters.stacking;
        }

        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this6.request({
          path: "/extended/v1/faucets/stx",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: InlineObjectToJSON(requestParameters.inlineObject)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return RunFaucetResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Add 500 STX tokens to the specified testnet address. Testnet STX addresses begin with `ST`. If the `stacking` parameter is set to `true`, the faucet will add the required number of tokens for individual stacking to the specified testnet address.  The endpoint returns the transaction ID, which you can use to view the transaction in the [Stacks Explorer](https://explorer.stacks.co/?chain=testnet). The tokens are delivered once the transaction has been included in an anchor block.  A common reason for failed faucet transactions is that the faucet has run out of tokens. If you are experiencing failed faucet transactions to a testnet address, you can get help in [Discord](https://stacks.chat).  **Note:** This is a testnet only endpoint. This endpoint will not work on the mainnet.
     * Get STX testnet tokens
     */
    ;

    _proto.runFaucetStx = function runFaucetStx(requestParameters, initOverrides) {
      try {
        var _this8 = this;

        return Promise.resolve(_this8.runFaucetStxRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    return FaucetsApi;
  }(BaseAPI);

  /**
   *
   */

  var FeesApi = /*#__PURE__*/function (_runtime$BaseAPI) {
    _inheritsLoose(FeesApi, _runtime$BaseAPI);

    function FeesApi() {
      return _runtime$BaseAPI.apply(this, arguments) || this;
    }

    var _proto = FeesApi.prototype;

    /**
     * **NOTE:** This endpoint is deprecated in favor of [Get approximate fees for a given transaction](#operation/post_fee_transaction).  Retrieves estimated fee rate.
     * Fetch fee rate
     */
    _proto.fetchFeeRateRaw = function fetchFeeRateRaw(requestParameters, initOverrides) {
      try {
        var _this2 = this;

        if (requestParameters.feeRateRequest === null || requestParameters.feeRateRequest === undefined) {
          throw new RequiredError('feeRateRequest', 'Required parameter requestParameters.feeRateRequest was null or undefined when calling fetchFeeRate.');
        }

        var queryParameters = {};
        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this2.request({
          path: "/extended/v1/fee_rate",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: FeeRateRequestToJSON(requestParameters.feeRateRequest)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return FeeRateFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * **NOTE:** This endpoint is deprecated in favor of [Get approximate fees for a given transaction](#operation/post_fee_transaction).  Retrieves estimated fee rate.
     * Fetch fee rate
     */
    ;

    _proto.fetchFeeRate = function fetchFeeRate(requestParameters, initOverrides) {
      try {
        var _this4 = this;

        return Promise.resolve(_this4.fetchFeeRateRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves an estimated fee rate for STX transfer transactions. This a a fee rate / byte, and is returned as a JSON integer
     * Get estimated fee
     */
    ;

    _proto.getFeeTransferRaw = function getFeeTransferRaw(initOverrides) {
      try {
        var _this6 = this;

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this6.request({
          path: "/v2/fees/transfer",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves an estimated fee rate for STX transfer transactions. This a a fee rate / byte, and is returned as a JSON integer
     * Get estimated fee
     */
    ;

    _proto.getFeeTransfer = function getFeeTransfer(initOverrides) {
      try {
        var _this8 = this;

        return Promise.resolve(_this8.getFeeTransferRaw(initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Get an estimated fee for the supplied transaction.  This estimates the execution cost of the transaction, the current fee rate of the network, and returns estimates for fee amounts. * `transaction_payload` is a hex-encoded serialization of   the TransactionPayload for the transaction. * `estimated_len` is an optional argument that provides the   endpoint with an estimation of the final length (in bytes)   of the transaction, including any post-conditions and   signatures If the node cannot provide an estimate for the transaction (e.g., if the node has never seen a contract-call for the given contract and function) or if estimation is not configured on this node, a 400 response is returned. The 400 response will be a JSON error containing a `reason` field which can be one of the following: * `DatabaseError` - this Stacks node has had an internal   database error while trying to estimate the costs of the   supplied transaction. * `NoEstimateAvailable` - this Stacks node has not seen this   kind of contract-call before, and it cannot provide an   estimate yet. * `CostEstimationDisabled` - this Stacks node does not perform   fee or cost estimation, and it cannot respond on this   endpoint. The 200 response contains the following data: * `estimated_cost` - the estimated multi-dimensional cost of   executing the Clarity VM on the provided transaction. * `estimated_cost_scalar` - a unitless integer that the Stacks   node uses to compare how much of the block limit is consumed   by different transactions. This value incorporates the   estimated length of the transaction and the estimated   execution cost of the transaction. The range of this integer   may vary between different Stacks nodes. In order to compute   an estimate of total fee amount for the transaction, this   value is multiplied by the same Stacks node\'s estimated fee   rate. * `cost_scalar_change_by_byte` - a float value that indicates how   much the `estimated_cost_scalar` value would increase for every   additional byte in the final transaction. * `estimations` - an array of estimated fee rates and total fees to   pay in microSTX for the transaction. This array provides a range of   estimates (default: 3) that may be used. Each element of the array   contains the following fields:     * `fee_rate` - the estimated value for the current fee       rates in the network     * `fee` - the estimated value for the total fee in       microSTX that the given transaction should pay. These       values are the result of computing:       `fee_rate` x `estimated_cost_scalar`.       If the estimated fees are less than the minimum relay       fee `(1 ustx x estimated_len)`, then that minimum relay       fee will be returned here instead. Note: If the final transaction\'s byte size is larger than supplied to `estimated_len`, then applications should increase this fee amount by:   `fee_rate` x `cost_scalar_change_by_byte` x (`final_size` - `estimated_size`)
     * Get approximate fees for a given transaction
     */
    ;

    _proto.postFeeTransactionRaw = function postFeeTransactionRaw(requestParameters, initOverrides) {
      try {
        var _this10 = this;

        var queryParameters = {};
        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this10.request({
          path: "/v2/fees/transaction",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: TransactionFeeEstimateRequestToJSON(requestParameters.transactionFeeEstimateRequest)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return TransactionFeeEstimateResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Get an estimated fee for the supplied transaction.  This estimates the execution cost of the transaction, the current fee rate of the network, and returns estimates for fee amounts. * `transaction_payload` is a hex-encoded serialization of   the TransactionPayload for the transaction. * `estimated_len` is an optional argument that provides the   endpoint with an estimation of the final length (in bytes)   of the transaction, including any post-conditions and   signatures If the node cannot provide an estimate for the transaction (e.g., if the node has never seen a contract-call for the given contract and function) or if estimation is not configured on this node, a 400 response is returned. The 400 response will be a JSON error containing a `reason` field which can be one of the following: * `DatabaseError` - this Stacks node has had an internal   database error while trying to estimate the costs of the   supplied transaction. * `NoEstimateAvailable` - this Stacks node has not seen this   kind of contract-call before, and it cannot provide an   estimate yet. * `CostEstimationDisabled` - this Stacks node does not perform   fee or cost estimation, and it cannot respond on this   endpoint. The 200 response contains the following data: * `estimated_cost` - the estimated multi-dimensional cost of   executing the Clarity VM on the provided transaction. * `estimated_cost_scalar` - a unitless integer that the Stacks   node uses to compare how much of the block limit is consumed   by different transactions. This value incorporates the   estimated length of the transaction and the estimated   execution cost of the transaction. The range of this integer   may vary between different Stacks nodes. In order to compute   an estimate of total fee amount for the transaction, this   value is multiplied by the same Stacks node\'s estimated fee   rate. * `cost_scalar_change_by_byte` - a float value that indicates how   much the `estimated_cost_scalar` value would increase for every   additional byte in the final transaction. * `estimations` - an array of estimated fee rates and total fees to   pay in microSTX for the transaction. This array provides a range of   estimates (default: 3) that may be used. Each element of the array   contains the following fields:     * `fee_rate` - the estimated value for the current fee       rates in the network     * `fee` - the estimated value for the total fee in       microSTX that the given transaction should pay. These       values are the result of computing:       `fee_rate` x `estimated_cost_scalar`.       If the estimated fees are less than the minimum relay       fee `(1 ustx x estimated_len)`, then that minimum relay       fee will be returned here instead. Note: If the final transaction\'s byte size is larger than supplied to `estimated_len`, then applications should increase this fee amount by:   `fee_rate` x `cost_scalar_change_by_byte` x (`final_size` - `estimated_size`)
     * Get approximate fees for a given transaction
     */
    ;

    _proto.postFeeTransaction = function postFeeTransaction(requestParameters, initOverrides) {
      try {
        var _this12 = this;

        return Promise.resolve(_this12.postFeeTransactionRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    return FeesApi;
  }(BaseAPI);

  /**
   *
   */

  var FungibleTokensApi = /*#__PURE__*/function (_runtime$BaseAPI) {
    _inheritsLoose(FungibleTokensApi, _runtime$BaseAPI);

    function FungibleTokensApi() {
      return _runtime$BaseAPI.apply(this, arguments) || this;
    }

    var _proto = FungibleTokensApi.prototype;

    /**
     * Retrieves the metadata for fungible tokens for a given contract id
     * Fungible tokens metadata for contract id
     */
    _proto.getContractFtMetadataRaw = function getContractFtMetadataRaw(requestParameters, initOverrides) {
      try {
        var _this2 = this;

        if (requestParameters.contractId === null || requestParameters.contractId === undefined) {
          throw new RequiredError('contractId', 'Required parameter requestParameters.contractId was null or undefined when calling getContractFtMetadata.');
        }

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this2.request({
          path: "/extended/v1/tokens/{contractId}/ft/metadata".replace("{" + "contractId" + "}", encodeURIComponent(String(requestParameters.contractId))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return FungibleTokenMetadataFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the metadata for fungible tokens for a given contract id
     * Fungible tokens metadata for contract id
     */
    ;

    _proto.getContractFtMetadata = function getContractFtMetadata(requestParameters, initOverrides) {
      try {
        var _this4 = this;

        return Promise.resolve(_this4.getContractFtMetadataRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves list of fungible tokens with their metadata. More information on Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#fungible-tokens).
     * Fungible tokens metadata list
     */
    ;

    _proto.getFtMetadataListRaw = function getFtMetadataListRaw(requestParameters, initOverrides) {
      try {
        var _this6 = this;

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        var headerParameters = {};
        return Promise.resolve(_this6.request({
          path: "/extended/v1/tokens/ft/metadata",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return FungibleTokensMetadataListFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves list of fungible tokens with their metadata. More information on Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#fungible-tokens).
     * Fungible tokens metadata list
     */
    ;

    _proto.getFtMetadataList = function getFtMetadataList(requestParameters, initOverrides) {
      try {
        var _this8 = this;

        return Promise.resolve(_this8.getFtMetadataListRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    return FungibleTokensApi;
  }(BaseAPI);

  /**
   *
   */

  var InfoApi = /*#__PURE__*/function (_runtime$BaseAPI) {
    _inheritsLoose(InfoApi, _runtime$BaseAPI);

    function InfoApi() {
      return _runtime$BaseAPI.apply(this, arguments) || this;
    }

    var _proto = InfoApi.prototype;

    /**
     * Retrieves information about the Core API including the server version
     * Get Core API info
     */
    _proto.getCoreApiInfoRaw = function getCoreApiInfoRaw(initOverrides) {
      try {
        var _this2 = this;

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this2.request({
          path: "/v2/info",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return CoreNodeInfoResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves information about the Core API including the server version
     * Get Core API info
     */
    ;

    _proto.getCoreApiInfo = function getCoreApiInfo(initOverrides) {
      try {
        var _this4 = this;

        return Promise.resolve(_this4.getCoreApiInfoRaw(initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the target block time for a given network. The network can be mainnet or testnet. The block time is hardcoded and will change throughout the implementation phases of the testnet.
     * Get a given network\'s target block time
     */
    ;

    _proto.getNetworkBlockTimeByNetworkRaw = function getNetworkBlockTimeByNetworkRaw(requestParameters, initOverrides) {
      try {
        var _this6 = this;

        if (requestParameters.network === null || requestParameters.network === undefined) {
          throw new RequiredError('network', 'Required parameter requestParameters.network was null or undefined when calling getNetworkBlockTimeByNetwork.');
        }

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this6.request({
          path: "/extended/v1/info/network_block_time/{network}".replace("{" + "network" + "}", encodeURIComponent(String(requestParameters.network))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return NetworkBlockTimeResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the target block time for a given network. The network can be mainnet or testnet. The block time is hardcoded and will change throughout the implementation phases of the testnet.
     * Get a given network\'s target block time
     */
    ;

    _proto.getNetworkBlockTimeByNetwork = function getNetworkBlockTimeByNetwork(requestParameters, initOverrides) {
      try {
        var _this8 = this;

        return Promise.resolve(_this8.getNetworkBlockTimeByNetworkRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the target block times for mainnet and testnet. The block time is hardcoded and will change throughout the implementation phases of the testnet.
     * Get the network target block time
     */
    ;

    _proto.getNetworkBlockTimesRaw = function getNetworkBlockTimesRaw(initOverrides) {
      try {
        var _this10 = this;

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this10.request({
          path: "/extended/v1/info/network_block_times",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return NetworkBlockTimesResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the target block times for mainnet and testnet. The block time is hardcoded and will change throughout the implementation phases of the testnet.
     * Get the network target block time
     */
    ;

    _proto.getNetworkBlockTimes = function getNetworkBlockTimes(initOverrides) {
      try {
        var _this12 = this;

        return Promise.resolve(_this12.getNetworkBlockTimesRaw(initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves Proof-of-Transfer (PoX) information. Can be used for Stacking.
     * Get Proof-of-Transfer details
     */
    ;

    _proto.getPoxInfoRaw = function getPoxInfoRaw(initOverrides) {
      try {
        var _this14 = this;

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this14.request({
          path: "/v2/pox",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return CoreNodePoxResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves Proof-of-Transfer (PoX) information. Can be used for Stacking.
     * Get Proof-of-Transfer details
     */
    ;

    _proto.getPoxInfo = function getPoxInfo(initOverrides) {
      try {
        var _this16 = this;

        return Promise.resolve(_this16.getPoxInfoRaw(initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the running status of the Stacks Blockchain API, including the server version and current chain tip information.
     * API status
     */
    ;

    _proto.getStatusRaw = function getStatusRaw(initOverrides) {
      try {
        var _this18 = this;

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this18.request({
          path: "/extended/v1/status",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return ServerStatusResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the running status of the Stacks Blockchain API, including the server version and current chain tip information.
     * API status
     */
    ;

    _proto.getStatus = function getStatus(initOverrides) {
      try {
        var _this20 = this;

        return Promise.resolve(_this20.getStatusRaw(initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the total and unlocked STX supply. More information on Stacking can be found [here] (https://docs.stacks.co/understand-stacks/stacking). **Note:** This uses the estimated future total supply for the year 2050.
     * Get total and unlocked STX supply
     */
    ;

    _proto.getStxSupplyRaw = function getStxSupplyRaw(requestParameters, initOverrides) {
      try {
        var _this22 = this;

        var queryParameters = {};

        if (requestParameters.height !== undefined) {
          queryParameters['height'] = requestParameters.height;
        }

        var headerParameters = {};
        return Promise.resolve(_this22.request({
          path: "/extended/v1/stx_supply",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return GetStxSupplyResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the total and unlocked STX supply. More information on Stacking can be found [here] (https://docs.stacks.co/understand-stacks/stacking). **Note:** This uses the estimated future total supply for the year 2050.
     * Get total and unlocked STX supply
     */
    ;

    _proto.getStxSupply = function getStxSupply(requestParameters, initOverrides) {
      try {
        var _this24 = this;

        return Promise.resolve(_this24.getStxSupplyRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the STX tokens currently in circulation that have been unlocked as plain text.
     * Get circulating STX supply in plain text format
     */
    ;

    _proto.getStxSupplyCirculatingPlainRaw = function getStxSupplyCirculatingPlainRaw(initOverrides) {
      try {
        var _this26 = this;

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this26.request({
          path: "/extended/v1/stx_supply/circulating/plain",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new TextApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the STX tokens currently in circulation that have been unlocked as plain text.
     * Get circulating STX supply in plain text format
     */
    ;

    _proto.getStxSupplyCirculatingPlain = function getStxSupplyCirculatingPlain(initOverrides) {
      try {
        var _this28 = this;

        return Promise.resolve(_this28.getStxSupplyCirculatingPlainRaw(initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the total supply for STX tokens as plain text. **Note:** this uses the estimated future total supply for the year 2050.
     * Get total STX supply in plain text format
     */
    ;

    _proto.getStxSupplyTotalSupplyPlainRaw = function getStxSupplyTotalSupplyPlainRaw(initOverrides) {
      try {
        var _this30 = this;

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this30.request({
          path: "/extended/v1/stx_supply/total/plain",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new TextApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the total supply for STX tokens as plain text. **Note:** this uses the estimated future total supply for the year 2050.
     * Get total STX supply in plain text format
     */
    ;

    _proto.getStxSupplyTotalSupplyPlain = function getStxSupplyTotalSupplyPlain(initOverrides) {
      try {
        var _this32 = this;

        return Promise.resolve(_this32.getStxSupplyTotalSupplyPlainRaw(initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves total supply of STX tokens including those currently in circulation that have been unlocked. **Note:** this uses the estimated future total supply for the year 2050.
     * Get total and unlocked STX supply (results formatted the same as the legacy 1.0 API)
     */
    ;

    _proto.getTotalStxSupplyLegacyFormatRaw = function getTotalStxSupplyLegacyFormatRaw(requestParameters, initOverrides) {
      try {
        var _this34 = this;

        var queryParameters = {};

        if (requestParameters.height !== undefined) {
          queryParameters['height'] = requestParameters.height;
        }

        var headerParameters = {};
        return Promise.resolve(_this34.request({
          path: "/extended/v1/stx_supply/legacy_format",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return GetStxSupplyLegacyFormatResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves total supply of STX tokens including those currently in circulation that have been unlocked. **Note:** this uses the estimated future total supply for the year 2050.
     * Get total and unlocked STX supply (results formatted the same as the legacy 1.0 API)
     */
    ;

    _proto.getTotalStxSupplyLegacyFormat = function getTotalStxSupplyLegacyFormat(requestParameters, initOverrides) {
      try {
        var _this36 = this;

        return Promise.resolve(_this36.getTotalStxSupplyLegacyFormatRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    return InfoApi;
  }(BaseAPI);
  /**
      * @export
      * @enum {string}
      */

  exports.GetNetworkBlockTimeByNetworkNetworkEnum = void 0;

  (function (GetNetworkBlockTimeByNetworkNetworkEnum) {
    GetNetworkBlockTimeByNetworkNetworkEnum["testnet"] = "testnet";
    GetNetworkBlockTimeByNetworkNetworkEnum["mainnet"] = "mainnet";
  })(exports.GetNetworkBlockTimeByNetworkNetworkEnum || (exports.GetNetworkBlockTimeByNetworkNetworkEnum = {}));

  /**
   *
   */

  var MicroblocksApi = /*#__PURE__*/function (_runtime$BaseAPI) {
    _inheritsLoose(MicroblocksApi, _runtime$BaseAPI);

    function MicroblocksApi() {
      return _runtime$BaseAPI.apply(this, arguments) || this;
    }

    var _proto = MicroblocksApi.prototype;

    /**
     * Retrieves a specific microblock by `hash`
     * Get microblock
     */
    _proto.getMicroblockByHashRaw = function getMicroblockByHashRaw(requestParameters, initOverrides) {
      try {
        var _this2 = this;

        if (requestParameters.hash === null || requestParameters.hash === undefined) {
          throw new RequiredError('hash', 'Required parameter requestParameters.hash was null or undefined when calling getMicroblockByHash.');
        }

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this2.request({
          path: "/extended/v1/microblock/{hash}".replace("{" + "hash" + "}", encodeURIComponent(String(requestParameters.hash))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return MicroblockFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a specific microblock by `hash`
     * Get microblock
     */
    ;

    _proto.getMicroblockByHash = function getMicroblockByHash(requestParameters, initOverrides) {
      try {
        var _this4 = this;

        return Promise.resolve(_this4.getMicroblockByHashRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of microblocks.  If you need to actively monitor new microblocks, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates.
     * Get recent microblocks
     */
    ;

    _proto.getMicroblockListRaw = function getMicroblockListRaw(requestParameters, initOverrides) {
      try {
        var _this6 = this;

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        var headerParameters = {};
        return Promise.resolve(_this6.request({
          path: "/extended/v1/microblock",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return MicroblockListResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of microblocks.  If you need to actively monitor new microblocks, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates.
     * Get recent microblocks
     */
    ;

    _proto.getMicroblockList = function getMicroblockList(requestParameters, initOverrides) {
      try {
        var _this8 = this;

        return Promise.resolve(_this8.getMicroblockListRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves transactions that have been streamed in microblocks but not yet accepted or rejected in an anchor block
     * Get the list of current transactions that belong to unanchored microblocks
     */
    ;

    _proto.getUnanchoredTxsRaw = function getUnanchoredTxsRaw(initOverrides) {
      try {
        var _this10 = this;

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this10.request({
          path: "/extended/v1/microblock/unanchored/txs",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return UnanchoredTransactionListResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves transactions that have been streamed in microblocks but not yet accepted or rejected in an anchor block
     * Get the list of current transactions that belong to unanchored microblocks
     */
    ;

    _proto.getUnanchoredTxs = function getUnanchoredTxs(initOverrides) {
      try {
        var _this12 = this;

        return Promise.resolve(_this12.getUnanchoredTxsRaw(initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    return MicroblocksApi;
  }(BaseAPI);

  /**
   *
   */

  var NamesApi = /*#__PURE__*/function (_runtime$BaseAPI) {
    _inheritsLoose(NamesApi, _runtime$BaseAPI);

    function NamesApi() {
      return _runtime$BaseAPI.apply(this, arguments) || this;
    }

    var _proto = NamesApi.prototype;

    /**
     * Retrieves the list of subdomains for a specific name
     * Get Name Subdomains
     */
    _proto.fetchSubdomainsListForNameRaw = function fetchSubdomainsListForNameRaw(requestParameters, initOverrides) {
      try {
        var _this2 = this;

        if (requestParameters.name === null || requestParameters.name === undefined) {
          throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling fetchSubdomainsListForName.');
        }

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this2.request({
          path: "/v1/names/{name}/subdomains".replace("{" + "name" + "}", encodeURIComponent(String(requestParameters.name))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the list of subdomains for a specific name
     * Get Name Subdomains
     */
    ;

    _proto.fetchSubdomainsListForName = function fetchSubdomainsListForName(requestParameters, initOverrides) {
      try {
        var _this4 = this;

        return Promise.resolve(_this4.fetchSubdomainsListForNameRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a user’s raw zone file. This only works for RFC-compliant zone files. This method returns an error for names that have non-standard zone files.
     * Get Zone File
     */
    ;

    _proto.fetchZoneFileRaw = function fetchZoneFileRaw(requestParameters, initOverrides) {
      try {
        var _this6 = this;

        if (requestParameters.name === null || requestParameters.name === undefined) {
          throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling fetchZoneFile.');
        }

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this6.request({
          path: "/v1/names/{name}/zonefile".replace("{" + "name" + "}", encodeURIComponent(String(requestParameters.name))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a user’s raw zone file. This only works for RFC-compliant zone files. This method returns an error for names that have non-standard zone files.
     * Get Zone File
     */
    ;

    _proto.fetchZoneFile = function fetchZoneFile(requestParameters, initOverrides) {
      try {
        var _this8 = this;

        return Promise.resolve(_this8.fetchZoneFileRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of all names known to the node.
     * Get All Names
     */
    ;

    _proto.getAllNamesRaw = function getAllNamesRaw(requestParameters, initOverrides) {
      try {
        var _this10 = this;

        var queryParameters = {};

        if (requestParameters.page !== undefined) {
          queryParameters['page'] = requestParameters.page;
        }

        var headerParameters = {};
        return Promise.resolve(_this10.request({
          path: "/v1/names",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of all names known to the node.
     * Get All Names
     */
    ;

    _proto.getAllNames = function getAllNames(requestParameters, initOverrides) {
      try {
        var _this12 = this;

        return Promise.resolve(_this12.getAllNamesRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of all namespaces known to the node.
     * Get All Namespaces
     */
    ;

    _proto.getAllNamespacesRaw = function getAllNamespacesRaw(initOverrides) {
      try {
        var _this14 = this;

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this14.request({
          path: "/v1/namespaces",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return BnsGetAllNamespacesResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of all namespaces known to the node.
     * Get All Namespaces
     */
    ;

    _proto.getAllNamespaces = function getAllNamespaces(initOverrides) {
      try {
        var _this16 = this;

        return Promise.resolve(_this16.getAllNamespacesRaw(initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the historical zonefile specified by the username and zone hash.
     * Get Historical Zone File
     */
    ;

    _proto.getHistoricalZoneFileRaw = function getHistoricalZoneFileRaw(requestParameters, initOverrides) {
      try {
        var _this18 = this;

        if (requestParameters.name === null || requestParameters.name === undefined) {
          throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling getHistoricalZoneFile.');
        }

        if (requestParameters.zoneFileHash === null || requestParameters.zoneFileHash === undefined) {
          throw new RequiredError('zoneFileHash', 'Required parameter requestParameters.zoneFileHash was null or undefined when calling getHistoricalZoneFile.');
        }

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this18.request({
          path: "/v1/names/{name}/zonefile/{zoneFileHash}".replace("{" + "name" + "}", encodeURIComponent(String(requestParameters.name))).replace("{" + "zoneFileHash" + "}", encodeURIComponent(String(requestParameters.zoneFileHash))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the historical zonefile specified by the username and zone hash.
     * Get Historical Zone File
     */
    ;

    _proto.getHistoricalZoneFile = function getHistoricalZoneFile(requestParameters, initOverrides) {
      try {
        var _this20 = this;

        return Promise.resolve(_this20.getHistoricalZoneFileRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves details of a given name including the `address`, `status` and last transaction id - `last_txid`.
     * Get Name Details
     */
    ;

    _proto.getNameInfoRaw = function getNameInfoRaw(requestParameters, initOverrides) {
      try {
        var _this22 = this;

        if (requestParameters.name === null || requestParameters.name === undefined) {
          throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling getNameInfo.');
        }

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this22.request({
          path: "/v1/names/{name}".replace("{" + "name" + "}", encodeURIComponent(String(requestParameters.name))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return BnsGetNameInfoResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves details of a given name including the `address`, `status` and last transaction id - `last_txid`.
     * Get Name Details
     */
    ;

    _proto.getNameInfo = function getNameInfo(requestParameters, initOverrides) {
      try {
        var _this24 = this;

        return Promise.resolve(_this24.getNameInfoRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the price of a name. The `amount` given will be in the smallest possible units of the currency.
     * Get Name Price
     */
    ;

    _proto.getNamePriceRaw = function getNamePriceRaw(requestParameters, initOverrides) {
      try {
        var _this26 = this;

        if (requestParameters.name === null || requestParameters.name === undefined) {
          throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling getNamePrice.');
        }

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this26.request({
          path: "/v2/prices/names/{name}".replace("{" + "name" + "}", encodeURIComponent(String(requestParameters.name))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return BnsGetNamePriceResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the price of a name. The `amount` given will be in the smallest possible units of the currency.
     * Get Name Price
     */
    ;

    _proto.getNamePrice = function getNamePrice(requestParameters, initOverrides) {
      try {
        var _this28 = this;

        return Promise.resolve(_this28.getNamePriceRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of names owned by the address provided.
     * Get Names Owned by Address
     */
    ;

    _proto.getNamesOwnedByAddressRaw = function getNamesOwnedByAddressRaw(requestParameters, initOverrides) {
      try {
        var _this30 = this;

        if (requestParameters.blockchain === null || requestParameters.blockchain === undefined) {
          throw new RequiredError('blockchain', 'Required parameter requestParameters.blockchain was null or undefined when calling getNamesOwnedByAddress.');
        }

        if (requestParameters.address === null || requestParameters.address === undefined) {
          throw new RequiredError('address', 'Required parameter requestParameters.address was null or undefined when calling getNamesOwnedByAddress.');
        }

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this30.request({
          path: "/v1/addresses/{blockchain}/{address}".replace("{" + "blockchain" + "}", encodeURIComponent(String(requestParameters.blockchain))).replace("{" + "address" + "}", encodeURIComponent(String(requestParameters.address))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return BnsNamesOwnByAddressResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of names owned by the address provided.
     * Get Names Owned by Address
     */
    ;

    _proto.getNamesOwnedByAddress = function getNamesOwnedByAddress(requestParameters, initOverrides) {
      try {
        var _this32 = this;

        return Promise.resolve(_this32.getNamesOwnedByAddressRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of names within a given namespace.
     * Get Namespace Names
     */
    ;

    _proto.getNamespaceNamesRaw = function getNamespaceNamesRaw(requestParameters, initOverrides) {
      try {
        var _this34 = this;

        if (requestParameters.tld === null || requestParameters.tld === undefined) {
          throw new RequiredError('tld', 'Required parameter requestParameters.tld was null or undefined when calling getNamespaceNames.');
        }

        var queryParameters = {};

        if (requestParameters.page !== undefined) {
          queryParameters['page'] = requestParameters.page;
        }

        var headerParameters = {};
        return Promise.resolve(_this34.request({
          path: "/v1/namespaces/{tld}/names".replace("{" + "tld" + "}", encodeURIComponent(String(requestParameters.tld))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of names within a given namespace.
     * Get Namespace Names
     */
    ;

    _proto.getNamespaceNames = function getNamespaceNames(requestParameters, initOverrides) {
      try {
        var _this36 = this;

        return Promise.resolve(_this36.getNamespaceNamesRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the price of a namespace. The `amount` given will be in the smallest possible units of the currency.
     * Get Namespace Price
     */
    ;

    _proto.getNamespacePriceRaw = function getNamespacePriceRaw(requestParameters, initOverrides) {
      try {
        var _this38 = this;

        if (requestParameters.tld === null || requestParameters.tld === undefined) {
          throw new RequiredError('tld', 'Required parameter requestParameters.tld was null or undefined when calling getNamespacePrice.');
        }

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this38.request({
          path: "/v2/prices/namespaces/{tld}".replace("{" + "tld" + "}", encodeURIComponent(String(requestParameters.tld))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return BnsGetNamespacePriceResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the price of a namespace. The `amount` given will be in the smallest possible units of the currency.
     * Get Namespace Price
     */
    ;

    _proto.getNamespacePrice = function getNamespacePrice(requestParameters, initOverrides) {
      try {
        var _this40 = this;

        return Promise.resolve(_this40.getNamespacePriceRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    return NamesApi;
  }(BaseAPI);

  /**
   *
   */

  var NonFungibleTokensApi = /*#__PURE__*/function (_runtime$BaseAPI) {
    _inheritsLoose(NonFungibleTokensApi, _runtime$BaseAPI);

    function NonFungibleTokensApi() {
      return _runtime$BaseAPI.apply(this, arguments) || this;
    }

    var _proto = NonFungibleTokensApi.prototype;

    /**
     * Retrieves metadata for non fungible tokens for a given contract id. More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non fungible tokens metadata for contract ID
     */
    _proto.getContractNftMetadataRaw = function getContractNftMetadataRaw(requestParameters, initOverrides) {
      try {
        var _this2 = this;

        if (requestParameters.contractId === null || requestParameters.contractId === undefined) {
          throw new RequiredError('contractId', 'Required parameter requestParameters.contractId was null or undefined when calling getContractNftMetadata.');
        }

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this2.request({
          path: "/extended/v1/tokens/{contractId}/nft/metadata".replace("{" + "contractId" + "}", encodeURIComponent(String(requestParameters.contractId))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return NonFungibleTokenMetadataFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves metadata for non fungible tokens for a given contract id. More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non fungible tokens metadata for contract ID
     */
    ;

    _proto.getContractNftMetadata = function getContractNftMetadata(requestParameters, initOverrides) {
      try {
        var _this4 = this;

        return Promise.resolve(_this4.getContractNftMetadataRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves all events relevant to a Non-Fungible Token. Useful to determine the ownership history of a particular asset.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non-Fungible Token history
     */
    ;

    _proto.getNftHistoryRaw = function getNftHistoryRaw(requestParameters, initOverrides) {
      try {
        var _this6 = this;

        if (requestParameters.assetIdentifier === null || requestParameters.assetIdentifier === undefined) {
          throw new RequiredError('assetIdentifier', 'Required parameter requestParameters.assetIdentifier was null or undefined when calling getNftHistory.');
        }

        if (requestParameters.value === null || requestParameters.value === undefined) {
          throw new RequiredError('value', 'Required parameter requestParameters.value was null or undefined when calling getNftHistory.');
        }

        var queryParameters = {};

        if (requestParameters.assetIdentifier !== undefined) {
          queryParameters['asset_identifier'] = requestParameters.assetIdentifier;
        }

        if (requestParameters.value !== undefined) {
          queryParameters['value'] = requestParameters.value;
        }

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.unanchored !== undefined) {
          queryParameters['unanchored'] = requestParameters.unanchored;
        }

        if (requestParameters.txMetadata !== undefined) {
          queryParameters['tx_metadata'] = requestParameters.txMetadata;
        }

        var headerParameters = {};
        return Promise.resolve(_this6.request({
          path: "/extended/v1/tokens/nft/history",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return NonFungibleTokenHistoryEventListFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves all events relevant to a Non-Fungible Token. Useful to determine the ownership history of a particular asset.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non-Fungible Token history
     */
    ;

    _proto.getNftHistory = function getNftHistory(requestParameters, initOverrides) {
      try {
        var _this8 = this;

        return Promise.resolve(_this8.getNftHistoryRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the list of Non-Fungible Tokens owned by the given principal (STX address or Smart Contract ID). Results can be filtered by one or more asset identifiers and can include metadata about the transaction that made the principal own each token.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non-Fungible Token holdings
     */
    ;

    _proto.getNftHoldingsRaw = function getNftHoldingsRaw(requestParameters, initOverrides) {
      try {
        var _this10 = this;

        if (requestParameters.principal === null || requestParameters.principal === undefined) {
          throw new RequiredError('principal', 'Required parameter requestParameters.principal was null or undefined when calling getNftHoldings.');
        }

        var queryParameters = {};

        if (requestParameters.principal !== undefined) {
          queryParameters['principal'] = requestParameters.principal;
        }

        if (requestParameters.assetIdentifiers) {
          queryParameters['asset_identifiers'] = requestParameters.assetIdentifiers;
        }

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.unanchored !== undefined) {
          queryParameters['unanchored'] = requestParameters.unanchored;
        }

        if (requestParameters.txMetadata !== undefined) {
          queryParameters['tx_metadata'] = requestParameters.txMetadata;
        }

        var headerParameters = {};
        return Promise.resolve(_this10.request({
          path: "/extended/v1/tokens/nft/holdings",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return NonFungibleTokenHoldingsListFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the list of Non-Fungible Tokens owned by the given principal (STX address or Smart Contract ID). Results can be filtered by one or more asset identifiers and can include metadata about the transaction that made the principal own each token.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non-Fungible Token holdings
     */
    ;

    _proto.getNftHoldings = function getNftHoldings(requestParameters, initOverrides) {
      try {
        var _this12 = this;

        return Promise.resolve(_this12.getNftHoldingsRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of non fungible tokens with their metadata. More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non fungible tokens metadata list
     */
    ;

    _proto.getNftMetadataListRaw = function getNftMetadataListRaw(requestParameters, initOverrides) {
      try {
        var _this14 = this;

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        var headerParameters = {};
        return Promise.resolve(_this14.request({
          path: "/extended/v1/tokens/nft/metadata",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return NonFungibleTokensMetadataListFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of non fungible tokens with their metadata. More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non fungible tokens metadata list
     */
    ;

    _proto.getNftMetadataList = function getNftMetadataList(requestParameters, initOverrides) {
      try {
        var _this16 = this;

        return Promise.resolve(_this16.getNftMetadataListRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves all mint events for a Non-Fungible Token asset class. Useful to determine which NFTs of a particular collection have been claimed.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non-Fungible Token mints
     */
    ;

    _proto.getNftMintsRaw = function getNftMintsRaw(requestParameters, initOverrides) {
      try {
        var _this18 = this;

        if (requestParameters.assetIdentifier === null || requestParameters.assetIdentifier === undefined) {
          throw new RequiredError('assetIdentifier', 'Required parameter requestParameters.assetIdentifier was null or undefined when calling getNftMints.');
        }

        var queryParameters = {};

        if (requestParameters.assetIdentifier !== undefined) {
          queryParameters['asset_identifier'] = requestParameters.assetIdentifier;
        }

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.unanchored !== undefined) {
          queryParameters['unanchored'] = requestParameters.unanchored;
        }

        if (requestParameters.txMetadata !== undefined) {
          queryParameters['tx_metadata'] = requestParameters.txMetadata;
        }

        var headerParameters = {};
        return Promise.resolve(_this18.request({
          path: "/extended/v1/tokens/nft/mints",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return NonFungibleTokenMintListFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves all mint events for a Non-Fungible Token asset class. Useful to determine which NFTs of a particular collection have been claimed.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non-Fungible Token mints
     */
    ;

    _proto.getNftMints = function getNftMints(requestParameters, initOverrides) {
      try {
        var _this20 = this;

        return Promise.resolve(_this20.getNftMintsRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    return NonFungibleTokensApi;
  }(BaseAPI);

  /**
   *
   */

  var RosettaApi = /*#__PURE__*/function (_runtime$BaseAPI) {
    _inheritsLoose(RosettaApi, _runtime$BaseAPI);

    function RosettaApi() {
      return _runtime$BaseAPI.apply(this, arguments) || this;
    }

    var _proto = RosettaApi.prototype;

    /**
     * An AccountBalanceRequest is utilized to make a balance request on the /account/balance endpoint. If the block_identifier is populated, a historical balance query should be performed.
     * Get an Account Balance
     */
    _proto.rosettaAccountBalanceRaw = function rosettaAccountBalanceRaw(requestParameters, initOverrides) {
      try {
        var _this2 = this;

        if (requestParameters.rosettaAccountBalanceRequest === null || requestParameters.rosettaAccountBalanceRequest === undefined) {
          throw new RequiredError('rosettaAccountBalanceRequest', 'Required parameter requestParameters.rosettaAccountBalanceRequest was null or undefined when calling rosettaAccountBalance.');
        }

        var queryParameters = {};
        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this2.request({
          path: "/rosetta/v1/account/balance",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: RosettaAccountBalanceRequestToJSON(requestParameters.rosettaAccountBalanceRequest)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return RosettaAccountBalanceResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * An AccountBalanceRequest is utilized to make a balance request on the /account/balance endpoint. If the block_identifier is populated, a historical balance query should be performed.
     * Get an Account Balance
     */
    ;

    _proto.rosettaAccountBalance = function rosettaAccountBalance(requestParameters, initOverrides) {
      try {
        var _this4 = this;

        return Promise.resolve(_this4.rosettaAccountBalanceRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the Block information for a given block identifier including a list of all transactions in the block.
     * Get a Block
     */
    ;

    _proto.rosettaBlockRaw = function rosettaBlockRaw(requestParameters, initOverrides) {
      try {
        var _this6 = this;

        if (requestParameters.rosettaBlockRequest === null || requestParameters.rosettaBlockRequest === undefined) {
          throw new RequiredError('rosettaBlockRequest', 'Required parameter requestParameters.rosettaBlockRequest was null or undefined when calling rosettaBlock.');
        }

        var queryParameters = {};
        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this6.request({
          path: "/rosetta/v1/block",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: RosettaBlockRequestToJSON(requestParameters.rosettaBlockRequest)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return RosettaBlockResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the Block information for a given block identifier including a list of all transactions in the block.
     * Get a Block
     */
    ;

    _proto.rosettaBlock = function rosettaBlock(requestParameters, initOverrides) {
      try {
        var _this8 = this;

        return Promise.resolve(_this8.rosettaBlockRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a Transaction included in a block that is not returned in a BlockResponse.
     * Get a Block Transaction
     */
    ;

    _proto.rosettaBlockTransactionRaw = function rosettaBlockTransactionRaw(requestParameters, initOverrides) {
      try {
        var _this10 = this;

        if (requestParameters.rosettaBlockTransactionRequest === null || requestParameters.rosettaBlockTransactionRequest === undefined) {
          throw new RequiredError('rosettaBlockTransactionRequest', 'Required parameter requestParameters.rosettaBlockTransactionRequest was null or undefined when calling rosettaBlockTransaction.');
        }

        var queryParameters = {};
        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this10.request({
          path: "/rosetta/v1/block/transaction",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: RosettaBlockTransactionRequestToJSON(requestParameters.rosettaBlockTransactionRequest)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return RosettaBlockTransactionResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a Transaction included in a block that is not returned in a BlockResponse.
     * Get a Block Transaction
     */
    ;

    _proto.rosettaBlockTransaction = function rosettaBlockTransaction(requestParameters, initOverrides) {
      try {
        var _this12 = this;

        return Promise.resolve(_this12.rosettaBlockTransactionRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Take unsigned transaction and signature, combine both and return signed transaction. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Create Network Transaction from Signatures
     */
    ;

    _proto.rosettaConstructionCombineRaw = function rosettaConstructionCombineRaw(requestParameters, initOverrides) {
      try {
        var _this14 = this;

        if (requestParameters.rosettaConstructionCombineRequest === null || requestParameters.rosettaConstructionCombineRequest === undefined) {
          throw new RequiredError('rosettaConstructionCombineRequest', 'Required parameter requestParameters.rosettaConstructionCombineRequest was null or undefined when calling rosettaConstructionCombine.');
        }

        var queryParameters = {};
        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this14.request({
          path: "/rosetta/v1/construction/combine",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: RosettaConstructionCombineRequestToJSON(requestParameters.rosettaConstructionCombineRequest)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return RosettaConstructionCombineResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Take unsigned transaction and signature, combine both and return signed transaction. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Create Network Transaction from Signatures
     */
    ;

    _proto.rosettaConstructionCombine = function rosettaConstructionCombine(requestParameters, initOverrides) {
      try {
        var _this16 = this;

        return Promise.resolve(_this16.rosettaConstructionCombineRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the Account Identifier information based on a Public Key for a given network
     * Derive an AccountIdentifier from a PublicKey
     */
    ;

    _proto.rosettaConstructionDeriveRaw = function rosettaConstructionDeriveRaw(requestParameters, initOverrides) {
      try {
        var _this18 = this;

        if (requestParameters.rosettaConstructionDeriveRequest === null || requestParameters.rosettaConstructionDeriveRequest === undefined) {
          throw new RequiredError('rosettaConstructionDeriveRequest', 'Required parameter requestParameters.rosettaConstructionDeriveRequest was null or undefined when calling rosettaConstructionDerive.');
        }

        var queryParameters = {};
        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this18.request({
          path: "/rosetta/v1/construction/derive",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: RosettaConstructionDeriveRequestToJSON(requestParameters.rosettaConstructionDeriveRequest)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return RosettaConstructionDeriveResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the Account Identifier information based on a Public Key for a given network
     * Derive an AccountIdentifier from a PublicKey
     */
    ;

    _proto.rosettaConstructionDerive = function rosettaConstructionDerive(requestParameters, initOverrides) {
      try {
        var _this20 = this;

        return Promise.resolve(_this20.rosettaConstructionDeriveRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the network-specific transaction hash for a signed transaction.
     * Get the Hash of a Signed Transaction
     */
    ;

    _proto.rosettaConstructionHashRaw = function rosettaConstructionHashRaw(requestParameters, initOverrides) {
      try {
        var _this22 = this;

        if (requestParameters.rosettaConstructionHashRequest === null || requestParameters.rosettaConstructionHashRequest === undefined) {
          throw new RequiredError('rosettaConstructionHashRequest', 'Required parameter requestParameters.rosettaConstructionHashRequest was null or undefined when calling rosettaConstructionHash.');
        }

        var queryParameters = {};
        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this22.request({
          path: "/rosetta/v1/construction/hash",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: RosettaConstructionHashRequestToJSON(requestParameters.rosettaConstructionHashRequest)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return RosettaConstructionHashResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the network-specific transaction hash for a signed transaction.
     * Get the Hash of a Signed Transaction
     */
    ;

    _proto.rosettaConstructionHash = function rosettaConstructionHash(requestParameters, initOverrides) {
      try {
        var _this24 = this;

        return Promise.resolve(_this24.rosettaConstructionHashRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * To Do
     * Get Metadata for Transaction Construction
     */
    ;

    _proto.rosettaConstructionMetadataRaw = function rosettaConstructionMetadataRaw(requestParameters, initOverrides) {
      try {
        var _this26 = this;

        if (requestParameters.rosettaConstructionMetadataRequest === null || requestParameters.rosettaConstructionMetadataRequest === undefined) {
          throw new RequiredError('rosettaConstructionMetadataRequest', 'Required parameter requestParameters.rosettaConstructionMetadataRequest was null or undefined when calling rosettaConstructionMetadata.');
        }

        var queryParameters = {};
        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this26.request({
          path: "/rosetta/v1/construction/metadata",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: RosettaConstructionMetadataRequestToJSON(requestParameters.rosettaConstructionMetadataRequest)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return RosettaConstructionMetadataResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * To Do
     * Get Metadata for Transaction Construction
     */
    ;

    _proto.rosettaConstructionMetadata = function rosettaConstructionMetadata(requestParameters, initOverrides) {
      try {
        var _this28 = this;

        return Promise.resolve(_this28.rosettaConstructionMetadataRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * TODO
     * Parse a Transaction
     */
    ;

    _proto.rosettaConstructionParseRaw = function rosettaConstructionParseRaw(requestParameters, initOverrides) {
      try {
        var _this30 = this;

        if (requestParameters.rosettaConstructionParseRequest === null || requestParameters.rosettaConstructionParseRequest === undefined) {
          throw new RequiredError('rosettaConstructionParseRequest', 'Required parameter requestParameters.rosettaConstructionParseRequest was null or undefined when calling rosettaConstructionParse.');
        }

        var queryParameters = {};
        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this30.request({
          path: "/rosetta/v1/construction/parse",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: RosettaConstructionParseRequestToJSON(requestParameters.rosettaConstructionParseRequest)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return RosettaConstructionParseResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * TODO
     * Parse a Transaction
     */
    ;

    _proto.rosettaConstructionParse = function rosettaConstructionParse(requestParameters, initOverrides) {
      try {
        var _this32 = this;

        return Promise.resolve(_this32.rosettaConstructionParseRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Generate an unsigned transaction from operations and metadata. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Generate an Unsigned Transaction and Signing Payloads
     */
    ;

    _proto.rosettaConstructionPayloadsRaw = function rosettaConstructionPayloadsRaw(requestParameters, initOverrides) {
      try {
        var _this34 = this;

        if (requestParameters.rosettaConstructionPayloadsRequest === null || requestParameters.rosettaConstructionPayloadsRequest === undefined) {
          throw new RequiredError('rosettaConstructionPayloadsRequest', 'Required parameter requestParameters.rosettaConstructionPayloadsRequest was null or undefined when calling rosettaConstructionPayloads.');
        }

        var queryParameters = {};
        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this34.request({
          path: "/rosetta/v1/construction/payloads",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: RosettaConstructionPayloadsRequestToJSON(requestParameters.rosettaConstructionPayloadsRequest)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return RosettaConstructionPayloadResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Generate an unsigned transaction from operations and metadata. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Generate an Unsigned Transaction and Signing Payloads
     */
    ;

    _proto.rosettaConstructionPayloads = function rosettaConstructionPayloads(requestParameters, initOverrides) {
      try {
        var _this36 = this;

        return Promise.resolve(_this36.rosettaConstructionPayloadsRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * TODO
     * Create a Request to Fetch Metadata
     */
    ;

    _proto.rosettaConstructionPreprocessRaw = function rosettaConstructionPreprocessRaw(requestParameters, initOverrides) {
      try {
        var _this38 = this;

        if (requestParameters.rosettaConstructionPreprocessRequest === null || requestParameters.rosettaConstructionPreprocessRequest === undefined) {
          throw new RequiredError('rosettaConstructionPreprocessRequest', 'Required parameter requestParameters.rosettaConstructionPreprocessRequest was null or undefined when calling rosettaConstructionPreprocess.');
        }

        var queryParameters = {};
        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this38.request({
          path: "/rosetta/v1/construction/preprocess",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: RosettaConstructionPreprocessRequestToJSON(requestParameters.rosettaConstructionPreprocessRequest)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return RosettaConstructionPreprocessResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * TODO
     * Create a Request to Fetch Metadata
     */
    ;

    _proto.rosettaConstructionPreprocess = function rosettaConstructionPreprocess(requestParameters, initOverrides) {
      try {
        var _this40 = this;

        return Promise.resolve(_this40.rosettaConstructionPreprocessRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Submit a pre-signed transaction to the node. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Submit a Signed Transaction
     */
    ;

    _proto.rosettaConstructionSubmitRaw = function rosettaConstructionSubmitRaw(requestParameters, initOverrides) {
      try {
        var _this42 = this;

        if (requestParameters.rosettaConstructionSubmitRequest === null || requestParameters.rosettaConstructionSubmitRequest === undefined) {
          throw new RequiredError('rosettaConstructionSubmitRequest', 'Required parameter requestParameters.rosettaConstructionSubmitRequest was null or undefined when calling rosettaConstructionSubmit.');
        }

        var queryParameters = {};
        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this42.request({
          path: "/rosetta/v1/construction/submit",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: RosettaConstructionSubmitRequestToJSON(requestParameters.rosettaConstructionSubmitRequest)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return RosettaConstructionSubmitResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Submit a pre-signed transaction to the node. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Submit a Signed Transaction
     */
    ;

    _proto.rosettaConstructionSubmit = function rosettaConstructionSubmit(requestParameters, initOverrides) {
      try {
        var _this44 = this;

        return Promise.resolve(_this44.rosettaConstructionSubmitRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of transactions currently in the mempool for a given network.
     * Get All Mempool Transactions
     */
    ;

    _proto.rosettaMempoolRaw = function rosettaMempoolRaw(requestParameters, initOverrides) {
      try {
        var _this46 = this;

        if (requestParameters.rosettaMempoolRequest === null || requestParameters.rosettaMempoolRequest === undefined) {
          throw new RequiredError('rosettaMempoolRequest', 'Required parameter requestParameters.rosettaMempoolRequest was null or undefined when calling rosettaMempool.');
        }

        var queryParameters = {};
        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this46.request({
          path: "/rosetta/v1/mempool",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: RosettaMempoolRequestToJSON(requestParameters.rosettaMempoolRequest)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return RosettaMempoolResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of transactions currently in the mempool for a given network.
     * Get All Mempool Transactions
     */
    ;

    _proto.rosettaMempool = function rosettaMempool(requestParameters, initOverrides) {
      try {
        var _this48 = this;

        return Promise.resolve(_this48.rosettaMempoolRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves transaction details from the mempool for a given transaction id from a given network.
     * Get a Mempool Transaction
     */
    ;

    _proto.rosettaMempoolTransactionRaw = function rosettaMempoolTransactionRaw(requestParameters, initOverrides) {
      try {
        var _this50 = this;

        if (requestParameters.rosettaMempoolTransactionRequest === null || requestParameters.rosettaMempoolTransactionRequest === undefined) {
          throw new RequiredError('rosettaMempoolTransactionRequest', 'Required parameter requestParameters.rosettaMempoolTransactionRequest was null or undefined when calling rosettaMempoolTransaction.');
        }

        var queryParameters = {};
        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this50.request({
          path: "/rosetta/v1/mempool/transaction",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: RosettaMempoolTransactionRequestToJSON(requestParameters.rosettaMempoolTransactionRequest)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return RosettaMempoolTransactionResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves transaction details from the mempool for a given transaction id from a given network.
     * Get a Mempool Transaction
     */
    ;

    _proto.rosettaMempoolTransaction = function rosettaMempoolTransaction(requestParameters, initOverrides) {
      try {
        var _this52 = this;

        return Promise.resolve(_this52.rosettaMempoolTransactionRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of NetworkIdentifiers that the Rosetta server supports.
     * Get List of Available Networks
     */
    ;

    _proto.rosettaNetworkListRaw = function rosettaNetworkListRaw(initOverrides) {
      try {
        var _this54 = this;

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this54.request({
          path: "/rosetta/v1/network/list",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return RosettaNetworkListResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of NetworkIdentifiers that the Rosetta server supports.
     * Get List of Available Networks
     */
    ;

    _proto.rosettaNetworkList = function rosettaNetworkList(initOverrides) {
      try {
        var _this56 = this;

        return Promise.resolve(_this56.rosettaNetworkListRaw(initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the version information and allowed network-specific types for a NetworkIdentifier. Any NetworkIdentifier returned by /network/list should be accessible here. Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network.
     * Get Network Options
     */
    ;

    _proto.rosettaNetworkOptionsRaw = function rosettaNetworkOptionsRaw(requestParameters, initOverrides) {
      try {
        var _this58 = this;

        if (requestParameters.rosettaOptionsRequest === null || requestParameters.rosettaOptionsRequest === undefined) {
          throw new RequiredError('rosettaOptionsRequest', 'Required parameter requestParameters.rosettaOptionsRequest was null or undefined when calling rosettaNetworkOptions.');
        }

        var queryParameters = {};
        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this58.request({
          path: "/rosetta/v1/network/options",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: RosettaOptionsRequestToJSON(requestParameters.rosettaOptionsRequest)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return RosettaNetworkOptionsResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the version information and allowed network-specific types for a NetworkIdentifier. Any NetworkIdentifier returned by /network/list should be accessible here. Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network.
     * Get Network Options
     */
    ;

    _proto.rosettaNetworkOptions = function rosettaNetworkOptions(requestParameters, initOverrides) {
      try {
        var _this60 = this;

        return Promise.resolve(_this60.rosettaNetworkOptionsRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the current status of the network requested. Any NetworkIdentifier returned by /network/list should be accessible here.
     * Get Network Status
     */
    ;

    _proto.rosettaNetworkStatusRaw = function rosettaNetworkStatusRaw(requestParameters, initOverrides) {
      try {
        var _this62 = this;

        if (requestParameters.rosettaStatusRequest === null || requestParameters.rosettaStatusRequest === undefined) {
          throw new RequiredError('rosettaStatusRequest', 'Required parameter requestParameters.rosettaStatusRequest was null or undefined when calling rosettaNetworkStatus.');
        }

        var queryParameters = {};
        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this62.request({
          path: "/rosetta/v1/network/status",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: RosettaStatusRequestToJSON(requestParameters.rosettaStatusRequest)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return RosettaNetworkStatusResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the current status of the network requested. Any NetworkIdentifier returned by /network/list should be accessible here.
     * Get Network Status
     */
    ;

    _proto.rosettaNetworkStatus = function rosettaNetworkStatus(requestParameters, initOverrides) {
      try {
        var _this64 = this;

        return Promise.resolve(_this64.rosettaNetworkStatusRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    return RosettaApi;
  }(BaseAPI);

  /**
   *
   */

  var SearchApi = /*#__PURE__*/function (_runtime$BaseAPI) {
    _inheritsLoose(SearchApi, _runtime$BaseAPI);

    function SearchApi() {
      return _runtime$BaseAPI.apply(this, arguments) || this;
    }

    var _proto = SearchApi.prototype;

    /**
     * Search blocks, transactions, contracts, or accounts by hash/ID
     * Search
     */
    _proto.searchByIdRaw = function searchByIdRaw(requestParameters, initOverrides) {
      try {
        var _this2 = this;

        if (requestParameters.id === null || requestParameters.id === undefined) {
          throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling searchById.');
        }

        var queryParameters = {};

        if (requestParameters.includeMetadata !== undefined) {
          queryParameters['include_metadata'] = requestParameters.includeMetadata;
        }

        var headerParameters = {};
        return Promise.resolve(_this2.request({
          path: "/extended/v1/search/{id}".replace("{" + "id" + "}", encodeURIComponent(String(requestParameters.id))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Search blocks, transactions, contracts, or accounts by hash/ID
     * Search
     */
    ;

    _proto.searchById = function searchById(requestParameters, initOverrides) {
      try {
        var _this4 = this;

        return Promise.resolve(_this4.searchByIdRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    return SearchApi;
  }(BaseAPI);

  /**
   *
   */

  var SmartContractsApi = /*#__PURE__*/function (_runtime$BaseAPI) {
    _inheritsLoose(SmartContractsApi, _runtime$BaseAPI);

    function SmartContractsApi() {
      return _runtime$BaseAPI.apply(this, arguments) || this;
    }

    var _proto = SmartContractsApi.prototype;

    /**
     * Call a read-only public function on a given smart contract.  The smart contract and function are specified using the URL path. The arguments and the simulated tx-sender are supplied via the POST body in the following JSON format:
     * Call read-only function
     */
    _proto.callReadOnlyFunctionRaw = function callReadOnlyFunctionRaw(requestParameters, initOverrides) {
      try {
        var _this2 = this;

        if (requestParameters.contractAddress === null || requestParameters.contractAddress === undefined) {
          throw new RequiredError('contractAddress', 'Required parameter requestParameters.contractAddress was null or undefined when calling callReadOnlyFunction.');
        }

        if (requestParameters.contractName === null || requestParameters.contractName === undefined) {
          throw new RequiredError('contractName', 'Required parameter requestParameters.contractName was null or undefined when calling callReadOnlyFunction.');
        }

        if (requestParameters.functionName === null || requestParameters.functionName === undefined) {
          throw new RequiredError('functionName', 'Required parameter requestParameters.functionName was null or undefined when calling callReadOnlyFunction.');
        }

        if (requestParameters.readOnlyFunctionArgs === null || requestParameters.readOnlyFunctionArgs === undefined) {
          throw new RequiredError('readOnlyFunctionArgs', 'Required parameter requestParameters.readOnlyFunctionArgs was null or undefined when calling callReadOnlyFunction.');
        }

        var queryParameters = {};

        if (requestParameters.tip !== undefined) {
          queryParameters['tip'] = requestParameters.tip;
        }

        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this2.request({
          path: "/v2/contracts/call-read/{contract_address}/{contract_name}/{function_name}".replace("{" + "contract_address" + "}", encodeURIComponent(String(requestParameters.contractAddress))).replace("{" + "contract_name" + "}", encodeURIComponent(String(requestParameters.contractName))).replace("{" + "function_name" + "}", encodeURIComponent(String(requestParameters.functionName))),
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: ReadOnlyFunctionArgsToJSON(requestParameters.readOnlyFunctionArgs)
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return ReadOnlyFunctionSuccessResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Call a read-only public function on a given smart contract.  The smart contract and function are specified using the URL path. The arguments and the simulated tx-sender are supplied via the POST body in the following JSON format:
     * Call read-only function
     */
    ;

    _proto.callReadOnlyFunction = function callReadOnlyFunction(requestParameters, initOverrides) {
      try {
        var _this4 = this;

        return Promise.resolve(_this4.callReadOnlyFunctionRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves details of a contract with a given `contract_id`
     * Get contract info
     */
    ;

    _proto.getContractByIdRaw = function getContractByIdRaw(requestParameters, initOverrides) {
      try {
        var _this6 = this;

        if (requestParameters.contractId === null || requestParameters.contractId === undefined) {
          throw new RequiredError('contractId', 'Required parameter requestParameters.contractId was null or undefined when calling getContractById.');
        }

        var queryParameters = {};

        if (requestParameters.unanchored !== undefined) {
          queryParameters['unanchored'] = requestParameters.unanchored;
        }

        var headerParameters = {};
        return Promise.resolve(_this6.request({
          path: "/extended/v1/contract/{contract_id}".replace("{" + "contract_id" + "}", encodeURIComponent(String(requestParameters.contractId))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return SmartContractFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves details of a contract with a given `contract_id`
     * Get contract info
     */
    ;

    _proto.getContractById = function getContractById(requestParameters, initOverrides) {
      try {
        var _this8 = this;

        return Promise.resolve(_this8.getContractByIdRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Attempt to fetch data from a contract data map. The contract is identified with Stacks Address `contract_address` and Contract Name `contract_address` in the URL path. The map is identified with [Map Name].  The key to lookup in the map is supplied via the POST body. This should be supplied as the hex string serialization of the key (which should be a Clarity value). Note, this is a JSON string atom.  In the response, `data` is the hex serialization of the map response. Note that map responses are Clarity option types, for non-existent values, this is a serialized none, and for all other responses, it is a serialized (some ...) object.
     * Get specific data-map inside a contract
     */
    ;

    _proto.getContractDataMapEntryRaw = function getContractDataMapEntryRaw(requestParameters, initOverrides) {
      try {
        var _this10 = this;

        if (requestParameters.contractAddress === null || requestParameters.contractAddress === undefined) {
          throw new RequiredError('contractAddress', 'Required parameter requestParameters.contractAddress was null or undefined when calling getContractDataMapEntry.');
        }

        if (requestParameters.contractName === null || requestParameters.contractName === undefined) {
          throw new RequiredError('contractName', 'Required parameter requestParameters.contractName was null or undefined when calling getContractDataMapEntry.');
        }

        if (requestParameters.mapName === null || requestParameters.mapName === undefined) {
          throw new RequiredError('mapName', 'Required parameter requestParameters.mapName was null or undefined when calling getContractDataMapEntry.');
        }

        if (requestParameters.key === null || requestParameters.key === undefined) {
          throw new RequiredError('key', 'Required parameter requestParameters.key was null or undefined when calling getContractDataMapEntry.');
        }

        var queryParameters = {};

        if (requestParameters.proof !== undefined) {
          queryParameters['proof'] = requestParameters.proof;
        }

        if (requestParameters.tip !== undefined) {
          queryParameters['tip'] = requestParameters.tip;
        }

        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        return Promise.resolve(_this10.request({
          path: "/v2/map_entry/{contract_address}/{contract_name}/{map_name}".replace("{" + "contract_address" + "}", encodeURIComponent(String(requestParameters.contractAddress))).replace("{" + "contract_name" + "}", encodeURIComponent(String(requestParameters.contractName))).replace("{" + "map_name" + "}", encodeURIComponent(String(requestParameters.mapName))),
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: requestParameters.key
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return MapEntryResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Attempt to fetch data from a contract data map. The contract is identified with Stacks Address `contract_address` and Contract Name `contract_address` in the URL path. The map is identified with [Map Name].  The key to lookup in the map is supplied via the POST body. This should be supplied as the hex string serialization of the key (which should be a Clarity value). Note, this is a JSON string atom.  In the response, `data` is the hex serialization of the map response. Note that map responses are Clarity option types, for non-existent values, this is a serialized none, and for all other responses, it is a serialized (some ...) object.
     * Get specific data-map inside a contract
     */
    ;

    _proto.getContractDataMapEntry = function getContractDataMapEntry(requestParameters, initOverrides) {
      try {
        var _this12 = this;

        return Promise.resolve(_this12.getContractDataMapEntryRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of events that have been triggered by a given `contract_id`
     * Get contract events
     */
    ;

    _proto.getContractEventsByIdRaw = function getContractEventsByIdRaw(requestParameters, initOverrides) {
      try {
        var _this14 = this;

        if (requestParameters.contractId === null || requestParameters.contractId === undefined) {
          throw new RequiredError('contractId', 'Required parameter requestParameters.contractId was null or undefined when calling getContractEventsById.');
        }

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.unanchored !== undefined) {
          queryParameters['unanchored'] = requestParameters.unanchored;
        }

        var headerParameters = {};
        return Promise.resolve(_this14.request({
          path: "/extended/v1/contract/{contract_id}/events".replace("{" + "contract_id" + "}", encodeURIComponent(String(requestParameters.contractId))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of events that have been triggered by a given `contract_id`
     * Get contract events
     */
    ;

    _proto.getContractEventsById = function getContractEventsById(requestParameters, initOverrides) {
      try {
        var _this16 = this;

        return Promise.resolve(_this16.getContractEventsByIdRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a contract interface with a given `contract_address` and `contract name`
     * Get contract interface
     */
    ;

    _proto.getContractInterfaceRaw = function getContractInterfaceRaw(requestParameters, initOverrides) {
      try {
        var _this18 = this;

        if (requestParameters.contractAddress === null || requestParameters.contractAddress === undefined) {
          throw new RequiredError('contractAddress', 'Required parameter requestParameters.contractAddress was null or undefined when calling getContractInterface.');
        }

        if (requestParameters.contractName === null || requestParameters.contractName === undefined) {
          throw new RequiredError('contractName', 'Required parameter requestParameters.contractName was null or undefined when calling getContractInterface.');
        }

        var queryParameters = {};

        if (requestParameters.tip !== undefined) {
          queryParameters['tip'] = requestParameters.tip;
        }

        var headerParameters = {};
        return Promise.resolve(_this18.request({
          path: "/v2/contracts/interface/{contract_address}/{contract_name}".replace("{" + "contract_address" + "}", encodeURIComponent(String(requestParameters.contractAddress))).replace("{" + "contract_name" + "}", encodeURIComponent(String(requestParameters.contractName))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return ContractInterfaceResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a contract interface with a given `contract_address` and `contract name`
     * Get contract interface
     */
    ;

    _proto.getContractInterface = function getContractInterface(requestParameters, initOverrides) {
      try {
        var _this20 = this;

        return Promise.resolve(_this20.getContractInterfaceRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the Clarity source code of a given contract, along with the block height it was published in, and the MARF proof for the data
     * Get contract source
     */
    ;

    _proto.getContractSourceRaw = function getContractSourceRaw(requestParameters, initOverrides) {
      try {
        var _this22 = this;

        if (requestParameters.contractAddress === null || requestParameters.contractAddress === undefined) {
          throw new RequiredError('contractAddress', 'Required parameter requestParameters.contractAddress was null or undefined when calling getContractSource.');
        }

        if (requestParameters.contractName === null || requestParameters.contractName === undefined) {
          throw new RequiredError('contractName', 'Required parameter requestParameters.contractName was null or undefined when calling getContractSource.');
        }

        var queryParameters = {};

        if (requestParameters.proof !== undefined) {
          queryParameters['proof'] = requestParameters.proof;
        }

        if (requestParameters.tip !== undefined) {
          queryParameters['tip'] = requestParameters.tip;
        }

        var headerParameters = {};
        return Promise.resolve(_this22.request({
          path: "/v2/contracts/source/{contract_address}/{contract_name}".replace("{" + "contract_address" + "}", encodeURIComponent(String(requestParameters.contractAddress))).replace("{" + "contract_name" + "}", encodeURIComponent(String(requestParameters.contractName))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return ContractSourceResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the Clarity source code of a given contract, along with the block height it was published in, and the MARF proof for the data
     * Get contract source
     */
    ;

    _proto.getContractSource = function getContractSource(requestParameters, initOverrides) {
      try {
        var _this24 = this;

        return Promise.resolve(_this24.getContractSourceRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of contracts based on the following traits listed in JSON format -  functions, variables, maps, fungible tokens and non-fungible tokens
     * Get contracts by trait
     */
    ;

    _proto.getContractsByTraitRaw = function getContractsByTraitRaw(requestParameters, initOverrides) {
      try {
        var _this26 = this;

        if (requestParameters.traitAbi === null || requestParameters.traitAbi === undefined) {
          throw new RequiredError('traitAbi', 'Required parameter requestParameters.traitAbi was null or undefined when calling getContractsByTrait.');
        }

        var queryParameters = {};

        if (requestParameters.traitAbi !== undefined) {
          queryParameters['trait_abi'] = requestParameters.traitAbi;
        }

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        var headerParameters = {};
        return Promise.resolve(_this26.request({
          path: "/extended/v1/contract/by_trait",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return ContractListResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of contracts based on the following traits listed in JSON format -  functions, variables, maps, fungible tokens and non-fungible tokens
     * Get contracts by trait
     */
    ;

    _proto.getContractsByTrait = function getContractsByTrait(requestParameters, initOverrides) {
      try {
        var _this28 = this;

        return Promise.resolve(_this28.getContractsByTraitRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    return SmartContractsApi;
  }(BaseAPI);

  /**
   *
   */

  var StackingRewardsApi = /*#__PURE__*/function (_runtime$BaseAPI) {
    _inheritsLoose(StackingRewardsApi, _runtime$BaseAPI);

    function StackingRewardsApi() {
      return _runtime$BaseAPI.apply(this, arguments) || this;
    }

    var _proto = StackingRewardsApi.prototype;

    /**
     * Retrieves a list of recent burnchain (e.g. Bitcoin) reward recipients with the associated amounts and block info
     * Get recent burnchain reward recipients
     */
    _proto.getBurnchainRewardListRaw = function getBurnchainRewardListRaw(requestParameters, initOverrides) {
      try {
        var _this2 = this;

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        var headerParameters = {};
        return Promise.resolve(_this2.request({
          path: "/extended/v1/burnchain/rewards",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return BurnchainRewardListResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of recent burnchain (e.g. Bitcoin) reward recipients with the associated amounts and block info
     * Get recent burnchain reward recipients
     */
    ;

    _proto.getBurnchainRewardList = function getBurnchainRewardList(requestParameters, initOverrides) {
      try {
        var _this4 = this;

        return Promise.resolve(_this4.getBurnchainRewardListRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of recent burnchain (e.g. Bitcoin) rewards for the given recipient with the associated amounts and block info
     * Get recent burnchain reward for the given recipient
     */
    ;

    _proto.getBurnchainRewardListByAddressRaw = function getBurnchainRewardListByAddressRaw(requestParameters, initOverrides) {
      try {
        var _this6 = this;

        if (requestParameters.address === null || requestParameters.address === undefined) {
          throw new RequiredError('address', 'Required parameter requestParameters.address was null or undefined when calling getBurnchainRewardListByAddress.');
        }

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        var headerParameters = {};
        return Promise.resolve(_this6.request({
          path: "/extended/v1/burnchain/rewards/{address}".replace("{" + "address" + "}", encodeURIComponent(String(requestParameters.address))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return BurnchainRewardListResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of recent burnchain (e.g. Bitcoin) rewards for the given recipient with the associated amounts and block info
     * Get recent burnchain reward for the given recipient
     */
    ;

    _proto.getBurnchainRewardListByAddress = function getBurnchainRewardListByAddress(requestParameters, initOverrides) {
      try {
        var _this8 = this;

        return Promise.resolve(_this8.getBurnchainRewardListByAddressRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of the Bitcoin addresses that would validly receive Proof-of-Transfer commitments.
     * Get recent reward slot holders
     */
    ;

    _proto.getBurnchainRewardSlotHoldersRaw = function getBurnchainRewardSlotHoldersRaw(requestParameters, initOverrides) {
      try {
        var _this10 = this;

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        var headerParameters = {};
        return Promise.resolve(_this10.request({
          path: "/extended/v1/burnchain/reward_slot_holders",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return BurnchainRewardSlotHolderListResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of the Bitcoin addresses that would validly receive Proof-of-Transfer commitments.
     * Get recent reward slot holders
     */
    ;

    _proto.getBurnchainRewardSlotHolders = function getBurnchainRewardSlotHolders(requestParameters, initOverrides) {
      try {
        var _this12 = this;

        return Promise.resolve(_this12.getBurnchainRewardSlotHoldersRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of the Bitcoin addresses that would validly receive Proof-of-Transfer commitments for a given reward slot holder recipient address.
     * Get recent reward slot holder entries for the given address
     */
    ;

    _proto.getBurnchainRewardSlotHoldersByAddressRaw = function getBurnchainRewardSlotHoldersByAddressRaw(requestParameters, initOverrides) {
      try {
        var _this14 = this;

        if (requestParameters.address === null || requestParameters.address === undefined) {
          throw new RequiredError('address', 'Required parameter requestParameters.address was null or undefined when calling getBurnchainRewardSlotHoldersByAddress.');
        }

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        var headerParameters = {};
        return Promise.resolve(_this14.request({
          path: "/extended/v1/burnchain/reward_slot_holders/{address}".replace("{" + "address" + "}", encodeURIComponent(String(requestParameters.address))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return BurnchainRewardSlotHolderListResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of the Bitcoin addresses that would validly receive Proof-of-Transfer commitments for a given reward slot holder recipient address.
     * Get recent reward slot holder entries for the given address
     */
    ;

    _proto.getBurnchainRewardSlotHoldersByAddress = function getBurnchainRewardSlotHoldersByAddress(requestParameters, initOverrides) {
      try {
        var _this16 = this;

        return Promise.resolve(_this16.getBurnchainRewardSlotHoldersByAddressRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the total burnchain (e.g. Bitcoin) rewards for a given recipient `address`
     * Get total burnchain rewards for the given recipient
     */
    ;

    _proto.getBurnchainRewardsTotalByAddressRaw = function getBurnchainRewardsTotalByAddressRaw(requestParameters, initOverrides) {
      try {
        var _this18 = this;

        if (requestParameters.address === null || requestParameters.address === undefined) {
          throw new RequiredError('address', 'Required parameter requestParameters.address was null or undefined when calling getBurnchainRewardsTotalByAddress.');
        }

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this18.request({
          path: "/extended/v1/burnchain/rewards/{address}/total".replace("{" + "address" + "}", encodeURIComponent(String(requestParameters.address))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return BurnchainRewardsTotalFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the total burnchain (e.g. Bitcoin) rewards for a given recipient `address`
     * Get total burnchain rewards for the given recipient
     */
    ;

    _proto.getBurnchainRewardsTotalByAddress = function getBurnchainRewardsTotalByAddress(requestParameters, initOverrides) {
      try {
        var _this20 = this;

        return Promise.resolve(_this20.getBurnchainRewardsTotalByAddressRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    return StackingRewardsApi;
  }(BaseAPI);

  /**
   *
   */

  var TransactionsApi = /*#__PURE__*/function (_runtime$BaseAPI) {
    _inheritsLoose(TransactionsApi, _runtime$BaseAPI);

    function TransactionsApi() {
      return _runtime$BaseAPI.apply(this, arguments) || this;
    }

    var _proto = TransactionsApi.prototype;

    /**
     * Retrieves all transactions for a given address that are currently in mempool
     * Transactions for address
     */
    _proto.getAddressMempoolTransactionsRaw = function getAddressMempoolTransactionsRaw(requestParameters, initOverrides) {
      try {
        var _this2 = this;

        if (requestParameters.address === null || requestParameters.address === undefined) {
          throw new RequiredError('address', 'Required parameter requestParameters.address was null or undefined when calling getAddressMempoolTransactions.');
        }

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.unanchored !== undefined) {
          queryParameters['unanchored'] = requestParameters.unanchored;
        }

        var headerParameters = {};
        return Promise.resolve(_this2.request({
          path: "/extended/v1/address/{address}/mempool".replace("{" + "address" + "}", encodeURIComponent(String(requestParameters.address))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return MempoolTransactionListResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves all transactions for a given address that are currently in mempool
     * Transactions for address
     */
    ;

    _proto.getAddressMempoolTransactions = function getAddressMempoolTransactions(requestParameters, initOverrides) {
      try {
        var _this4 = this;

        return Promise.resolve(_this4.getAddressMempoolTransactionsRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves all recently-broadcast transactions that have been dropped from the mempool.  Transactions are dropped from the mempool if:  * they were stale and awaiting garbage collection or,  * were expensive,  or  * were replaced with a new fee
     * Get dropped mempool transactions
     */
    ;

    _proto.getDroppedMempoolTransactionListRaw = function getDroppedMempoolTransactionListRaw(requestParameters, initOverrides) {
      try {
        var _this6 = this;

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        var headerParameters = {};
        return Promise.resolve(_this6.request({
          path: "/extended/v1/tx/mempool/dropped",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return MempoolTransactionListResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves all recently-broadcast transactions that have been dropped from the mempool.  Transactions are dropped from the mempool if:  * they were stale and awaiting garbage collection or,  * were expensive,  or  * were replaced with a new fee
     * Get dropped mempool transactions
     */
    ;

    _proto.getDroppedMempoolTransactionList = function getDroppedMempoolTransactionList(requestParameters, initOverrides) {
      try {
        var _this8 = this;

        return Promise.resolve(_this8.getDroppedMempoolTransactionListRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the list of events filtered by principal (STX address or Smart Contract ID), transaction id or event types. The list of event types is (\'smart_contract_log\', \'stx_lock\', \'stx_asset\', \'fungible_token_asset\', \'non_fungible_token_asset\').
     * Transaction Events
     */
    ;

    _proto.getFilteredEventsRaw = function getFilteredEventsRaw(requestParameters, initOverrides) {
      try {
        var _this10 = this;

        var queryParameters = {};

        if (requestParameters.txId !== undefined) {
          queryParameters['tx_id'] = requestParameters.txId;
        }

        if (requestParameters.address !== undefined) {
          queryParameters['address'] = requestParameters.address;
        }

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.type) {
          queryParameters['type'] = requestParameters.type;
        }

        var headerParameters = {};
        return Promise.resolve(_this10.request({
          path: "/extended/v1/tx/events",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return TransactionEventsResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves the list of events filtered by principal (STX address or Smart Contract ID), transaction id or event types. The list of event types is (\'smart_contract_log\', \'stx_lock\', \'stx_asset\', \'fungible_token_asset\', \'non_fungible_token_asset\').
     * Transaction Events
     */
    ;

    _proto.getFilteredEvents = function getFilteredEvents(requestParameters, initOverrides) {
      try {
        var _this12 = this;

        return Promise.resolve(_this12.getFilteredEventsRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves all transactions that have been recently broadcast to the mempool. These are pending transactions awaiting confirmation.  If you need to monitor new transactions, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates.
     * Get mempool transactions
     */
    ;

    _proto.getMempoolTransactionListRaw = function getMempoolTransactionListRaw(requestParameters, initOverrides) {
      try {
        var _this14 = this;

        var queryParameters = {};

        if (requestParameters.senderAddress !== undefined) {
          queryParameters['sender_address'] = requestParameters.senderAddress;
        }

        if (requestParameters.recipientAddress !== undefined) {
          queryParameters['recipient_address'] = requestParameters.recipientAddress;
        }

        if (requestParameters.address !== undefined) {
          queryParameters['address'] = requestParameters.address;
        }

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.unanchored !== undefined) {
          queryParameters['unanchored'] = requestParameters.unanchored;
        }

        var headerParameters = {};
        return Promise.resolve(_this14.request({
          path: "/extended/v1/tx/mempool",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return MempoolTransactionListResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves all transactions that have been recently broadcast to the mempool. These are pending transactions awaiting confirmation.  If you need to monitor new transactions, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates.
     * Get mempool transactions
     */
    ;

    _proto.getMempoolTransactionList = function getMempoolTransactionList(requestParameters, initOverrides) {
      try {
        var _this16 = this;

        return Promise.resolve(_this16.getMempoolTransactionListRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Queries for transactions counts, age (by block height), fees (simple average), and size. All results broken down by transaction type and percentiles (p25, p50, p75, p95).
     * Get statistics for mempool transactions
     */
    ;

    _proto.getMempoolTransactionStatsRaw = function getMempoolTransactionStatsRaw(initOverrides) {
      try {
        var _this18 = this;

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this18.request({
          path: "/extended/v1/tx/mempool/stats",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return MempoolTransactionStatsResponseFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Queries for transactions counts, age (by block height), fees (simple average), and size. All results broken down by transaction type and percentiles (p25, p50, p75, p95).
     * Get statistics for mempool transactions
     */
    ;

    _proto.getMempoolTransactionStats = function getMempoolTransactionStats(initOverrides) {
      try {
        var _this20 = this;

        return Promise.resolve(_this20.getMempoolTransactionStatsRaw(initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a hex encoded serialized transaction for a given ID
     * Get Raw Transaction
     */
    ;

    _proto.getRawTransactionByIdRaw = function getRawTransactionByIdRaw(requestParameters, initOverrides) {
      try {
        var _this22 = this;

        if (requestParameters.txId === null || requestParameters.txId === undefined) {
          throw new RequiredError('txId', 'Required parameter requestParameters.txId was null or undefined when calling getRawTransactionById.');
        }

        var queryParameters = {};
        var headerParameters = {};
        return Promise.resolve(_this22.request({
          path: "/extended/v1/tx/{tx_id}/raw".replace("{" + "tx_id" + "}", encodeURIComponent(String(requestParameters.txId))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return GetRawTransactionResultFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a hex encoded serialized transaction for a given ID
     * Get Raw Transaction
     */
    ;

    _proto.getRawTransactionById = function getRawTransactionById(requestParameters, initOverrides) {
      try {
        var _this24 = this;

        return Promise.resolve(_this24.getRawTransactionByIdRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves transaction details for a given transaction ID  `import type { Transaction } from \'@stacks/stacks-blockchain-api-types\';`
     * Get transaction
     */
    ;

    _proto.getTransactionByIdRaw = function getTransactionByIdRaw(requestParameters, initOverrides) {
      try {
        var _this26 = this;

        if (requestParameters.txId === null || requestParameters.txId === undefined) {
          throw new RequiredError('txId', 'Required parameter requestParameters.txId was null or undefined when calling getTransactionById.');
        }

        var queryParameters = {};

        if (requestParameters.eventOffset !== undefined) {
          queryParameters['event_offset'] = requestParameters.eventOffset;
        }

        if (requestParameters.eventLimit !== undefined) {
          queryParameters['event_limit'] = requestParameters.eventLimit;
        }

        if (requestParameters.unanchored !== undefined) {
          queryParameters['unanchored'] = requestParameters.unanchored;
        }

        var headerParameters = {};
        return Promise.resolve(_this26.request({
          path: "/extended/v1/tx/{tx_id}".replace("{" + "tx_id" + "}", encodeURIComponent(String(requestParameters.txId))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves transaction details for a given transaction ID  `import type { Transaction } from \'@stacks/stacks-blockchain-api-types\';`
     * Get transaction
     */
    ;

    _proto.getTransactionById = function getTransactionById(requestParameters, initOverrides) {
      try {
        var _this28 = this;

        return Promise.resolve(_this28.getTransactionByIdRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves all recently mined transactions  If using TypeScript, import typings for this response from our types package:  `import type { TransactionResults } from \'@stacks/stacks-blockchain-api-types\';`
     * Get recent transactions
     */
    ;

    _proto.getTransactionListRaw = function getTransactionListRaw(requestParameters, initOverrides) {
      try {
        var _this30 = this;

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.type) {
          queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.unanchored !== undefined) {
          queryParameters['unanchored'] = requestParameters.unanchored;
        }

        var headerParameters = {};
        return Promise.resolve(_this30.request({
          path: "/extended/v1/tx",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return TransactionResultsFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves all recently mined transactions  If using TypeScript, import typings for this response from our types package:  `import type { TransactionResults } from \'@stacks/stacks-blockchain-api-types\';`
     * Get recent transactions
     */
    ;

    _proto.getTransactionList = function getTransactionList(requestParameters, initOverrides) {
      try {
        var _this32 = this;

        return Promise.resolve(_this32.getTransactionListRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of all transactions within a block for a given block hash.
     * Transactions by block hash
     */
    ;

    _proto.getTransactionsByBlockHashRaw = function getTransactionsByBlockHashRaw(requestParameters, initOverrides) {
      try {
        var _this34 = this;

        if (requestParameters.blockHash === null || requestParameters.blockHash === undefined) {
          throw new RequiredError('blockHash', 'Required parameter requestParameters.blockHash was null or undefined when calling getTransactionsByBlockHash.');
        }

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        var headerParameters = {};
        return Promise.resolve(_this34.request({
          path: "/extended/v1/tx/block/{block_hash}".replace("{" + "block_hash" + "}", encodeURIComponent(String(requestParameters.blockHash))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return TransactionResultsFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of all transactions within a block for a given block hash.
     * Transactions by block hash
     */
    ;

    _proto.getTransactionsByBlockHash = function getTransactionsByBlockHash(requestParameters, initOverrides) {
      try {
        var _this36 = this;

        return Promise.resolve(_this36.getTransactionsByBlockHashRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves all transactions within a block at a given height
     * Transactions by block height
     */
    ;

    _proto.getTransactionsByBlockHeightRaw = function getTransactionsByBlockHeightRaw(requestParameters, initOverrides) {
      try {
        var _this38 = this;

        if (requestParameters.height === null || requestParameters.height === undefined) {
          throw new RequiredError('height', 'Required parameter requestParameters.height was null or undefined when calling getTransactionsByBlockHeight.');
        }

        var queryParameters = {};

        if (requestParameters.limit !== undefined) {
          queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
          queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.unanchored !== undefined) {
          queryParameters['unanchored'] = requestParameters.unanchored;
        }

        var headerParameters = {};
        return Promise.resolve(_this38.request({
          path: "/extended/v1/tx/block_height/{height}".replace("{" + "height" + "}", encodeURIComponent(String(requestParameters.height))),
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response, function (jsonValue) {
            return TransactionResultsFromJSON(jsonValue);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves all transactions within a block at a given height
     * Transactions by block height
     */
    ;

    _proto.getTransactionsByBlockHeight = function getTransactionsByBlockHeight(requestParameters, initOverrides) {
      try {
        var _this40 = this;

        return Promise.resolve(_this40.getTransactionsByBlockHeightRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of transactions for a given list of transaction IDs  If using TypeScript, import typings for this response from our types package:  `import type { Transaction } from \'@stacks/stacks-blockchain-api-types\';`
     * Get list of details for transactions
     */
    ;

    _proto.getTxListDetailsRaw = function getTxListDetailsRaw(requestParameters, initOverrides) {
      try {
        var _this42 = this;

        if (requestParameters.txId === null || requestParameters.txId === undefined) {
          throw new RequiredError('txId', 'Required parameter requestParameters.txId was null or undefined when calling getTxListDetails.');
        }

        var queryParameters = {};

        if (requestParameters.txId) {
          queryParameters['tx_id'] = requestParameters.txId;
        }

        if (requestParameters.eventOffset !== undefined) {
          queryParameters['event_offset'] = requestParameters.eventOffset;
        }

        if (requestParameters.eventLimit !== undefined) {
          queryParameters['event_limit'] = requestParameters.eventLimit;
        }

        if (requestParameters.unanchored !== undefined) {
          queryParameters['unanchored'] = requestParameters.unanchored;
        }

        var headerParameters = {};
        return Promise.resolve(_this42.request({
          path: "/extended/v1/tx/multiple",
          method: 'GET',
          headers: headerParameters,
          query: queryParameters
        }, initOverrides)).then(function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Retrieves a list of transactions for a given list of transaction IDs  If using TypeScript, import typings for this response from our types package:  `import type { Transaction } from \'@stacks/stacks-blockchain-api-types\';`
     * Get list of details for transactions
     */
    ;

    _proto.getTxListDetails = function getTxListDetails(requestParameters, initOverrides) {
      try {
        var _this44 = this;

        return Promise.resolve(_this44.getTxListDetailsRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Broadcasts raw transactions on the network. You can use the [@stacks/transactions](https://github.com/blockstack/stacks.js) project to generate a raw transaction payload.
     * Broadcast raw transaction
     */
    ;

    _proto.postCoreNodeTransactionsRaw = function postCoreNodeTransactionsRaw(requestParameters, initOverrides) {
      try {
        var _this46 = this;

        var queryParameters = {};
        var headerParameters = {};
        headerParameters['Content-Type'] = 'application/octet-stream';
        return Promise.resolve(_this46.request({
          path: "/v2/transactions",
          method: 'POST',
          headers: headerParameters,
          query: queryParameters,
          body: requestParameters.body
        }, initOverrides)).then(function (response) {
          return new TextApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Broadcasts raw transactions on the network. You can use the [@stacks/transactions](https://github.com/blockstack/stacks.js) project to generate a raw transaction payload.
     * Broadcast raw transaction
     */
    ;

    _proto.postCoreNodeTransactions = function postCoreNodeTransactions(requestParameters, initOverrides) {
      try {
        var _this48 = this;

        return Promise.resolve(_this48.postCoreNodeTransactionsRaw(requestParameters, initOverrides)).then(function (response) {
          return Promise.resolve(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    return TransactionsApi;
  }(BaseAPI);
  /**
      * @export
      * @enum {string}
      */

  exports.GetFilteredEventsTypeEnum = void 0;

  (function (GetFilteredEventsTypeEnum) {
    GetFilteredEventsTypeEnum["smart_contract_log"] = "smart_contract_log";
    GetFilteredEventsTypeEnum["stx_lock"] = "stx_lock";
    GetFilteredEventsTypeEnum["stx_asset"] = "stx_asset";
    GetFilteredEventsTypeEnum["fungible_token_asset"] = "fungible_token_asset";
    GetFilteredEventsTypeEnum["non_fungible_token_asset"] = "non_fungible_token_asset";
  })(exports.GetFilteredEventsTypeEnum || (exports.GetFilteredEventsTypeEnum = {}));
  /**
      * @export
      * @enum {string}
      */


  exports.GetTransactionListTypeEnum = void 0;

  (function (GetTransactionListTypeEnum) {
    GetTransactionListTypeEnum["coinbase"] = "coinbase";
    GetTransactionListTypeEnum["token_transfer"] = "token_transfer";
    GetTransactionListTypeEnum["smart_contract"] = "smart_contract";
    GetTransactionListTypeEnum["contract_call"] = "contract_call";
    GetTransactionListTypeEnum["poison_microblock"] = "poison_microblock";
  })(exports.GetTransactionListTypeEnum || (exports.GetTransactionListTypeEnum = {}));

  // **Github:** https://github.com/teambition/jsonrpc-lite
  const hasOwnProperty = Object.prototype.hasOwnProperty;
  const isInteger = typeof Number.isSafeInteger === 'function'
      ? Number.isSafeInteger // ECMAScript 2015
      : function (num) {
          return typeof num === 'number' && isFinite(num) && num === Math.floor(num) && Math.abs(num) <= 9007199254740991;
      };
  class JsonRpc {
      constructor() {
          this.jsonrpc = '2.0';
      }
      serialize() {
          return JSON.stringify(this);
      }
  }
  JsonRpc.VERSION = '2.0';
  class RequestObject extends JsonRpc {
      constructor(id, method, params) {
          super();
          this.id = id;
          this.method = method;
          if (params !== undefined) {
              this.params = params;
          }
      }
  }
  class NotificationObject extends JsonRpc {
      constructor(method, params) {
          super();
          this.method = method;
          if (params !== undefined) {
              this.params = params;
          }
      }
  }
  class SuccessObject extends JsonRpc {
      constructor(id, result) {
          super();
          this.id = id;
          this.result = result;
      }
  }
  class ErrorObject extends JsonRpc {
      // tslint:disable-next-line:no-shadowed-variable
      constructor(id, error) {
          super();
          this.id = id;
          this.error = error;
          this.id = id;
          this.error = error;
      }
  }
  class JsonRpcParsed {
      constructor(payload, type) {
          this.payload = payload;
          this.type = type;
          this.payload = payload;
          this.type = type;
      }
  }
  /**
   * JsonRpcError Class
   *
   * @param  {String} message
   * @param  {Integer} code
   * @return {String} name: optional
   * @api public
   */
  class JsonRpcError {
      constructor(message, code, data) {
          this.message = message;
          this.code = isInteger(code) ? code : 0;
          if (data != null) {
              this.data = data;
          }
      }
  }
  JsonRpcError.invalidRequest = function (data) {
      return new JsonRpcError('Invalid request', -32600, data);
  };
  JsonRpcError.methodNotFound = function (data) {
      return new JsonRpcError('Method not found', -32601, data);
  };
  JsonRpcError.invalidParams = function (data) {
      return new JsonRpcError('Invalid params', -32602, data);
  };
  JsonRpcError.internalError = function (data) {
      return new JsonRpcError('Internal error', -32603, data);
  };
  JsonRpcError.parseError = function (data) {
      return new JsonRpcError('Parse error', -32700, data);
  };
  /**
   * Creates a JSON-RPC 2.0 request object
   *
   * @param  {String|Integer} id
   * @param  {String} method
   * @param  {Object|Array} [params]: optional
   * @return {Object} JsonRpc object
   * @api public
   */
  function request(id, method, params) {
      const object = new RequestObject(id, method, params);
      validateMessage(object, true);
      return object;
  }
  function parse(message) {
      if (!isString(message)) {
          return new JsonRpcParsed(JsonRpcError.invalidRequest(message), "invalid" /* invalid */);
      }
      let jsonrpcObj;
      try {
          jsonrpcObj = JSON.parse(message);
      }
      catch (err) {
          return new JsonRpcParsed(JsonRpcError.parseError(message), "invalid" /* invalid */);
      }
      return parseJsonRpcObject(jsonrpcObj);
  }
  /**
   * Takes a JSON-RPC 2.0 payload (Object) or batch (Object[]) and tries to parse it.
   * If successful, determine what objects are inside (response, notification,
   * success, error, or invalid), and return their types and properly formatted objects.
   *
   * @param  {Object|Array} jsonrpcObj
   * @return {Object|Array} a single object or an array of `JsonRpcParsed` objects with `type` and `payload`:
   *
   *  {
   *    type: <Enum, 'request'|'notification'|'success'|'error'|'invalid'>
   *    payload: <JsonRpc|JsonRpcError>
   *  }
   *
   * @api public
   */
  function parseJsonRpcObject(jsonrpcObj) {
      if (!Array.isArray(jsonrpcObj)) {
          return parseObject(jsonrpcObj);
      }
      if (jsonrpcObj.length === 0) {
          return new JsonRpcParsed(JsonRpcError.invalidRequest(jsonrpcObj), "invalid" /* invalid */);
      }
      const parsedObjectArray = [];
      for (let i = 0, len = jsonrpcObj.length; i < len; i++) {
          parsedObjectArray[i] = parseObject(jsonrpcObj[i]);
      }
      return parsedObjectArray;
  }
  /**
   * Takes a JSON-RPC 2.0 payload (Object) and tries to parse it into a JSON.
   * If successful, determine what object is it (response, notification,
   * success, error, or invalid), and return it's type and properly formatted object.
   *
   * @param  {Object} obj
   * @return {Object} an `JsonRpcParsed` object with `type` and `payload`:
   *
   *  {
   *    type: <Enum, 'request'|'notification'|'success'|'error'|'invalid'>
   *    payload: <JsonRpc|JsonRpcError>
   *  }
   *
   * @api public
   */
  function parseObject(obj) {
      let err = null;
      let payload = null;
      let payloadType = "invalid" /* invalid */;
      if (obj == null || obj.jsonrpc !== JsonRpc.VERSION) {
          err = JsonRpcError.invalidRequest(obj);
          payloadType = "invalid" /* invalid */;
      }
      else if (!hasOwnProperty.call(obj, 'id')) {
          const tmp = obj;
          payload = new NotificationObject(tmp.method, tmp.params);
          err = validateMessage(payload);
          payloadType = "notification" /* notification */;
      }
      else if (hasOwnProperty.call(obj, 'method')) {
          const tmp = obj;
          payload = new RequestObject(tmp.id, tmp.method, tmp.params);
          err = validateMessage(payload);
          payloadType = "request" /* request */;
      }
      else if (hasOwnProperty.call(obj, 'result')) {
          const tmp = obj;
          payload = new SuccessObject(tmp.id, tmp.result);
          err = validateMessage(payload);
          payloadType = "success" /* success */;
      }
      else if (hasOwnProperty.call(obj, 'error')) {
          const tmp = obj;
          payloadType = "error" /* error */;
          if (tmp.error == null) {
              err = JsonRpcError.internalError(tmp);
          }
          else {
              const errorObj = new JsonRpcError(tmp.error.message, tmp.error.code, tmp.error.data);
              if (errorObj.message !== tmp.error.message || errorObj.code !== tmp.error.code) {
                  err = JsonRpcError.internalError(tmp);
              }
              else {
                  payload = new ErrorObject(tmp.id, errorObj);
                  err = validateMessage(payload);
              }
          }
      }
      if (err == null && payload != null) {
          return new JsonRpcParsed(payload, payloadType);
      }
      return new JsonRpcParsed(err != null ? err : JsonRpcError.invalidRequest(obj), "invalid" /* invalid */);
  }
  // if error, return error, else return null
  function validateMessage(obj, throwIt) {
      let err = null;
      if (obj instanceof RequestObject) {
          err = checkId(obj.id);
          if (err == null) {
              err = checkMethod(obj.method);
          }
          if (err == null) {
              err = checkParams(obj.params);
          }
      }
      else if (obj instanceof NotificationObject) {
          err = checkMethod(obj.method);
          if (err == null) {
              err = checkParams(obj.params);
          }
      }
      else if (obj instanceof SuccessObject) {
          err = checkId(obj.id);
          if (err == null) {
              err = checkResult(obj.result);
          }
      }
      else if (obj instanceof ErrorObject) {
          err = checkId(obj.id, true);
          if (err == null) {
              err = checkError(obj.error);
          }
      }
      if (throwIt && err != null) {
          throw err;
      }
      return err;
  }
  function checkId(id, maybeNull) {
      if (maybeNull && id === null) {
          return null;
      }
      return isString(id) || isInteger(id)
          ? null
          : JsonRpcError.internalError('"id" must be provided, a string or an integer.');
  }
  function checkMethod(method) {
      return isString(method) ? null : JsonRpcError.invalidRequest(method);
  }
  function checkResult(result) {
      return result === undefined
          ? JsonRpcError.internalError('Result must exist for success Response objects')
          : null;
  }
  function checkParams(params) {
      if (params === undefined) {
          return null;
      }
      if (Array.isArray(params) || isObject(params)) {
          // ensure params can be stringify
          try {
              JSON.stringify(params);
              return null;
          }
          catch (err) {
              return JsonRpcError.parseError(params);
          }
      }
      return JsonRpcError.invalidParams(params);
  }
  function checkError(err) {
      if (!(err instanceof JsonRpcError)) {
          return JsonRpcError.internalError('Error must be an instance of JsonRpcError');
      }
      if (!isInteger(err.code)) {
          return JsonRpcError.internalError('Invalid error code. It must be an integer.');
      }
      if (!isString(err.message)) {
          return JsonRpcError.internalError('Message must exist or must be a string.');
      }
      return null;
  }
  function isString(obj) {
      return obj !== '' && typeof obj === 'string';
  }
  function isObject(obj) {
      return obj != null && typeof obj === 'object' && !Array.isArray(obj);
  }

  function createCommonjsModule(fn) {
    var module = { exports: {} };
  	return fn(module, module.exports), module.exports;
  }

  var eventemitter3 = createCommonjsModule(function (module) {

  var has = Object.prototype.hasOwnProperty
    , prefix = '~';

  /**
   * Constructor to create a storage for our `EE` objects.
   * An `Events` instance is a plain object whose properties are event names.
   *
   * @constructor
   * @private
   */
  function Events() {}

  //
  // We try to not inherit from `Object.prototype`. In some engines creating an
  // instance in this way is faster than calling `Object.create(null)` directly.
  // If `Object.create(null)` is not supported we prefix the event names with a
  // character to make sure that the built-in object properties are not
  // overridden or used as an attack vector.
  //
  if (Object.create) {
    Events.prototype = Object.create(null);

    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__) prefix = false;
  }

  /**
   * Representation of a single event listener.
   *
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
   * @constructor
   * @private
   */
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }

  /**
   * Add a listener for a given event.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} once Specify if the listener is a one-time listener.
   * @returns {EventEmitter}
   * @private
   */
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== 'function') {
      throw new TypeError('The listener must be a function');
    }

    var listener = new EE(fn, context || emitter, once)
      , evt = prefix ? prefix + event : event;

    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [emitter._events[evt], listener];

    return emitter;
  }

  /**
   * Clear event by name.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} evt The Event name.
   * @private
   */
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }

  /**
   * Minimal `EventEmitter` interface that is molded against the Node.js
   * `EventEmitter` interface.
   *
   * @constructor
   * @public
   */
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }

  /**
   * Return an array listing the events for which the emitter has registered
   * listeners.
   *
   * @returns {Array}
   * @public
   */
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = []
      , events
      , name;

    if (this._eventsCount === 0) return names;

    for (name in (events = this._events)) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }

    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }

    return names;
  };

  /**
   * Return the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Array} The registered listeners.
   * @public
   */
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event
      , handlers = this._events[evt];

    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];

    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }

    return ee;
  };

  /**
   * Return the number of listeners listening to a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Number} The number of listeners.
   * @public
   */
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event
      , listeners = this._events[evt];

    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };

  /**
   * Calls each of the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Boolean} `true` if the event had listeners, else `false`.
   * @public
   */
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;

    if (!this._events[evt]) return false;

    var listeners = this._events[evt]
      , len = arguments.length
      , args
      , i;

    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

      switch (len) {
        case 1: return listeners.fn.call(listeners.context), true;
        case 2: return listeners.fn.call(listeners.context, a1), true;
        case 3: return listeners.fn.call(listeners.context, a1, a2), true;
        case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }

      for (i = 1, args = new Array(len -1); i < len; i++) {
        args[i - 1] = arguments[i];
      }

      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length
        , j;

      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

        switch (len) {
          case 1: listeners[i].fn.call(listeners[i].context); break;
          case 2: listeners[i].fn.call(listeners[i].context, a1); break;
          case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
          case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
          default:
            if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
              args[j - 1] = arguments[j];
            }

            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }

    return true;
  };

  /**
   * Add a listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };

  /**
   * Add a one-time listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };

  /**
   * Remove the listeners of a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn Only remove the listeners that match this function.
   * @param {*} context Only remove the listeners that have this context.
   * @param {Boolean} once Only remove one-time listeners.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;

    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }

    var listeners = this._events[evt];

    if (listeners.fn) {
      if (
        listeners.fn === fn &&
        (!once || listeners.once) &&
        (!context || listeners.context === context)
      ) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (
          listeners[i].fn !== fn ||
          (once && !listeners[i].once) ||
          (context && listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }

      //
      // Reset the array, or remove it completely if we have no more listeners.
      //
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
      else clearEvent(this, evt);
    }

    return this;
  };

  /**
   * Remove all listeners, or those of the specified event.
   *
   * @param {(String|Symbol)} [event] The event name.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;

    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }

    return this;
  };

  //
  // Alias methods names because people roll like that.
  //
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  //
  // Expose the prefix.
  //
  EventEmitter.prefixed = prefix;

  //
  // Allow `EventEmitter` to be imported as module namespace.
  //
  EventEmitter.EventEmitter = EventEmitter;

  //
  // Expose the module.
  //
  {
    module.exports = EventEmitter;
  }
  });

  var connectWebSocketClient = function connectWebSocketClient(url) {
    if (url === void 0) {
      url = BASE_PATH;
    }

    try {
      return Promise.resolve(StacksApiWebSocketClient.connect(url));
    } catch (e) {
      return Promise.reject(e);
    }
  };
  /**
   * Simple isomorphic WebSocket class lookup.
   * Uses global WebSocket (browsers) if available, otherwise, uses the Node.js `ws` lib.
   */

  var StacksApiWebSocketClient = /*#__PURE__*/function () {
    StacksApiWebSocketClient.connect = function connect(url) {
      if (url === void 0) {
        url = BASE_PATH;
      }

      try {
        // `ws://${addr}/extended/v1/ws`;
        var urlObj;

        try {
          urlObj = new URL(url);
        } catch (_error) {
          urlObj = new URL("ws://" + url);
        }

        if (urlObj.protocol === 'https:') {
          urlObj.protocol = 'wss:';
        } else if (urlObj.protocol === 'http:') {
          urlObj.protocol = 'ws:';
        }

        if (urlObj.pathname === '/') {
          urlObj.pathname = '/extended/v1/ws';
        }

        return Promise.resolve(new Promise(function (resolve, reject) {
          var webSocket = new (createWebSocket())(urlObj.toString());

          webSocket.onopen = function () {
            return resolve(webSocket);
          };

          webSocket.onerror = function (error) {
            return reject(error);
          };
        })).then(function (webSocket) {
          return new StacksApiWebSocketClient(webSocket);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    function StacksApiWebSocketClient(webSocket) {
      var _this = this;

      this.webSocket = void 0;
      this.idCursor = 0;
      this.pendingRequests = new Map();
      this.eventEmitter = new eventemitter3.EventEmitter();
      this.webSocket = webSocket;
      webSocket.addEventListener('message', function (event) {
        var parsed = parse(event.data);
        var rpcObjects = Array.isArray(parsed) ? parsed : [parsed];
        rpcObjects.forEach(function (obj) {
          if (obj.type === "notification"
          /* notification */
          ) {
            _this.handleNotification(obj.payload);
          } else if (obj.type === "success"
          /* success */
          ) {
            var req = _this.pendingRequests.get(obj.payload.id);

            if (req) {
              _this.pendingRequests["delete"](obj.payload.id);

              req.resolve(obj.payload.result);
            }
          } else if (obj.type === "error"
          /* error */
          ) {
            var _req = _this.pendingRequests.get(obj.payload.id);

            if (_req) {
              _this.pendingRequests["delete"](obj.payload.id);

              _req.reject(obj.payload.error);
            }
          }
        });
      });
    }

    var _proto = StacksApiWebSocketClient.prototype;

    _proto.handleNotification = function handleNotification(data) {
      var method = data.method;

      switch (method) {
        case 'tx_update':
          this.eventEmitter.emit('txUpdate', data.params);
          break;

        case 'address_tx_update':
          this.eventEmitter.emit('addressTxUpdate', data.params);
          break;

        case 'address_balance_update':
          this.eventEmitter.emit('addressBalanceUpdate', data.params);
          break;

        case 'block':
          this.eventEmitter.emit('block', data.params);
          break;

        case 'microblock':
          this.eventEmitter.emit('microblock', data.params);
          break;

        case 'mempool':
          this.eventEmitter.emit('mempool', data.params);
          break;

        case 'nft_event':
          this.eventEmitter.emit('nftEventUpdate', data.params);
          break;

        case 'nft_asset_event':
          this.eventEmitter.emit('nftAssetEventUpdate', data.params);
          break;

        case 'nft_collection_event':
          this.eventEmitter.emit('nftCollectionEventUpdate', data.params);
          break;
      }
    };

    _proto.rpcCall = function rpcCall(method, params) {
      var _this2 = this;

      var rpcReq = request(++this.idCursor, method, params);
      return new Promise(function (resolve, reject) {
        _this2.pendingRequests.set(rpcReq.id, {
          resolve: resolve,
          reject: reject
        });

        _this2.webSocket.send(rpcReq.serialize());
      });
    };

    _proto.subscribeBlocks = function subscribeBlocks(update) {
      try {
        var _this4 = this;

        var params = {
          event: 'block'
        };
        return Promise.resolve(_this4.rpcCall('subscribe', params)).then(function () {
          var listener = function listener(event) {
            update(event);
          };

          _this4.eventEmitter.addListener('block', listener);

          return {
            unsubscribe: function unsubscribe() {
              _this4.eventEmitter.removeListener('block', listener);

              return _this4.rpcCall('unsubscribe', params);
            }
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.subscribeMicroblocks = function subscribeMicroblocks(update) {
      try {
        var _this6 = this;

        var params = {
          event: 'microblock'
        };
        return Promise.resolve(_this6.rpcCall('subscribe', params)).then(function () {
          var listener = function listener(event) {
            update(event);
          };

          _this6.eventEmitter.addListener('microblock', listener);

          return {
            unsubscribe: function unsubscribe() {
              _this6.eventEmitter.removeListener('microblock', listener);

              return _this6.rpcCall('unsubscribe', params);
            }
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.subscribeMempool = function subscribeMempool(update) {
      try {
        var _this8 = this;

        var params = {
          event: 'mempool'
        };
        return Promise.resolve(_this8.rpcCall('subscribe', params)).then(function () {
          var listener = function listener(event) {
            update(event);
          };

          _this8.eventEmitter.addListener('mempool', listener);

          return {
            unsubscribe: function unsubscribe() {
              _this8.eventEmitter.removeListener('mempool', listener);

              return _this8.rpcCall('unsubscribe', params);
            }
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.subscribeTxUpdates = function subscribeTxUpdates(txId, update) {
      try {
        var _this10 = this;

        var params = {
          event: 'tx_update',
          tx_id: txId
        };
        return Promise.resolve(_this10.rpcCall('subscribe', params)).then(function (subscribed) {
          var listener = function listener(event) {
            if (event.tx_id === subscribed.tx_id) {
              update(event);
            }
          };

          _this10.eventEmitter.addListener('txUpdate', listener);

          return {
            unsubscribe: function unsubscribe() {
              _this10.eventEmitter.removeListener('txUpdate', listener);

              return _this10.rpcCall('unsubscribe', params);
            }
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.subscribeAddressTransactions = function subscribeAddressTransactions(address, update) {
      try {
        var _this12 = this;

        var params = {
          event: 'address_tx_update',
          address: address
        };
        return Promise.resolve(_this12.rpcCall('subscribe', params)).then(function (subscribed) {
          var listener = function listener(event) {
            if (event.address === subscribed.address) {
              update(event);
            }
          };

          _this12.eventEmitter.addListener('addressTxUpdate', listener);

          return {
            unsubscribe: function unsubscribe() {
              _this12.eventEmitter.removeListener('addressTxUpdate', listener);

              return _this12.rpcCall('unsubscribe', params);
            }
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.subscribeAddressBalanceUpdates = function subscribeAddressBalanceUpdates(address, update) {
      try {
        var _this14 = this;

        var params = {
          event: 'address_balance_update',
          address: address
        };
        return Promise.resolve(_this14.rpcCall('subscribe', params)).then(function (subscribed) {
          var listener = function listener(event) {
            if (event.address === subscribed.address) {
              update(event);
            }
          };

          _this14.eventEmitter.addListener('addressBalanceUpdate', listener);

          return {
            unsubscribe: function unsubscribe() {
              _this14.eventEmitter.removeListener('addressBalanceUpdate', listener);

              return _this14.rpcCall('unsubscribe', params);
            }
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.subscribeNftEventUpdates = function subscribeNftEventUpdates(update) {
      try {
        var _this16 = this;

        var params = {
          event: 'nft_event'
        };
        return Promise.resolve(_this16.rpcCall('subscribe', params)).then(function () {
          var listener = function listener(event) {
            update(event);
          };

          _this16.eventEmitter.addListener('nftEventUpdate', listener);

          return {
            unsubscribe: function unsubscribe() {
              _this16.eventEmitter.removeListener('nftEventUpdate', listener);

              return _this16.rpcCall('unsubscribe', params);
            }
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.subscribeNftAssetEventUpdates = function subscribeNftAssetEventUpdates(assetIdentifier, value, update) {
      try {
        var _this18 = this;

        var params = {
          event: 'nft_asset_event',
          asset_identifier: assetIdentifier,
          value: value
        };
        return Promise.resolve(_this18.rpcCall('subscribe', params)).then(function (subscribed) {
          var listener = function listener(event) {
            if (event.asset_identifier === subscribed.asset_identifier && event.value.hex === subscribed.value) {
              update(event);
            }
          };

          _this18.eventEmitter.addListener('nftAssetEventUpdate', listener);

          return {
            unsubscribe: function unsubscribe() {
              _this18.eventEmitter.removeListener('nftAssetEventUpdate', listener);

              return _this18.rpcCall('unsubscribe', params);
            }
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    _proto.subscribeNftCollectionEventUpdates = function subscribeNftCollectionEventUpdates(assetIdentifier, update) {
      try {
        var _this20 = this;

        var params = {
          event: 'nft_collection_event',
          asset_identifier: assetIdentifier
        };
        return Promise.resolve(_this20.rpcCall('subscribe', params)).then(function (subscribed) {
          var listener = function listener(event) {
            if (event.asset_identifier === subscribed.asset_identifier) {
              update(event);
            }
          };

          _this20.eventEmitter.addListener('nftCollectionEventUpdate', listener);

          return {
            unsubscribe: function unsubscribe() {
              _this20.eventEmitter.removeListener('nftCollectionEventUpdate', listener);

              return _this20.rpcCall('unsubscribe', params);
            }
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    return StacksApiWebSocketClient;
  }();

  function createWebSocket() {
    if (typeof WebSocket !== 'undefined') {
      return WebSocket;
    } else if (typeof global !== 'undefined' && global.WebSocket) {
      return global.WebSocket;
    } else if (typeof window !== 'undefined' && window.WebSocket) {
      return window.WebSocket;
    } else if (typeof self !== 'undefined' && self.WebSocket) {
      return self.WebSocket;
    } else {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      return require('ws');
    }
  }

  /**
   * Parses an URI
   *
   * @author Steven Levithan <stevenlevithan.com> (MIT license)
   * @api private
   */
  var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

  var parts = [
      'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
  ];

  var parseuri = function parseuri(str) {
      var src = str,
          b = str.indexOf('['),
          e = str.indexOf(']');

      if (b != -1 && e != -1) {
          str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
      }

      var m = re.exec(str || ''),
          uri = {},
          i = 14;

      while (i--) {
          uri[parts[i]] = m[i] || '';
      }

      if (b != -1 && e != -1) {
          uri.source = src;
          uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
          uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
          uri.ipv6uri = true;
      }

      uri.pathNames = pathNames(uri, uri['path']);
      uri.queryKey = queryKey(uri, uri['query']);

      return uri;
  };

  function pathNames(obj, path) {
      var regx = /\/{2,9}/g,
          names = path.replace(regx, "/").split("/");

      if (path.substr(0, 1) == '/' || path.length === 0) {
          names.splice(0, 1);
      }
      if (path.substr(path.length - 1, 1) == '/') {
          names.splice(names.length - 1, 1);
      }

      return names;
  }

  function queryKey(uri, query) {
      var data = {};

      query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
          if ($1) {
              data[$1] = $2;
          }
      });

      return data;
  }

  /**
   * URL parser.
   *
   * @param uri - url
   * @param path - the request path of the connection
   * @param loc - An object meant to mimic window.location.
   *        Defaults to window.location.
   * @public
   */
  function url(uri, path = "", loc) {
      let obj = uri;
      // default to window.location
      loc = loc || (typeof location !== "undefined" && location);
      if (null == uri)
          uri = loc.protocol + "//" + loc.host;
      // relative path support
      if (typeof uri === "string") {
          if ("/" === uri.charAt(0)) {
              if ("/" === uri.charAt(1)) {
                  uri = loc.protocol + uri;
              }
              else {
                  uri = loc.host + uri;
              }
          }
          if (!/^(https?|wss?):\/\//.test(uri)) {
              if ("undefined" !== typeof loc) {
                  uri = loc.protocol + "//" + uri;
              }
              else {
                  uri = "https://" + uri;
              }
          }
          // parse
          obj = parseuri(uri);
      }
      // make sure we treat `localhost:80` and `localhost` equally
      if (!obj.port) {
          if (/^(http|ws)$/.test(obj.protocol)) {
              obj.port = "80";
          }
          else if (/^(http|ws)s$/.test(obj.protocol)) {
              obj.port = "443";
          }
      }
      obj.path = obj.path || "/";
      const ipv6 = obj.host.indexOf(":") !== -1;
      const host = ipv6 ? "[" + obj.host + "]" : obj.host;
      // define unique id
      obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
      // define href
      obj.href =
          obj.protocol +
              "://" +
              host +
              (loc && loc.port === obj.port ? "" : ":" + obj.port);
      return obj;
  }

  var hasCors = createCommonjsModule(function (module) {
  /**
   * Module exports.
   *
   * Logic borrowed from Modernizr:
   *
   *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
   */

  try {
    module.exports = typeof XMLHttpRequest !== 'undefined' &&
      'withCredentials' in new XMLHttpRequest();
  } catch (err) {
    // if XMLHttp support is disabled in IE then it will throw
    // when trying to create
    module.exports = false;
  }
  });

  var globalThis = (() => {
      if (typeof self !== "undefined") {
          return self;
      }
      else if (typeof window !== "undefined") {
          return window;
      }
      else {
          return Function("return this")();
      }
  })();

  // browser shim for xmlhttprequest module
  function XMLHttpRequest$1 (opts) {
      const xdomain = opts.xdomain;
      // XMLHttpRequest can be disabled on IE
      try {
          if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCors)) {
              return new XMLHttpRequest();
          }
      }
      catch (e) { }
      if (!xdomain) {
          try {
              return new globalThis[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
          }
          catch (e) { }
      }
  }

  function pick(obj, ...attr) {
      return attr.reduce((acc, k) => {
          if (obj.hasOwnProperty(k)) {
              acc[k] = obj[k];
          }
          return acc;
      }, {});
  }
  // Keep a reference to the real timeout functions so they can be used when overridden
  const NATIVE_SET_TIMEOUT = setTimeout;
  const NATIVE_CLEAR_TIMEOUT = clearTimeout;
  function installTimerFunctions(obj, opts) {
      if (opts.useNativeTimers) {
          obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis);
          obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis);
      }
      else {
          obj.setTimeoutFn = setTimeout.bind(globalThis);
          obj.clearTimeoutFn = clearTimeout.bind(globalThis);
      }
  }

  /**
   * Expose `Emitter`.
   */

  var Emitter_1 = Emitter;

  /**
   * Initialize a new `Emitter`.
   *
   * @api public
   */

  function Emitter(obj) {
    if (obj) return mixin(obj);
  }

  /**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */

  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }
    return obj;
  }

  /**
   * Listen on the given `event` with `fn`.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.on =
  Emitter.prototype.addEventListener = function(event, fn){
    this._callbacks = this._callbacks || {};
    (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
      .push(fn);
    return this;
  };

  /**
   * Adds an `event` listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.once = function(event, fn){
    function on() {
      this.off(event, on);
      fn.apply(this, arguments);
    }

    on.fn = fn;
    this.on(event, on);
    return this;
  };

  /**
   * Remove the given callback for `event` or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.off =
  Emitter.prototype.removeListener =
  Emitter.prototype.removeAllListeners =
  Emitter.prototype.removeEventListener = function(event, fn){
    this._callbacks = this._callbacks || {};

    // all
    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    }

    // specific event
    var callbacks = this._callbacks['$' + event];
    if (!callbacks) return this;

    // remove all handlers
    if (1 == arguments.length) {
      delete this._callbacks['$' + event];
      return this;
    }

    // remove specific handler
    var cb;
    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];
      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    }

    // Remove event specific arrays for event types that no
    // one is subscribed for to avoid memory leak.
    if (callbacks.length === 0) {
      delete this._callbacks['$' + event];
    }

    return this;
  };

  /**
   * Emit `event` with the given args.
   *
   * @param {String} event
   * @param {Mixed} ...
   * @return {Emitter}
   */

  Emitter.prototype.emit = function(event){
    this._callbacks = this._callbacks || {};

    var args = new Array(arguments.length - 1)
      , callbacks = this._callbacks['$' + event];

    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }

    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }

    return this;
  };

  // alias used for reserved events (protected method)
  Emitter.prototype.emitReserved = Emitter.prototype.emit;

  /**
   * Return array of callbacks for `event`.
   *
   * @param {String} event
   * @return {Array}
   * @api public
   */

  Emitter.prototype.listeners = function(event){
    this._callbacks = this._callbacks || {};
    return this._callbacks['$' + event] || [];
  };

  /**
   * Check if this emitter has `event` handlers.
   *
   * @param {String} event
   * @return {Boolean}
   * @api public
   */

  Emitter.prototype.hasListeners = function(event){
    return !! this.listeners(event).length;
  };

  const PACKET_TYPES = Object.create(null); // no Map = no polyfill
  PACKET_TYPES["open"] = "0";
  PACKET_TYPES["close"] = "1";
  PACKET_TYPES["ping"] = "2";
  PACKET_TYPES["pong"] = "3";
  PACKET_TYPES["message"] = "4";
  PACKET_TYPES["upgrade"] = "5";
  PACKET_TYPES["noop"] = "6";
  const PACKET_TYPES_REVERSE = Object.create(null);
  Object.keys(PACKET_TYPES).forEach(key => {
      PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
  });
  const ERROR_PACKET = { type: "error", data: "parser error" };

  const withNativeBlob$1 = typeof Blob === "function" ||
      (typeof Blob !== "undefined" &&
          Object.prototype.toString.call(Blob) === "[object BlobConstructor]");
  const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
  // ArrayBuffer.isView method is not defined in IE10
  const isView$1 = obj => {
      return typeof ArrayBuffer.isView === "function"
          ? ArrayBuffer.isView(obj)
          : obj && obj.buffer instanceof ArrayBuffer;
  };
  const encodePacket = ({ type, data }, supportsBinary, callback) => {
      if (withNativeBlob$1 && data instanceof Blob) {
          if (supportsBinary) {
              return callback(data);
          }
          else {
              return encodeBlobAsBase64(data, callback);
          }
      }
      else if (withNativeArrayBuffer$2 &&
          (data instanceof ArrayBuffer || isView$1(data))) {
          if (supportsBinary) {
              return callback(data);
          }
          else {
              return encodeBlobAsBase64(new Blob([data]), callback);
          }
      }
      // plain string
      return callback(PACKET_TYPES[type] + (data || ""));
  };
  const encodeBlobAsBase64 = (data, callback) => {
      const fileReader = new FileReader();
      fileReader.onload = function () {
          const content = fileReader.result.split(",")[1];
          callback("b" + content);
      };
      return fileReader.readAsDataURL(data);
  };

  /*
   * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>
   * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  // Use a lookup table to find the index.
  var lookup$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  for (var i$1 = 0; i$1 < chars.length; i$1++) {
      lookup$1[chars.charCodeAt(i$1)] = i$1;
  }
  var decode$2 = function (base64) {
      var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base64[base64.length - 1] === '=') {
          bufferLength--;
          if (base64[base64.length - 2] === '=') {
              bufferLength--;
          }
      }
      var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
      for (i = 0; i < len; i += 4) {
          encoded1 = lookup$1[base64.charCodeAt(i)];
          encoded2 = lookup$1[base64.charCodeAt(i + 1)];
          encoded3 = lookup$1[base64.charCodeAt(i + 2)];
          encoded4 = lookup$1[base64.charCodeAt(i + 3)];
          bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
          bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
          bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
      }
      return arraybuffer;
  };

  const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
  const decodePacket = (encodedPacket, binaryType) => {
      if (typeof encodedPacket !== "string") {
          return {
              type: "message",
              data: mapBinary(encodedPacket, binaryType)
          };
      }
      const type = encodedPacket.charAt(0);
      if (type === "b") {
          return {
              type: "message",
              data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
          };
      }
      const packetType = PACKET_TYPES_REVERSE[type];
      if (!packetType) {
          return ERROR_PACKET;
      }
      return encodedPacket.length > 1
          ? {
              type: PACKET_TYPES_REVERSE[type],
              data: encodedPacket.substring(1)
          }
          : {
              type: PACKET_TYPES_REVERSE[type]
          };
  };
  const decodeBase64Packet = (data, binaryType) => {
      if (withNativeArrayBuffer$1) {
          const decoded = decode$2(data);
          return mapBinary(decoded, binaryType);
      }
      else {
          return { base64: true, data }; // fallback for old browsers
      }
  };
  const mapBinary = (data, binaryType) => {
      switch (binaryType) {
          case "blob":
              return data instanceof ArrayBuffer ? new Blob([data]) : data;
          case "arraybuffer":
          default:
              return data; // assuming the data is already an ArrayBuffer
      }
  };

  const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
  const encodePayload = (packets, callback) => {
      // some packets may be added to the array while encoding, so the initial length must be saved
      const length = packets.length;
      const encodedPackets = new Array(length);
      let count = 0;
      packets.forEach((packet, i) => {
          // force base64 encoding for binary packets
          encodePacket(packet, false, encodedPacket => {
              encodedPackets[i] = encodedPacket;
              if (++count === length) {
                  callback(encodedPackets.join(SEPARATOR));
              }
          });
      });
  };
  const decodePayload = (encodedPayload, binaryType) => {
      const encodedPackets = encodedPayload.split(SEPARATOR);
      const packets = [];
      for (let i = 0; i < encodedPackets.length; i++) {
          const decodedPacket = decodePacket(encodedPackets[i], binaryType);
          packets.push(decodedPacket);
          if (decodedPacket.type === "error") {
              break;
          }
      }
      return packets;
  };
  const protocol$1 = 4;

  class Transport extends Emitter_1 {
      /**
       * Transport abstract constructor.
       *
       * @param {Object} options.
       * @api private
       */
      constructor(opts) {
          super();
          this.writable = false;
          installTimerFunctions(this, opts);
          this.opts = opts;
          this.query = opts.query;
          this.readyState = "";
          this.socket = opts.socket;
      }
      /**
       * Emits an error.
       *
       * @param {String} str
       * @return {Transport} for chaining
       * @api protected
       */
      onError(msg, desc) {
          const err = new Error(msg);
          // @ts-ignore
          err.type = "TransportError";
          // @ts-ignore
          err.description = desc;
          super.emit("error", err);
          return this;
      }
      /**
       * Opens the transport.
       *
       * @api public
       */
      open() {
          if ("closed" === this.readyState || "" === this.readyState) {
              this.readyState = "opening";
              this.doOpen();
          }
          return this;
      }
      /**
       * Closes the transport.
       *
       * @api public
       */
      close() {
          if ("opening" === this.readyState || "open" === this.readyState) {
              this.doClose();
              this.onClose();
          }
          return this;
      }
      /**
       * Sends multiple packets.
       *
       * @param {Array} packets
       * @api public
       */
      send(packets) {
          if ("open" === this.readyState) {
              this.write(packets);
          }
      }
      /**
       * Called upon open
       *
       * @api protected
       */
      onOpen() {
          this.readyState = "open";
          this.writable = true;
          super.emit("open");
      }
      /**
       * Called with data.
       *
       * @param {String} data
       * @api protected
       */
      onData(data) {
          const packet = decodePacket(data, this.socket.binaryType);
          this.onPacket(packet);
      }
      /**
       * Called with a decoded packet.
       *
       * @api protected
       */
      onPacket(packet) {
          super.emit("packet", packet);
      }
      /**
       * Called upon close.
       *
       * @api protected
       */
      onClose() {
          this.readyState = "closed";
          super.emit("close");
      }
  }

  var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
    , length = 64
    , map = {}
    , seed = 0
    , i = 0
    , prev;

  /**
   * Return a string representing the specified number.
   *
   * @param {Number} num The number to convert.
   * @returns {String} The string representation of the number.
   * @api public
   */
  function encode$1(num) {
    var encoded = '';

    do {
      encoded = alphabet[num % length] + encoded;
      num = Math.floor(num / length);
    } while (num > 0);

    return encoded;
  }

  /**
   * Return the integer value specified by the given string.
   *
   * @param {String} str The string to convert.
   * @returns {Number} The integer value represented by the string.
   * @api public
   */
  function decode$1(str) {
    var decoded = 0;

    for (i = 0; i < str.length; i++) {
      decoded = decoded * length + map[str.charAt(i)];
    }

    return decoded;
  }

  /**
   * Yeast: A tiny growing id generator.
   *
   * @returns {String} A unique id.
   * @api public
   */
  function yeast() {
    var now = encode$1(+new Date());

    if (now !== prev) return seed = 0, prev = now;
    return now +'.'+ encode$1(seed++);
  }

  //
  // Map each character to its index.
  //
  for (; i < length; i++) map[alphabet[i]] = i;

  //
  // Expose the `yeast`, `encode` and `decode` functions.
  //
  yeast.encode = encode$1;
  yeast.decode = decode$1;
  var yeast_1 = yeast;

  /**
   * Compiles a querystring
   * Returns string representation of the object
   *
   * @param {Object}
   * @api private
   */
  var encode = function (obj) {
    var str = '';

    for (var i in obj) {
      if (obj.hasOwnProperty(i)) {
        if (str.length) str += '&';
        str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
      }
    }

    return str;
  };

  /**
   * Parses a simple querystring into an object
   *
   * @param {String} qs
   * @api private
   */

  var decode = function(qs){
    var qry = {};
    var pairs = qs.split('&');
    for (var i = 0, l = pairs.length; i < l; i++) {
      var pair = pairs[i].split('=');
      qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return qry;
  };

  var parseqs = {
  	encode: encode,
  	decode: decode
  };

  class Polling extends Transport {
      constructor() {
          super(...arguments);
          this.polling = false;
      }
      /**
       * Transport name.
       */
      get name() {
          return "polling";
      }
      /**
       * Opens the socket (triggers polling). We write a PING message to determine
       * when the transport is open.
       *
       * @api private
       */
      doOpen() {
          this.poll();
      }
      /**
       * Pauses polling.
       *
       * @param {Function} callback upon buffers are flushed and transport is paused
       * @api private
       */
      pause(onPause) {
          this.readyState = "pausing";
          const pause = () => {
              this.readyState = "paused";
              onPause();
          };
          if (this.polling || !this.writable) {
              let total = 0;
              if (this.polling) {
                  total++;
                  this.once("pollComplete", function () {
                      --total || pause();
                  });
              }
              if (!this.writable) {
                  total++;
                  this.once("drain", function () {
                      --total || pause();
                  });
              }
          }
          else {
              pause();
          }
      }
      /**
       * Starts polling cycle.
       *
       * @api public
       */
      poll() {
          this.polling = true;
          this.doPoll();
          this.emit("poll");
      }
      /**
       * Overloads onData to detect payloads.
       *
       * @api private
       */
      onData(data) {
          const callback = packet => {
              // if its the first message we consider the transport open
              if ("opening" === this.readyState && packet.type === "open") {
                  this.onOpen();
              }
              // if its a close packet, we close the ongoing requests
              if ("close" === packet.type) {
                  this.onClose();
                  return false;
              }
              // otherwise bypass onData and handle the message
              this.onPacket(packet);
          };
          // decode payload
          decodePayload(data, this.socket.binaryType).forEach(callback);
          // if an event did not trigger closing
          if ("closed" !== this.readyState) {
              // if we got data we're not polling
              this.polling = false;
              this.emit("pollComplete");
              if ("open" === this.readyState) {
                  this.poll();
              }
          }
      }
      /**
       * For polling, send a close packet.
       *
       * @api private
       */
      doClose() {
          const close = () => {
              this.write([{ type: "close" }]);
          };
          if ("open" === this.readyState) {
              close();
          }
          else {
              // in case we're trying to close while
              // handshaking is in progress (GH-164)
              this.once("open", close);
          }
      }
      /**
       * Writes a packets payload.
       *
       * @param {Array} data packets
       * @param {Function} drain callback
       * @api private
       */
      write(packets) {
          this.writable = false;
          encodePayload(packets, data => {
              this.doWrite(data, () => {
                  this.writable = true;
                  this.emit("drain");
              });
          });
      }
      /**
       * Generates uri for connection.
       *
       * @api private
       */
      uri() {
          let query = this.query || {};
          const schema = this.opts.secure ? "https" : "http";
          let port = "";
          // cache busting is forced
          if (false !== this.opts.timestampRequests) {
              query[this.opts.timestampParam] = yeast_1();
          }
          if (!this.supportsBinary && !query.sid) {
              query.b64 = 1;
          }
          // avoid port if default for schema
          if (this.opts.port &&
              (("https" === schema && Number(this.opts.port) !== 443) ||
                  ("http" === schema && Number(this.opts.port) !== 80))) {
              port = ":" + this.opts.port;
          }
          const encodedQuery = parseqs.encode(query);
          const ipv6 = this.opts.hostname.indexOf(":") !== -1;
          return (schema +
              "://" +
              (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) +
              port +
              this.opts.path +
              (encodedQuery.length ? "?" + encodedQuery : ""));
      }
  }

  /* global attachEvent */
  /**
   * Empty function
   */
  function empty() { }
  const hasXHR2 = (function () {
      const xhr = new XMLHttpRequest$1({
          xdomain: false
      });
      return null != xhr.responseType;
  })();
  class XHR extends Polling {
      /**
       * XHR Polling constructor.
       *
       * @param {Object} opts
       * @api public
       */
      constructor(opts) {
          super(opts);
          if (typeof location !== "undefined") {
              const isSSL = "https:" === location.protocol;
              let port = location.port;
              // some user agents have empty `location.port`
              if (!port) {
                  port = isSSL ? "443" : "80";
              }
              this.xd =
                  (typeof location !== "undefined" &&
                      opts.hostname !== location.hostname) ||
                      port !== opts.port;
              this.xs = opts.secure !== isSSL;
          }
          /**
           * XHR supports binary
           */
          const forceBase64 = opts && opts.forceBase64;
          this.supportsBinary = hasXHR2 && !forceBase64;
      }
      /**
       * Creates a request.
       *
       * @param {String} method
       * @api private
       */
      request(opts = {}) {
          Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
          return new Request(this.uri(), opts);
      }
      /**
       * Sends data.
       *
       * @param {String} data to send.
       * @param {Function} called upon flush.
       * @api private
       */
      doWrite(data, fn) {
          const req = this.request({
              method: "POST",
              data: data
          });
          req.on("success", fn);
          req.on("error", err => {
              this.onError("xhr post error", err);
          });
      }
      /**
       * Starts a poll cycle.
       *
       * @api private
       */
      doPoll() {
          const req = this.request();
          req.on("data", this.onData.bind(this));
          req.on("error", err => {
              this.onError("xhr poll error", err);
          });
          this.pollXhr = req;
      }
  }
  class Request extends Emitter_1 {
      /**
       * Request constructor
       *
       * @param {Object} options
       * @api public
       */
      constructor(uri, opts) {
          super();
          installTimerFunctions(this, opts);
          this.opts = opts;
          this.method = opts.method || "GET";
          this.uri = uri;
          this.async = false !== opts.async;
          this.data = undefined !== opts.data ? opts.data : null;
          this.create();
      }
      /**
       * Creates the XHR object and sends the request.
       *
       * @api private
       */
      create() {
          const opts = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
          opts.xdomain = !!this.opts.xd;
          opts.xscheme = !!this.opts.xs;
          const xhr = (this.xhr = new XMLHttpRequest$1(opts));
          try {
              xhr.open(this.method, this.uri, this.async);
              try {
                  if (this.opts.extraHeaders) {
                      xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
                      for (let i in this.opts.extraHeaders) {
                          if (this.opts.extraHeaders.hasOwnProperty(i)) {
                              xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
                          }
                      }
                  }
              }
              catch (e) { }
              if ("POST" === this.method) {
                  try {
                      xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
                  }
                  catch (e) { }
              }
              try {
                  xhr.setRequestHeader("Accept", "*/*");
              }
              catch (e) { }
              // ie6 check
              if ("withCredentials" in xhr) {
                  xhr.withCredentials = this.opts.withCredentials;
              }
              if (this.opts.requestTimeout) {
                  xhr.timeout = this.opts.requestTimeout;
              }
              xhr.onreadystatechange = () => {
                  if (4 !== xhr.readyState)
                      return;
                  if (200 === xhr.status || 1223 === xhr.status) {
                      this.onLoad();
                  }
                  else {
                      // make sure the `error` event handler that's user-set
                      // does not throw in the same tick and gets caught here
                      this.setTimeoutFn(() => {
                          this.onError(typeof xhr.status === "number" ? xhr.status : 0);
                      }, 0);
                  }
              };
              xhr.send(this.data);
          }
          catch (e) {
              // Need to defer since .create() is called directly from the constructor
              // and thus the 'error' event can only be only bound *after* this exception
              // occurs.  Therefore, also, we cannot throw here at all.
              this.setTimeoutFn(() => {
                  this.onError(e);
              }, 0);
              return;
          }
          if (typeof document !== "undefined") {
              this.index = Request.requestsCount++;
              Request.requests[this.index] = this;
          }
      }
      /**
       * Called upon successful response.
       *
       * @api private
       */
      onSuccess() {
          this.emit("success");
          this.cleanup();
      }
      /**
       * Called if we have data.
       *
       * @api private
       */
      onData(data) {
          this.emit("data", data);
          this.onSuccess();
      }
      /**
       * Called upon error.
       *
       * @api private
       */
      onError(err) {
          this.emit("error", err);
          this.cleanup(true);
      }
      /**
       * Cleans up house.
       *
       * @api private
       */
      cleanup(fromError) {
          if ("undefined" === typeof this.xhr || null === this.xhr) {
              return;
          }
          this.xhr.onreadystatechange = empty;
          if (fromError) {
              try {
                  this.xhr.abort();
              }
              catch (e) { }
          }
          if (typeof document !== "undefined") {
              delete Request.requests[this.index];
          }
          this.xhr = null;
      }
      /**
       * Called upon load.
       *
       * @api private
       */
      onLoad() {
          const data = this.xhr.responseText;
          if (data !== null) {
              this.onData(data);
          }
      }
      /**
       * Aborts the request.
       *
       * @api public
       */
      abort() {
          this.cleanup();
      }
  }
  Request.requestsCount = 0;
  Request.requests = {};
  /**
   * Aborts pending requests when unloading the window. This is needed to prevent
   * memory leaks (e.g. when using IE) and to ensure that no spurious error is
   * emitted.
   */
  if (typeof document !== "undefined") {
      // @ts-ignore
      if (typeof attachEvent === "function") {
          // @ts-ignore
          attachEvent("onunload", unloadHandler);
      }
      else if (typeof addEventListener === "function") {
          const terminationEvent = "onpagehide" in globalThis ? "pagehide" : "unload";
          addEventListener(terminationEvent, unloadHandler, false);
      }
  }
  function unloadHandler() {
      for (let i in Request.requests) {
          if (Request.requests.hasOwnProperty(i)) {
              Request.requests[i].abort();
          }
      }
  }

  const nextTick = (() => {
      const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
      if (isPromiseAvailable) {
          return cb => Promise.resolve().then(cb);
      }
      else {
          return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
      }
  })();
  const WebSocket$1 = globalThis.WebSocket || globalThis.MozWebSocket;
  const usingBrowserWebSocket = true;
  const defaultBinaryType = "arraybuffer";

  // detect ReactNative environment
  const isReactNative = typeof navigator !== "undefined" &&
      typeof navigator.product === "string" &&
      navigator.product.toLowerCase() === "reactnative";
  class WS extends Transport {
      /**
       * WebSocket transport constructor.
       *
       * @api {Object} connection options
       * @api public
       */
      constructor(opts) {
          super(opts);
          this.supportsBinary = !opts.forceBase64;
      }
      /**
       * Transport name.
       *
       * @api public
       */
      get name() {
          return "websocket";
      }
      /**
       * Opens socket.
       *
       * @api private
       */
      doOpen() {
          if (!this.check()) {
              // let probe timeout
              return;
          }
          const uri = this.uri();
          const protocols = this.opts.protocols;
          // React Native only supports the 'headers' option, and will print a warning if anything else is passed
          const opts = isReactNative
              ? {}
              : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
          if (this.opts.extraHeaders) {
              opts.headers = this.opts.extraHeaders;
          }
          try {
              this.ws =
                  usingBrowserWebSocket && !isReactNative
                      ? protocols
                          ? new WebSocket$1(uri, protocols)
                          : new WebSocket$1(uri)
                      : new WebSocket$1(uri, protocols, opts);
          }
          catch (err) {
              return this.emit("error", err);
          }
          this.ws.binaryType = this.socket.binaryType || defaultBinaryType;
          this.addEventListeners();
      }
      /**
       * Adds event listeners to the socket
       *
       * @api private
       */
      addEventListeners() {
          this.ws.onopen = () => {
              if (this.opts.autoUnref) {
                  this.ws._socket.unref();
              }
              this.onOpen();
          };
          this.ws.onclose = this.onClose.bind(this);
          this.ws.onmessage = ev => this.onData(ev.data);
          this.ws.onerror = e => this.onError("websocket error", e);
      }
      /**
       * Writes data to socket.
       *
       * @param {Array} array of packets.
       * @api private
       */
      write(packets) {
          this.writable = false;
          // encodePacket efficient as it uses WS framing
          // no need for encodePayload
          for (let i = 0; i < packets.length; i++) {
              const packet = packets[i];
              const lastPacket = i === packets.length - 1;
              encodePacket(packet, this.supportsBinary, data => {
                  // always create a new object (GH-437)
                  const opts = {};
                  // Sometimes the websocket has already been closed but the browser didn't
                  // have a chance of informing us about it yet, in that case send will
                  // throw an error
                  try {
                      if (usingBrowserWebSocket) {
                          // TypeError is thrown when passing the second argument on Safari
                          this.ws.send(data);
                      }
                  }
                  catch (e) {
                  }
                  if (lastPacket) {
                      // fake drain
                      // defer to next tick to allow Socket to clear writeBuffer
                      nextTick(() => {
                          this.writable = true;
                          this.emit("drain");
                      }, this.setTimeoutFn);
                  }
              });
          }
      }
      /**
       * Closes socket.
       *
       * @api private
       */
      doClose() {
          if (typeof this.ws !== "undefined") {
              this.ws.close();
              this.ws = null;
          }
      }
      /**
       * Generates uri for connection.
       *
       * @api private
       */
      uri() {
          let query = this.query || {};
          const schema = this.opts.secure ? "wss" : "ws";
          let port = "";
          // avoid port if default for schema
          if (this.opts.port &&
              (("wss" === schema && Number(this.opts.port) !== 443) ||
                  ("ws" === schema && Number(this.opts.port) !== 80))) {
              port = ":" + this.opts.port;
          }
          // append timestamp to URI
          if (this.opts.timestampRequests) {
              query[this.opts.timestampParam] = yeast_1();
          }
          // communicate binary support capabilities
          if (!this.supportsBinary) {
              query.b64 = 1;
          }
          const encodedQuery = parseqs.encode(query);
          const ipv6 = this.opts.hostname.indexOf(":") !== -1;
          return (schema +
              "://" +
              (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) +
              port +
              this.opts.path +
              (encodedQuery.length ? "?" + encodedQuery : ""));
      }
      /**
       * Feature detection for WebSocket.
       *
       * @return {Boolean} whether this transport is available.
       * @api public
       */
      check() {
          return (!!WebSocket$1 &&
              !("__initialize" in WebSocket$1 && this.name === WS.prototype.name));
      }
  }

  const transports = {
      websocket: WS,
      polling: XHR
  };

  class Socket$1 extends Emitter_1 {
      /**
       * Socket constructor.
       *
       * @param {String|Object} uri or options
       * @param {Object} opts - options
       * @api public
       */
      constructor(uri, opts = {}) {
          super();
          if (uri && "object" === typeof uri) {
              opts = uri;
              uri = null;
          }
          if (uri) {
              uri = parseuri(uri);
              opts.hostname = uri.host;
              opts.secure = uri.protocol === "https" || uri.protocol === "wss";
              opts.port = uri.port;
              if (uri.query)
                  opts.query = uri.query;
          }
          else if (opts.host) {
              opts.hostname = parseuri(opts.host).host;
          }
          installTimerFunctions(this, opts);
          this.secure =
              null != opts.secure
                  ? opts.secure
                  : typeof location !== "undefined" && "https:" === location.protocol;
          if (opts.hostname && !opts.port) {
              // if no port is specified manually, use the protocol default
              opts.port = this.secure ? "443" : "80";
          }
          this.hostname =
              opts.hostname ||
                  (typeof location !== "undefined" ? location.hostname : "localhost");
          this.port =
              opts.port ||
                  (typeof location !== "undefined" && location.port
                      ? location.port
                      : this.secure
                          ? "443"
                          : "80");
          this.transports = opts.transports || ["polling", "websocket"];
          this.readyState = "";
          this.writeBuffer = [];
          this.prevBufferLen = 0;
          this.opts = Object.assign({
              path: "/engine.io",
              agent: false,
              withCredentials: false,
              upgrade: true,
              timestampParam: "t",
              rememberUpgrade: false,
              rejectUnauthorized: true,
              perMessageDeflate: {
                  threshold: 1024
              },
              transportOptions: {},
              closeOnBeforeunload: true
          }, opts);
          this.opts.path = this.opts.path.replace(/\/$/, "") + "/";
          if (typeof this.opts.query === "string") {
              this.opts.query = parseqs.decode(this.opts.query);
          }
          // set on handshake
          this.id = null;
          this.upgrades = null;
          this.pingInterval = null;
          this.pingTimeout = null;
          // set on heartbeat
          this.pingTimeoutTimer = null;
          if (typeof addEventListener === "function") {
              if (this.opts.closeOnBeforeunload) {
                  // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
                  // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
                  // closed/reloaded)
                  addEventListener("beforeunload", () => {
                      if (this.transport) {
                          // silently close the transport
                          this.transport.removeAllListeners();
                          this.transport.close();
                      }
                  }, false);
              }
              if (this.hostname !== "localhost") {
                  this.offlineEventListener = () => {
                      this.onClose("transport close");
                  };
                  addEventListener("offline", this.offlineEventListener, false);
              }
          }
          this.open();
      }
      /**
       * Creates transport of the given type.
       *
       * @param {String} transport name
       * @return {Transport}
       * @api private
       */
      createTransport(name) {
          const query = clone(this.opts.query);
          // append engine.io protocol identifier
          query.EIO = protocol$1;
          // transport name
          query.transport = name;
          // session id if we already have one
          if (this.id)
              query.sid = this.id;
          const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {
              query,
              socket: this,
              hostname: this.hostname,
              secure: this.secure,
              port: this.port
          });
          return new transports[name](opts);
      }
      /**
       * Initializes transport to use and starts probe.
       *
       * @api private
       */
      open() {
          let transport;
          if (this.opts.rememberUpgrade &&
              Socket$1.priorWebsocketSuccess &&
              this.transports.indexOf("websocket") !== -1) {
              transport = "websocket";
          }
          else if (0 === this.transports.length) {
              // Emit error on next tick so it can be listened to
              this.setTimeoutFn(() => {
                  this.emitReserved("error", "No transports available");
              }, 0);
              return;
          }
          else {
              transport = this.transports[0];
          }
          this.readyState = "opening";
          // Retry with the next transport if the transport is disabled (jsonp: false)
          try {
              transport = this.createTransport(transport);
          }
          catch (e) {
              this.transports.shift();
              this.open();
              return;
          }
          transport.open();
          this.setTransport(transport);
      }
      /**
       * Sets the current transport. Disables the existing one (if any).
       *
       * @api private
       */
      setTransport(transport) {
          if (this.transport) {
              this.transport.removeAllListeners();
          }
          // set up transport
          this.transport = transport;
          // set up transport listeners
          transport
              .on("drain", this.onDrain.bind(this))
              .on("packet", this.onPacket.bind(this))
              .on("error", this.onError.bind(this))
              .on("close", () => {
              this.onClose("transport close");
          });
      }
      /**
       * Probes a transport.
       *
       * @param {String} transport name
       * @api private
       */
      probe(name) {
          let transport = this.createTransport(name);
          let failed = false;
          Socket$1.priorWebsocketSuccess = false;
          const onTransportOpen = () => {
              if (failed)
                  return;
              transport.send([{ type: "ping", data: "probe" }]);
              transport.once("packet", msg => {
                  if (failed)
                      return;
                  if ("pong" === msg.type && "probe" === msg.data) {
                      this.upgrading = true;
                      this.emitReserved("upgrading", transport);
                      if (!transport)
                          return;
                      Socket$1.priorWebsocketSuccess = "websocket" === transport.name;
                      this.transport.pause(() => {
                          if (failed)
                              return;
                          if ("closed" === this.readyState)
                              return;
                          cleanup();
                          this.setTransport(transport);
                          transport.send([{ type: "upgrade" }]);
                          this.emitReserved("upgrade", transport);
                          transport = null;
                          this.upgrading = false;
                          this.flush();
                      });
                  }
                  else {
                      const err = new Error("probe error");
                      // @ts-ignore
                      err.transport = transport.name;
                      this.emitReserved("upgradeError", err);
                  }
              });
          };
          function freezeTransport() {
              if (failed)
                  return;
              // Any callback called by transport should be ignored since now
              failed = true;
              cleanup();
              transport.close();
              transport = null;
          }
          // Handle any error that happens while probing
          const onerror = err => {
              const error = new Error("probe error: " + err);
              // @ts-ignore
              error.transport = transport.name;
              freezeTransport();
              this.emitReserved("upgradeError", error);
          };
          function onTransportClose() {
              onerror("transport closed");
          }
          // When the socket is closed while we're probing
          function onclose() {
              onerror("socket closed");
          }
          // When the socket is upgraded while we're probing
          function onupgrade(to) {
              if (transport && to.name !== transport.name) {
                  freezeTransport();
              }
          }
          // Remove all listeners on the transport and on self
          const cleanup = () => {
              transport.removeListener("open", onTransportOpen);
              transport.removeListener("error", onerror);
              transport.removeListener("close", onTransportClose);
              this.off("close", onclose);
              this.off("upgrading", onupgrade);
          };
          transport.once("open", onTransportOpen);
          transport.once("error", onerror);
          transport.once("close", onTransportClose);
          this.once("close", onclose);
          this.once("upgrading", onupgrade);
          transport.open();
      }
      /**
       * Called when connection is deemed open.
       *
       * @api private
       */
      onOpen() {
          this.readyState = "open";
          Socket$1.priorWebsocketSuccess = "websocket" === this.transport.name;
          this.emitReserved("open");
          this.flush();
          // we check for `readyState` in case an `open`
          // listener already closed the socket
          if ("open" === this.readyState &&
              this.opts.upgrade &&
              this.transport.pause) {
              let i = 0;
              const l = this.upgrades.length;
              for (; i < l; i++) {
                  this.probe(this.upgrades[i]);
              }
          }
      }
      /**
       * Handles a packet.
       *
       * @api private
       */
      onPacket(packet) {
          if ("opening" === this.readyState ||
              "open" === this.readyState ||
              "closing" === this.readyState) {
              this.emitReserved("packet", packet);
              // Socket is live - any packet counts
              this.emitReserved("heartbeat");
              switch (packet.type) {
                  case "open":
                      this.onHandshake(JSON.parse(packet.data));
                      break;
                  case "ping":
                      this.resetPingTimeout();
                      this.sendPacket("pong");
                      this.emitReserved("ping");
                      this.emitReserved("pong");
                      break;
                  case "error":
                      const err = new Error("server error");
                      // @ts-ignore
                      err.code = packet.data;
                      this.onError(err);
                      break;
                  case "message":
                      this.emitReserved("data", packet.data);
                      this.emitReserved("message", packet.data);
                      break;
              }
          }
      }
      /**
       * Called upon handshake completion.
       *
       * @param {Object} data - handshake obj
       * @api private
       */
      onHandshake(data) {
          this.emitReserved("handshake", data);
          this.id = data.sid;
          this.transport.query.sid = data.sid;
          this.upgrades = this.filterUpgrades(data.upgrades);
          this.pingInterval = data.pingInterval;
          this.pingTimeout = data.pingTimeout;
          this.onOpen();
          // In case open handler closes socket
          if ("closed" === this.readyState)
              return;
          this.resetPingTimeout();
      }
      /**
       * Sets and resets ping timeout timer based on server pings.
       *
       * @api private
       */
      resetPingTimeout() {
          this.clearTimeoutFn(this.pingTimeoutTimer);
          this.pingTimeoutTimer = this.setTimeoutFn(() => {
              this.onClose("ping timeout");
          }, this.pingInterval + this.pingTimeout);
          if (this.opts.autoUnref) {
              this.pingTimeoutTimer.unref();
          }
      }
      /**
       * Called on `drain` event
       *
       * @api private
       */
      onDrain() {
          this.writeBuffer.splice(0, this.prevBufferLen);
          // setting prevBufferLen = 0 is very important
          // for example, when upgrading, upgrade packet is sent over,
          // and a nonzero prevBufferLen could cause problems on `drain`
          this.prevBufferLen = 0;
          if (0 === this.writeBuffer.length) {
              this.emitReserved("drain");
          }
          else {
              this.flush();
          }
      }
      /**
       * Flush write buffers.
       *
       * @api private
       */
      flush() {
          if ("closed" !== this.readyState &&
              this.transport.writable &&
              !this.upgrading &&
              this.writeBuffer.length) {
              this.transport.send(this.writeBuffer);
              // keep track of current length of writeBuffer
              // splice writeBuffer and callbackBuffer on `drain`
              this.prevBufferLen = this.writeBuffer.length;
              this.emitReserved("flush");
          }
      }
      /**
       * Sends a message.
       *
       * @param {String} message.
       * @param {Function} callback function.
       * @param {Object} options.
       * @return {Socket} for chaining.
       * @api public
       */
      write(msg, options, fn) {
          this.sendPacket("message", msg, options, fn);
          return this;
      }
      send(msg, options, fn) {
          this.sendPacket("message", msg, options, fn);
          return this;
      }
      /**
       * Sends a packet.
       *
       * @param {String} packet type.
       * @param {String} data.
       * @param {Object} options.
       * @param {Function} callback function.
       * @api private
       */
      sendPacket(type, data, options, fn) {
          if ("function" === typeof data) {
              fn = data;
              data = undefined;
          }
          if ("function" === typeof options) {
              fn = options;
              options = null;
          }
          if ("closing" === this.readyState || "closed" === this.readyState) {
              return;
          }
          options = options || {};
          options.compress = false !== options.compress;
          const packet = {
              type: type,
              data: data,
              options: options
          };
          this.emitReserved("packetCreate", packet);
          this.writeBuffer.push(packet);
          if (fn)
              this.once("flush", fn);
          this.flush();
      }
      /**
       * Closes the connection.
       *
       * @api public
       */
      close() {
          const close = () => {
              this.onClose("forced close");
              this.transport.close();
          };
          const cleanupAndClose = () => {
              this.off("upgrade", cleanupAndClose);
              this.off("upgradeError", cleanupAndClose);
              close();
          };
          const waitForUpgrade = () => {
              // wait for upgrade to finish since we can't send packets while pausing a transport
              this.once("upgrade", cleanupAndClose);
              this.once("upgradeError", cleanupAndClose);
          };
          if ("opening" === this.readyState || "open" === this.readyState) {
              this.readyState = "closing";
              if (this.writeBuffer.length) {
                  this.once("drain", () => {
                      if (this.upgrading) {
                          waitForUpgrade();
                      }
                      else {
                          close();
                      }
                  });
              }
              else if (this.upgrading) {
                  waitForUpgrade();
              }
              else {
                  close();
              }
          }
          return this;
      }
      /**
       * Called upon transport error
       *
       * @api private
       */
      onError(err) {
          Socket$1.priorWebsocketSuccess = false;
          this.emitReserved("error", err);
          this.onClose("transport error", err);
      }
      /**
       * Called upon transport close.
       *
       * @api private
       */
      onClose(reason, desc) {
          if ("opening" === this.readyState ||
              "open" === this.readyState ||
              "closing" === this.readyState) {
              // clear timers
              this.clearTimeoutFn(this.pingTimeoutTimer);
              // stop event from firing again for transport
              this.transport.removeAllListeners("close");
              // ensure transport won't stay open
              this.transport.close();
              // ignore further transport communication
              this.transport.removeAllListeners();
              if (typeof removeEventListener === "function") {
                  removeEventListener("offline", this.offlineEventListener, false);
              }
              // set ready state
              this.readyState = "closed";
              // clear session id
              this.id = null;
              // emit close event
              this.emitReserved("close", reason, desc);
              // clean buffers after, so users can still
              // grab the buffers on `close` event
              this.writeBuffer = [];
              this.prevBufferLen = 0;
          }
      }
      /**
       * Filters upgrades, returning only those matching client transports.
       *
       * @param {Array} server upgrades
       * @api private
       *
       */
      filterUpgrades(upgrades) {
          const filteredUpgrades = [];
          let i = 0;
          const j = upgrades.length;
          for (; i < j; i++) {
              if (~this.transports.indexOf(upgrades[i]))
                  filteredUpgrades.push(upgrades[i]);
          }
          return filteredUpgrades;
      }
  }
  Socket$1.protocol = protocol$1;
  function clone(obj) {
      const o = {};
      for (let i in obj) {
          if (obj.hasOwnProperty(i)) {
              o[i] = obj[i];
          }
      }
      return o;
  }

  const withNativeArrayBuffer = typeof ArrayBuffer === "function";
  const isView = (obj) => {
      return typeof ArrayBuffer.isView === "function"
          ? ArrayBuffer.isView(obj)
          : obj.buffer instanceof ArrayBuffer;
  };
  const toString = Object.prototype.toString;
  const withNativeBlob = typeof Blob === "function" ||
      (typeof Blob !== "undefined" &&
          toString.call(Blob) === "[object BlobConstructor]");
  const withNativeFile = typeof File === "function" ||
      (typeof File !== "undefined" &&
          toString.call(File) === "[object FileConstructor]");
  /**
   * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
   *
   * @private
   */
  function isBinary(obj) {
      return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||
          (withNativeBlob && obj instanceof Blob) ||
          (withNativeFile && obj instanceof File));
  }
  function hasBinary(obj, toJSON) {
      if (!obj || typeof obj !== "object") {
          return false;
      }
      if (Array.isArray(obj)) {
          for (let i = 0, l = obj.length; i < l; i++) {
              if (hasBinary(obj[i])) {
                  return true;
              }
          }
          return false;
      }
      if (isBinary(obj)) {
          return true;
      }
      if (obj.toJSON &&
          typeof obj.toJSON === "function" &&
          arguments.length === 1) {
          return hasBinary(obj.toJSON(), true);
      }
      for (const key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
              return true;
          }
      }
      return false;
  }

  /**
   * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
   *
   * @param {Object} packet - socket.io event packet
   * @return {Object} with deconstructed packet and list of buffers
   * @public
   */
  function deconstructPacket(packet) {
      const buffers = [];
      const packetData = packet.data;
      const pack = packet;
      pack.data = _deconstructPacket(packetData, buffers);
      pack.attachments = buffers.length; // number of binary 'attachments'
      return { packet: pack, buffers: buffers };
  }
  function _deconstructPacket(data, buffers) {
      if (!data)
          return data;
      if (isBinary(data)) {
          const placeholder = { _placeholder: true, num: buffers.length };
          buffers.push(data);
          return placeholder;
      }
      else if (Array.isArray(data)) {
          const newData = new Array(data.length);
          for (let i = 0; i < data.length; i++) {
              newData[i] = _deconstructPacket(data[i], buffers);
          }
          return newData;
      }
      else if (typeof data === "object" && !(data instanceof Date)) {
          const newData = {};
          for (const key in data) {
              if (data.hasOwnProperty(key)) {
                  newData[key] = _deconstructPacket(data[key], buffers);
              }
          }
          return newData;
      }
      return data;
  }
  /**
   * Reconstructs a binary packet from its placeholder packet and buffers
   *
   * @param {Object} packet - event packet with placeholders
   * @param {Array} buffers - binary buffers to put in placeholder positions
   * @return {Object} reconstructed packet
   * @public
   */
  function reconstructPacket(packet, buffers) {
      packet.data = _reconstructPacket(packet.data, buffers);
      packet.attachments = undefined; // no longer useful
      return packet;
  }
  function _reconstructPacket(data, buffers) {
      if (!data)
          return data;
      if (data && data._placeholder) {
          return buffers[data.num]; // appropriate buffer (should be natural order anyway)
      }
      else if (Array.isArray(data)) {
          for (let i = 0; i < data.length; i++) {
              data[i] = _reconstructPacket(data[i], buffers);
          }
      }
      else if (typeof data === "object") {
          for (const key in data) {
              if (data.hasOwnProperty(key)) {
                  data[key] = _reconstructPacket(data[key], buffers);
              }
          }
      }
      return data;
  }

  /**
   * Protocol version.
   *
   * @public
   */
  const protocol = 5;
  var PacketType;
  (function (PacketType) {
      PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
      PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
      PacketType[PacketType["EVENT"] = 2] = "EVENT";
      PacketType[PacketType["ACK"] = 3] = "ACK";
      PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
      PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
      PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
  })(PacketType || (PacketType = {}));
  /**
   * A socket.io Encoder instance
   */
  class Encoder {
      /**
       * Encode a packet as a single string if non-binary, or as a
       * buffer sequence, depending on packet type.
       *
       * @param {Object} obj - packet object
       */
      encode(obj) {
          if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
              if (hasBinary(obj)) {
                  obj.type =
                      obj.type === PacketType.EVENT
                          ? PacketType.BINARY_EVENT
                          : PacketType.BINARY_ACK;
                  return this.encodeAsBinary(obj);
              }
          }
          return [this.encodeAsString(obj)];
      }
      /**
       * Encode packet as string.
       */
      encodeAsString(obj) {
          // first is type
          let str = "" + obj.type;
          // attachments if we have them
          if (obj.type === PacketType.BINARY_EVENT ||
              obj.type === PacketType.BINARY_ACK) {
              str += obj.attachments + "-";
          }
          // if we have a namespace other than `/`
          // we append it followed by a comma `,`
          if (obj.nsp && "/" !== obj.nsp) {
              str += obj.nsp + ",";
          }
          // immediately followed by the id
          if (null != obj.id) {
              str += obj.id;
          }
          // json data
          if (null != obj.data) {
              str += JSON.stringify(obj.data);
          }
          return str;
      }
      /**
       * Encode packet as 'buffer sequence' by removing blobs, and
       * deconstructing packet into object with placeholders and
       * a list of buffers.
       */
      encodeAsBinary(obj) {
          const deconstruction = deconstructPacket(obj);
          const pack = this.encodeAsString(deconstruction.packet);
          const buffers = deconstruction.buffers;
          buffers.unshift(pack); // add packet info to beginning of data list
          return buffers; // write all the buffers
      }
  }
  /**
   * A socket.io Decoder instance
   *
   * @return {Object} decoder
   */
  class Decoder extends Emitter_1 {
      constructor() {
          super();
      }
      /**
       * Decodes an encoded packet string into packet JSON.
       *
       * @param {String} obj - encoded packet
       */
      add(obj) {
          let packet;
          if (typeof obj === "string") {
              packet = this.decodeString(obj);
              if (packet.type === PacketType.BINARY_EVENT ||
                  packet.type === PacketType.BINARY_ACK) {
                  // binary packet's json
                  this.reconstructor = new BinaryReconstructor(packet);
                  // no attachments, labeled binary but no binary data to follow
                  if (packet.attachments === 0) {
                      super.emitReserved("decoded", packet);
                  }
              }
              else {
                  // non-binary full packet
                  super.emitReserved("decoded", packet);
              }
          }
          else if (isBinary(obj) || obj.base64) {
              // raw binary data
              if (!this.reconstructor) {
                  throw new Error("got binary data when not reconstructing a packet");
              }
              else {
                  packet = this.reconstructor.takeBinaryData(obj);
                  if (packet) {
                      // received final buffer
                      this.reconstructor = null;
                      super.emitReserved("decoded", packet);
                  }
              }
          }
          else {
              throw new Error("Unknown type: " + obj);
          }
      }
      /**
       * Decode a packet String (JSON data)
       *
       * @param {String} str
       * @return {Object} packet
       */
      decodeString(str) {
          let i = 0;
          // look up type
          const p = {
              type: Number(str.charAt(0)),
          };
          if (PacketType[p.type] === undefined) {
              throw new Error("unknown packet type " + p.type);
          }
          // look up attachments if type binary
          if (p.type === PacketType.BINARY_EVENT ||
              p.type === PacketType.BINARY_ACK) {
              const start = i + 1;
              while (str.charAt(++i) !== "-" && i != str.length) { }
              const buf = str.substring(start, i);
              if (buf != Number(buf) || str.charAt(i) !== "-") {
                  throw new Error("Illegal attachments");
              }
              p.attachments = Number(buf);
          }
          // look up namespace (if any)
          if ("/" === str.charAt(i + 1)) {
              const start = i + 1;
              while (++i) {
                  const c = str.charAt(i);
                  if ("," === c)
                      break;
                  if (i === str.length)
                      break;
              }
              p.nsp = str.substring(start, i);
          }
          else {
              p.nsp = "/";
          }
          // look up id
          const next = str.charAt(i + 1);
          if ("" !== next && Number(next) == next) {
              const start = i + 1;
              while (++i) {
                  const c = str.charAt(i);
                  if (null == c || Number(c) != c) {
                      --i;
                      break;
                  }
                  if (i === str.length)
                      break;
              }
              p.id = Number(str.substring(start, i + 1));
          }
          // look up json data
          if (str.charAt(++i)) {
              const payload = tryParse(str.substr(i));
              if (Decoder.isPayloadValid(p.type, payload)) {
                  p.data = payload;
              }
              else {
                  throw new Error("invalid payload");
              }
          }
          return p;
      }
      static isPayloadValid(type, payload) {
          switch (type) {
              case PacketType.CONNECT:
                  return typeof payload === "object";
              case PacketType.DISCONNECT:
                  return payload === undefined;
              case PacketType.CONNECT_ERROR:
                  return typeof payload === "string" || typeof payload === "object";
              case PacketType.EVENT:
              case PacketType.BINARY_EVENT:
                  return Array.isArray(payload) && payload.length > 0;
              case PacketType.ACK:
              case PacketType.BINARY_ACK:
                  return Array.isArray(payload);
          }
      }
      /**
       * Deallocates a parser's resources
       */
      destroy() {
          if (this.reconstructor) {
              this.reconstructor.finishedReconstruction();
          }
      }
  }
  function tryParse(str) {
      try {
          return JSON.parse(str);
      }
      catch (e) {
          return false;
      }
  }
  /**
   * A manager of a binary event's 'buffer sequence'. Should
   * be constructed whenever a packet of type BINARY_EVENT is
   * decoded.
   *
   * @param {Object} packet
   * @return {BinaryReconstructor} initialized reconstructor
   */
  class BinaryReconstructor {
      constructor(packet) {
          this.packet = packet;
          this.buffers = [];
          this.reconPack = packet;
      }
      /**
       * Method to be called when binary data received from connection
       * after a BINARY_EVENT packet.
       *
       * @param {Buffer | ArrayBuffer} binData - the raw binary data received
       * @return {null | Object} returns null if more binary data is expected or
       *   a reconstructed packet object if all buffers have been received.
       */
      takeBinaryData(binData) {
          this.buffers.push(binData);
          if (this.buffers.length === this.reconPack.attachments) {
              // done with buffer list
              const packet = reconstructPacket(this.reconPack, this.buffers);
              this.finishedReconstruction();
              return packet;
          }
          return null;
      }
      /**
       * Cleans up binary packet reconstruction variables.
       */
      finishedReconstruction() {
          this.reconPack = null;
          this.buffers = [];
      }
  }

  var parser = {
    __proto__: null,
    protocol: protocol,
    get PacketType () { return PacketType; },
    Encoder: Encoder,
    Decoder: Decoder
  };

  function on(obj, ev, fn) {
      obj.on(ev, fn);
      return function subDestroy() {
          obj.off(ev, fn);
      };
  }

  /**
   * Internal events.
   * These events can't be emitted by the user.
   */
  const RESERVED_EVENTS = Object.freeze({
      connect: 1,
      connect_error: 1,
      disconnect: 1,
      disconnecting: 1,
      // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
      newListener: 1,
      removeListener: 1,
  });
  class Socket extends Emitter_1 {
      /**
       * `Socket` constructor.
       *
       * @public
       */
      constructor(io, nsp, opts) {
          super();
          this.connected = false;
          this.disconnected = true;
          this.receiveBuffer = [];
          this.sendBuffer = [];
          this.ids = 0;
          this.acks = {};
          this.flags = {};
          this.io = io;
          this.nsp = nsp;
          if (opts && opts.auth) {
              this.auth = opts.auth;
          }
          if (this.io._autoConnect)
              this.open();
      }
      /**
       * Subscribe to open, close and packet events
       *
       * @private
       */
      subEvents() {
          if (this.subs)
              return;
          const io = this.io;
          this.subs = [
              on(io, "open", this.onopen.bind(this)),
              on(io, "packet", this.onpacket.bind(this)),
              on(io, "error", this.onerror.bind(this)),
              on(io, "close", this.onclose.bind(this)),
          ];
      }
      /**
       * Whether the Socket will try to reconnect when its Manager connects or reconnects
       */
      get active() {
          return !!this.subs;
      }
      /**
       * "Opens" the socket.
       *
       * @public
       */
      connect() {
          if (this.connected)
              return this;
          this.subEvents();
          if (!this.io["_reconnecting"])
              this.io.open(); // ensure open
          if ("open" === this.io._readyState)
              this.onopen();
          return this;
      }
      /**
       * Alias for connect()
       */
      open() {
          return this.connect();
      }
      /**
       * Sends a `message` event.
       *
       * @return self
       * @public
       */
      send(...args) {
          args.unshift("message");
          this.emit.apply(this, args);
          return this;
      }
      /**
       * Override `emit`.
       * If the event is in `events`, it's emitted normally.
       *
       * @return self
       * @public
       */
      emit(ev, ...args) {
          if (RESERVED_EVENTS.hasOwnProperty(ev)) {
              throw new Error('"' + ev + '" is a reserved event name');
          }
          args.unshift(ev);
          const packet = {
              type: PacketType.EVENT,
              data: args,
          };
          packet.options = {};
          packet.options.compress = this.flags.compress !== false;
          // event ack callback
          if ("function" === typeof args[args.length - 1]) {
              const id = this.ids++;
              const ack = args.pop();
              this._registerAckCallback(id, ack);
              packet.id = id;
          }
          const isTransportWritable = this.io.engine &&
              this.io.engine.transport &&
              this.io.engine.transport.writable;
          const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
          if (discardPacket) ;
          else if (this.connected) {
              this.packet(packet);
          }
          else {
              this.sendBuffer.push(packet);
          }
          this.flags = {};
          return this;
      }
      /**
       * @private
       */
      _registerAckCallback(id, ack) {
          const timeout = this.flags.timeout;
          if (timeout === undefined) {
              this.acks[id] = ack;
              return;
          }
          // @ts-ignore
          const timer = this.io.setTimeoutFn(() => {
              delete this.acks[id];
              for (let i = 0; i < this.sendBuffer.length; i++) {
                  if (this.sendBuffer[i].id === id) {
                      this.sendBuffer.splice(i, 1);
                  }
              }
              ack.call(this, new Error("operation has timed out"));
          }, timeout);
          this.acks[id] = (...args) => {
              // @ts-ignore
              this.io.clearTimeoutFn(timer);
              ack.apply(this, [null, ...args]);
          };
      }
      /**
       * Sends a packet.
       *
       * @param packet
       * @private
       */
      packet(packet) {
          packet.nsp = this.nsp;
          this.io._packet(packet);
      }
      /**
       * Called upon engine `open`.
       *
       * @private
       */
      onopen() {
          if (typeof this.auth == "function") {
              this.auth((data) => {
                  this.packet({ type: PacketType.CONNECT, data });
              });
          }
          else {
              this.packet({ type: PacketType.CONNECT, data: this.auth });
          }
      }
      /**
       * Called upon engine or manager `error`.
       *
       * @param err
       * @private
       */
      onerror(err) {
          if (!this.connected) {
              this.emitReserved("connect_error", err);
          }
      }
      /**
       * Called upon engine `close`.
       *
       * @param reason
       * @private
       */
      onclose(reason) {
          this.connected = false;
          this.disconnected = true;
          delete this.id;
          this.emitReserved("disconnect", reason);
      }
      /**
       * Called with socket packet.
       *
       * @param packet
       * @private
       */
      onpacket(packet) {
          const sameNamespace = packet.nsp === this.nsp;
          if (!sameNamespace)
              return;
          switch (packet.type) {
              case PacketType.CONNECT:
                  if (packet.data && packet.data.sid) {
                      const id = packet.data.sid;
                      this.onconnect(id);
                  }
                  else {
                      this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                  }
                  break;
              case PacketType.EVENT:
                  this.onevent(packet);
                  break;
              case PacketType.BINARY_EVENT:
                  this.onevent(packet);
                  break;
              case PacketType.ACK:
                  this.onack(packet);
                  break;
              case PacketType.BINARY_ACK:
                  this.onack(packet);
                  break;
              case PacketType.DISCONNECT:
                  this.ondisconnect();
                  break;
              case PacketType.CONNECT_ERROR:
                  this.destroy();
                  const err = new Error(packet.data.message);
                  // @ts-ignore
                  err.data = packet.data.data;
                  this.emitReserved("connect_error", err);
                  break;
          }
      }
      /**
       * Called upon a server event.
       *
       * @param packet
       * @private
       */
      onevent(packet) {
          const args = packet.data || [];
          if (null != packet.id) {
              args.push(this.ack(packet.id));
          }
          if (this.connected) {
              this.emitEvent(args);
          }
          else {
              this.receiveBuffer.push(Object.freeze(args));
          }
      }
      emitEvent(args) {
          if (this._anyListeners && this._anyListeners.length) {
              const listeners = this._anyListeners.slice();
              for (const listener of listeners) {
                  listener.apply(this, args);
              }
          }
          super.emit.apply(this, args);
      }
      /**
       * Produces an ack callback to emit with an event.
       *
       * @private
       */
      ack(id) {
          const self = this;
          let sent = false;
          return function (...args) {
              // prevent double callbacks
              if (sent)
                  return;
              sent = true;
              self.packet({
                  type: PacketType.ACK,
                  id: id,
                  data: args,
              });
          };
      }
      /**
       * Called upon a server acknowlegement.
       *
       * @param packet
       * @private
       */
      onack(packet) {
          const ack = this.acks[packet.id];
          if ("function" === typeof ack) {
              ack.apply(this, packet.data);
              delete this.acks[packet.id];
          }
      }
      /**
       * Called upon server connect.
       *
       * @private
       */
      onconnect(id) {
          this.id = id;
          this.connected = true;
          this.disconnected = false;
          this.emitBuffered();
          this.emitReserved("connect");
      }
      /**
       * Emit buffered events (received and emitted).
       *
       * @private
       */
      emitBuffered() {
          this.receiveBuffer.forEach((args) => this.emitEvent(args));
          this.receiveBuffer = [];
          this.sendBuffer.forEach((packet) => this.packet(packet));
          this.sendBuffer = [];
      }
      /**
       * Called upon server disconnect.
       *
       * @private
       */
      ondisconnect() {
          this.destroy();
          this.onclose("io server disconnect");
      }
      /**
       * Called upon forced client/server side disconnections,
       * this method ensures the manager stops tracking us and
       * that reconnections don't get triggered for this.
       *
       * @private
       */
      destroy() {
          if (this.subs) {
              // clean subscriptions to avoid reconnections
              this.subs.forEach((subDestroy) => subDestroy());
              this.subs = undefined;
          }
          this.io["_destroy"](this);
      }
      /**
       * Disconnects the socket manually.
       *
       * @return self
       * @public
       */
      disconnect() {
          if (this.connected) {
              this.packet({ type: PacketType.DISCONNECT });
          }
          // remove socket from pool
          this.destroy();
          if (this.connected) {
              // fire events
              this.onclose("io client disconnect");
          }
          return this;
      }
      /**
       * Alias for disconnect()
       *
       * @return self
       * @public
       */
      close() {
          return this.disconnect();
      }
      /**
       * Sets the compress flag.
       *
       * @param compress - if `true`, compresses the sending data
       * @return self
       * @public
       */
      compress(compress) {
          this.flags.compress = compress;
          return this;
      }
      /**
       * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
       * ready to send messages.
       *
       * @returns self
       * @public
       */
      get volatile() {
          this.flags.volatile = true;
          return this;
      }
      /**
       * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
       * given number of milliseconds have elapsed without an acknowledgement from the server:
       *
       * ```
       * socket.timeout(5000).emit("my-event", (err) => {
       *   if (err) {
       *     // the server did not acknowledge the event in the given delay
       *   }
       * });
       * ```
       *
       * @returns self
       * @public
       */
      timeout(timeout) {
          this.flags.timeout = timeout;
          return this;
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback.
       *
       * @param listener
       * @public
       */
      onAny(listener) {
          this._anyListeners = this._anyListeners || [];
          this._anyListeners.push(listener);
          return this;
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback. The listener is added to the beginning of the listeners array.
       *
       * @param listener
       * @public
       */
      prependAny(listener) {
          this._anyListeners = this._anyListeners || [];
          this._anyListeners.unshift(listener);
          return this;
      }
      /**
       * Removes the listener that will be fired when any event is emitted.
       *
       * @param listener
       * @public
       */
      offAny(listener) {
          if (!this._anyListeners) {
              return this;
          }
          if (listener) {
              const listeners = this._anyListeners;
              for (let i = 0; i < listeners.length; i++) {
                  if (listener === listeners[i]) {
                      listeners.splice(i, 1);
                      return this;
                  }
              }
          }
          else {
              this._anyListeners = [];
          }
          return this;
      }
      /**
       * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
       * e.g. to remove listeners.
       *
       * @public
       */
      listenersAny() {
          return this._anyListeners || [];
      }
  }

  /**
   * Expose `Backoff`.
   */

  var backo2 = Backoff;

  /**
   * Initialize backoff timer with `opts`.
   *
   * - `min` initial timeout in milliseconds [100]
   * - `max` max timeout [10000]
   * - `jitter` [0]
   * - `factor` [2]
   *
   * @param {Object} opts
   * @api public
   */

  function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 10000;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
    this.attempts = 0;
  }

  /**
   * Return the backoff duration.
   *
   * @return {Number}
   * @api public
   */

  Backoff.prototype.duration = function(){
    var ms = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
      var rand =  Math.random();
      var deviation = Math.floor(rand * this.jitter * ms);
      ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
    }
    return Math.min(ms, this.max) | 0;
  };

  /**
   * Reset the number of attempts.
   *
   * @api public
   */

  Backoff.prototype.reset = function(){
    this.attempts = 0;
  };

  /**
   * Set the minimum duration
   *
   * @api public
   */

  Backoff.prototype.setMin = function(min){
    this.ms = min;
  };

  /**
   * Set the maximum duration
   *
   * @api public
   */

  Backoff.prototype.setMax = function(max){
    this.max = max;
  };

  /**
   * Set the jitter
   *
   * @api public
   */

  Backoff.prototype.setJitter = function(jitter){
    this.jitter = jitter;
  };

  class Manager extends Emitter_1 {
      constructor(uri, opts) {
          var _a;
          super();
          this.nsps = {};
          this.subs = [];
          if (uri && "object" === typeof uri) {
              opts = uri;
              uri = undefined;
          }
          opts = opts || {};
          opts.path = opts.path || "/socket.io";
          this.opts = opts;
          installTimerFunctions(this, opts);
          this.reconnection(opts.reconnection !== false);
          this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
          this.reconnectionDelay(opts.reconnectionDelay || 1000);
          this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
          this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
          this.backoff = new backo2({
              min: this.reconnectionDelay(),
              max: this.reconnectionDelayMax(),
              jitter: this.randomizationFactor(),
          });
          this.timeout(null == opts.timeout ? 20000 : opts.timeout);
          this._readyState = "closed";
          this.uri = uri;
          const _parser = opts.parser || parser;
          this.encoder = new _parser.Encoder();
          this.decoder = new _parser.Decoder();
          this._autoConnect = opts.autoConnect !== false;
          if (this._autoConnect)
              this.open();
      }
      reconnection(v) {
          if (!arguments.length)
              return this._reconnection;
          this._reconnection = !!v;
          return this;
      }
      reconnectionAttempts(v) {
          if (v === undefined)
              return this._reconnectionAttempts;
          this._reconnectionAttempts = v;
          return this;
      }
      reconnectionDelay(v) {
          var _a;
          if (v === undefined)
              return this._reconnectionDelay;
          this._reconnectionDelay = v;
          (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
          return this;
      }
      randomizationFactor(v) {
          var _a;
          if (v === undefined)
              return this._randomizationFactor;
          this._randomizationFactor = v;
          (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
          return this;
      }
      reconnectionDelayMax(v) {
          var _a;
          if (v === undefined)
              return this._reconnectionDelayMax;
          this._reconnectionDelayMax = v;
          (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
          return this;
      }
      timeout(v) {
          if (!arguments.length)
              return this._timeout;
          this._timeout = v;
          return this;
      }
      /**
       * Starts trying to reconnect if reconnection is enabled and we have not
       * started reconnecting yet
       *
       * @private
       */
      maybeReconnectOnOpen() {
          // Only try to reconnect if it's the first time we're connecting
          if (!this._reconnecting &&
              this._reconnection &&
              this.backoff.attempts === 0) {
              // keeps reconnection from firing twice for the same reconnection loop
              this.reconnect();
          }
      }
      /**
       * Sets the current transport `socket`.
       *
       * @param {Function} fn - optional, callback
       * @return self
       * @public
       */
      open(fn) {
          if (~this._readyState.indexOf("open"))
              return this;
          this.engine = new Socket$1(this.uri, this.opts);
          const socket = this.engine;
          const self = this;
          this._readyState = "opening";
          this.skipReconnect = false;
          // emit `open`
          const openSubDestroy = on(socket, "open", function () {
              self.onopen();
              fn && fn();
          });
          // emit `error`
          const errorSub = on(socket, "error", (err) => {
              self.cleanup();
              self._readyState = "closed";
              this.emitReserved("error", err);
              if (fn) {
                  fn(err);
              }
              else {
                  // Only do this if there is no fn to handle the error
                  self.maybeReconnectOnOpen();
              }
          });
          if (false !== this._timeout) {
              const timeout = this._timeout;
              if (timeout === 0) {
                  openSubDestroy(); // prevents a race condition with the 'open' event
              }
              // set timer
              const timer = this.setTimeoutFn(() => {
                  openSubDestroy();
                  socket.close();
                  // @ts-ignore
                  socket.emit("error", new Error("timeout"));
              }, timeout);
              if (this.opts.autoUnref) {
                  timer.unref();
              }
              this.subs.push(function subDestroy() {
                  clearTimeout(timer);
              });
          }
          this.subs.push(openSubDestroy);
          this.subs.push(errorSub);
          return this;
      }
      /**
       * Alias for open()
       *
       * @return self
       * @public
       */
      connect(fn) {
          return this.open(fn);
      }
      /**
       * Called upon transport open.
       *
       * @private
       */
      onopen() {
          // clear old subs
          this.cleanup();
          // mark as open
          this._readyState = "open";
          this.emitReserved("open");
          // add new subs
          const socket = this.engine;
          this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
      }
      /**
       * Called upon a ping.
       *
       * @private
       */
      onping() {
          this.emitReserved("ping");
      }
      /**
       * Called with data.
       *
       * @private
       */
      ondata(data) {
          this.decoder.add(data);
      }
      /**
       * Called when parser fully decodes a packet.
       *
       * @private
       */
      ondecoded(packet) {
          this.emitReserved("packet", packet);
      }
      /**
       * Called upon socket error.
       *
       * @private
       */
      onerror(err) {
          this.emitReserved("error", err);
      }
      /**
       * Creates a new socket for the given `nsp`.
       *
       * @return {Socket}
       * @public
       */
      socket(nsp, opts) {
          let socket = this.nsps[nsp];
          if (!socket) {
              socket = new Socket(this, nsp, opts);
              this.nsps[nsp] = socket;
          }
          return socket;
      }
      /**
       * Called upon a socket close.
       *
       * @param socket
       * @private
       */
      _destroy(socket) {
          const nsps = Object.keys(this.nsps);
          for (const nsp of nsps) {
              const socket = this.nsps[nsp];
              if (socket.active) {
                  return;
              }
          }
          this._close();
      }
      /**
       * Writes a packet.
       *
       * @param packet
       * @private
       */
      _packet(packet) {
          const encodedPackets = this.encoder.encode(packet);
          for (let i = 0; i < encodedPackets.length; i++) {
              this.engine.write(encodedPackets[i], packet.options);
          }
      }
      /**
       * Clean up transport subscriptions and packet buffer.
       *
       * @private
       */
      cleanup() {
          this.subs.forEach((subDestroy) => subDestroy());
          this.subs.length = 0;
          this.decoder.destroy();
      }
      /**
       * Close the current socket.
       *
       * @private
       */
      _close() {
          this.skipReconnect = true;
          this._reconnecting = false;
          this.onclose("forced close");
          if (this.engine)
              this.engine.close();
      }
      /**
       * Alias for close()
       *
       * @private
       */
      disconnect() {
          return this._close();
      }
      /**
       * Called upon engine close.
       *
       * @private
       */
      onclose(reason) {
          this.cleanup();
          this.backoff.reset();
          this._readyState = "closed";
          this.emitReserved("close", reason);
          if (this._reconnection && !this.skipReconnect) {
              this.reconnect();
          }
      }
      /**
       * Attempt a reconnection.
       *
       * @private
       */
      reconnect() {
          if (this._reconnecting || this.skipReconnect)
              return this;
          const self = this;
          if (this.backoff.attempts >= this._reconnectionAttempts) {
              this.backoff.reset();
              this.emitReserved("reconnect_failed");
              this._reconnecting = false;
          }
          else {
              const delay = this.backoff.duration();
              this._reconnecting = true;
              const timer = this.setTimeoutFn(() => {
                  if (self.skipReconnect)
                      return;
                  this.emitReserved("reconnect_attempt", self.backoff.attempts);
                  // check again for the case socket closed in above events
                  if (self.skipReconnect)
                      return;
                  self.open((err) => {
                      if (err) {
                          self._reconnecting = false;
                          self.reconnect();
                          this.emitReserved("reconnect_error", err);
                      }
                      else {
                          self.onreconnect();
                      }
                  });
              }, delay);
              if (this.opts.autoUnref) {
                  timer.unref();
              }
              this.subs.push(function subDestroy() {
                  clearTimeout(timer);
              });
          }
      }
      /**
       * Called upon successful reconnect.
       *
       * @private
       */
      onreconnect() {
          const attempt = this.backoff.attempts;
          this._reconnecting = false;
          this.backoff.reset();
          this.emitReserved("reconnect", attempt);
      }
  }

  /**
   * Managers cache.
   */
  const cache = {};
  function lookup(uri, opts) {
      if (typeof uri === "object") {
          opts = uri;
          uri = undefined;
      }
      opts = opts || {};
      const parsed = url(uri, opts.path || "/socket.io");
      const source = parsed.source;
      const id = parsed.id;
      const path = parsed.path;
      const sameNamespace = cache[id] && path in cache[id]["nsps"];
      const newConnection = opts.forceNew ||
          opts["force new connection"] ||
          false === opts.multiplex ||
          sameNamespace;
      let io;
      if (newConnection) {
          io = new Manager(source, opts);
      }
      else {
          if (!cache[id]) {
              cache[id] = new Manager(source, opts);
          }
          io = cache[id];
      }
      if (parsed.query && !opts.query) {
          opts.query = parsed.queryKey;
      }
      return io.socket(parsed.path, opts);
  }
  // so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
  // namespace (e.g. `io.connect(...)`), for backward compatibility
  Object.assign(lookup, {
      Manager,
      Socket,
      io: lookup,
      connect: lookup,
  });

  function getWsUrl(url) {
    var urlObj;

    try {
      urlObj = new URL(url);

      if (!urlObj.protocol || !urlObj.host) {
        throw new TypeError("[ERR_INVALID_URL]: Invalid URL: " + url);
      }
    } catch (error) {
      console.error("Pass an absolute URL with a protocol/schema, e.g. \"wss://example.com\"");
      throw error;
    }

    return urlObj;
  }

  var StacksApiSocketClient = /*#__PURE__*/function () {
    function StacksApiSocketClient(socket) {
      this.socket = void 0;
      this.socket = socket;
    }

    StacksApiSocketClient.connect = function connect(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          _ref$url = _ref.url,
          url = _ref$url === void 0 ? BASE_PATH : _ref$url,
          _ref$subscriptions = _ref.subscriptions,
          subscriptions = _ref$subscriptions === void 0 ? [] : _ref$subscriptions;

      var socket = lookup(getWsUrl(url).href, {
        query: {
          // Subscriptions can be specified on init using this handshake query param.
          subscriptions: Array.from(new Set(subscriptions)).join(',')
        }
      });
      return new StacksApiSocketClient(socket);
    };

    var _proto = StacksApiSocketClient.prototype;

    _proto.handleSubscription = function handleSubscription(topic, subscribe) {
      var _this$socket$io$opts$,
          _this$socket$io$opts$2,
          _this = this;

      if (subscribe === void 0) {
        subscribe = false;
      }

      var subscriptions = new Set((_this$socket$io$opts$ = (_this$socket$io$opts$2 = this.socket.io.opts.query) == null ? void 0 : _this$socket$io$opts$2.subscriptions.split(',')) != null ? _this$socket$io$opts$ : []);

      if (subscribe) {
        this.socket.emit('subscribe', topic, function (error) {
          if (error) console.error("Error subscribing: " + error);
        });
        subscriptions.add(topic);
      } else {
        this.socket.emit('unsubscribe', topic);
        subscriptions["delete"](topic);
      } // Update the subscriptions in the socket handshake so topics are persisted on re-connect.


      if (this.socket.io.opts.query === undefined) {
        this.socket.io.opts.query = {};
      }

      this.socket.io.opts.query.subscriptions = Array.from(subscriptions).join(',');
      return {
        unsubscribe: function unsubscribe() {
          _this.handleSubscription(topic, false);
        }
      };
    };

    _proto.subscribeBlocks = function subscribeBlocks() {
      return this.handleSubscription('block', true);
    };

    _proto.unsubscribeBlocks = function unsubscribeBlocks() {
      this.handleSubscription('block', false);
    };

    _proto.subscribeMicroblocks = function subscribeMicroblocks() {
      return this.handleSubscription('microblock', true);
    };

    _proto.unsubscribeMicroblocks = function unsubscribeMicroblocks() {
      this.handleSubscription('microblock', false);
    };

    _proto.subscribeMempool = function subscribeMempool() {
      return this.handleSubscription('mempool', true);
    };

    _proto.unsubscribeMempool = function unsubscribeMempool() {
      this.handleSubscription('mempool', false);
    };

    _proto.subscribeAddressTransactions = function subscribeAddressTransactions(address) {
      return this.handleSubscription("address-transaction:" + address, true);
    };

    _proto.unsubscribeAddressTransactions = function unsubscribeAddressTransactions(address) {
      this.handleSubscription("address-transaction:" + address, false);
    };

    _proto.subscribeAddressStxBalance = function subscribeAddressStxBalance(address) {
      return this.handleSubscription("address-stx-balance:" + address, true);
    };

    _proto.unsubscribeAddressStxBalance = function unsubscribeAddressStxBalance(address) {
      this.handleSubscription("address-stx-balance:" + address, false);
    };

    _proto.subscribeTransaction = function subscribeTransaction(txId) {
      return this.handleSubscription("transaction:" + txId, true);
    };

    _proto.unsubscribeTransaction = function unsubscribeTransaction(txId) {
      this.handleSubscription("transaction:" + txId, false);
    };

    _proto.subscribeNftEvent = function subscribeNftEvent() {
      return this.handleSubscription('nft-event', true);
    };

    _proto.unsubscribeNftEvent = function unsubscribeNftEvent() {
      this.handleSubscription('nft-event', false);
    };

    _proto.subscribeNftAssetEvent = function subscribeNftAssetEvent(assetIdentifier, value) {
      return this.handleSubscription("nft-asset-event:" + assetIdentifier + "+" + value, true);
    };

    _proto.unsubscribeNftAssetEvent = function unsubscribeNftAssetEvent(assetIdentifier, value) {
      this.handleSubscription("nft-asset-event:" + assetIdentifier + "+" + value, false);
    };

    _proto.subscribeNftCollectionEvent = function subscribeNftCollectionEvent(assetIdentifier) {
      return this.handleSubscription("nft-collection-event:" + assetIdentifier, true);
    };

    _proto.unsubscribeNftCollectionEvent = function unsubscribeNftCollectionEvent(assetIdentifier) {
      this.handleSubscription("nft-collection-event:" + assetIdentifier, false);
    };

    _proto.logEvents = function logEvents() {
      this.socket.on('connect', function () {
        return console.log('socket connected');
      });
      this.socket.on('disconnect', function (reason) {
        return console.warn('disconnected', reason);
      });
      this.socket.on('connect_error', function (error) {
        return console.error('connect_error', error);
      });
      this.socket.on('block', function (block) {
        return console.log('block', block);
      });
      this.socket.on('microblock', function (microblock) {
        return console.log('microblock', microblock);
      });
      this.socket.on('mempool', function (tx) {
        return console.log('mempool', tx);
      });
      this.socket.on('address-transaction', function (address, data) {
        return console.log('address-transaction', address, data);
      });
      this.socket.on('address-stx-balance', function (address, data) {
        return console.log('address-stx-balance', address, data);
      });
      this.socket.on('nft-event', function (event) {
        return console.log('nft-event', event);
      });
      this.socket.on('nft-asset-event', function (assetIdentifier, value, event) {
        return console.log('nft-asset-event', assetIdentifier, value, event);
      });
      this.socket.on('nft-collection-event', function (assetIdentifier, event) {
        return console.log('nft-collection-event', assetIdentifier, event);
      });
    };

    return StacksApiSocketClient;
  }();

  exports.AccountDataResponseFromJSON = AccountDataResponseFromJSON;
  exports.AccountDataResponseFromJSONTyped = AccountDataResponseFromJSONTyped;
  exports.AccountDataResponseToJSON = AccountDataResponseToJSON;
  exports.AccountsApi = AccountsApi;
  exports.AddressAssetsListResponseFromJSON = AddressAssetsListResponseFromJSON;
  exports.AddressAssetsListResponseFromJSONTyped = AddressAssetsListResponseFromJSONTyped;
  exports.AddressAssetsListResponseToJSON = AddressAssetsListResponseToJSON;
  exports.AddressBalanceResponseFromJSON = AddressBalanceResponseFromJSON;
  exports.AddressBalanceResponseFromJSONTyped = AddressBalanceResponseFromJSONTyped;
  exports.AddressBalanceResponseToJSON = AddressBalanceResponseToJSON;
  exports.AddressNftListResponseFromJSON = AddressNftListResponseFromJSON;
  exports.AddressNftListResponseFromJSONTyped = AddressNftListResponseFromJSONTyped;
  exports.AddressNftListResponseToJSON = AddressNftListResponseToJSON;
  exports.AddressNftListResponseValueFromJSON = AddressNftListResponseValueFromJSON;
  exports.AddressNftListResponseValueFromJSONTyped = AddressNftListResponseValueFromJSONTyped;
  exports.AddressNftListResponseValueToJSON = AddressNftListResponseValueToJSON;
  exports.AddressNoncesFromJSON = AddressNoncesFromJSON;
  exports.AddressNoncesFromJSONTyped = AddressNoncesFromJSONTyped;
  exports.AddressNoncesToJSON = AddressNoncesToJSON;
  exports.AddressStxInboundListResponseFromJSON = AddressStxInboundListResponseFromJSON;
  exports.AddressStxInboundListResponseFromJSONTyped = AddressStxInboundListResponseFromJSONTyped;
  exports.AddressStxInboundListResponseToJSON = AddressStxInboundListResponseToJSON;
  exports.AddressTokenOfferingLockedFromJSON = AddressTokenOfferingLockedFromJSON;
  exports.AddressTokenOfferingLockedFromJSONTyped = AddressTokenOfferingLockedFromJSONTyped;
  exports.AddressTokenOfferingLockedToJSON = AddressTokenOfferingLockedToJSON;
  exports.AddressTransactionWithTransfersFromJSON = AddressTransactionWithTransfersFromJSON;
  exports.AddressTransactionWithTransfersFromJSONTyped = AddressTransactionWithTransfersFromJSONTyped;
  exports.AddressTransactionWithTransfersFtTransfersFromJSON = AddressTransactionWithTransfersFtTransfersFromJSON;
  exports.AddressTransactionWithTransfersFtTransfersFromJSONTyped = AddressTransactionWithTransfersFtTransfersFromJSONTyped;
  exports.AddressTransactionWithTransfersFtTransfersToJSON = AddressTransactionWithTransfersFtTransfersToJSON;
  exports.AddressTransactionWithTransfersNftTransfersFromJSON = AddressTransactionWithTransfersNftTransfersFromJSON;
  exports.AddressTransactionWithTransfersNftTransfersFromJSONTyped = AddressTransactionWithTransfersNftTransfersFromJSONTyped;
  exports.AddressTransactionWithTransfersNftTransfersToJSON = AddressTransactionWithTransfersNftTransfersToJSON;
  exports.AddressTransactionWithTransfersStxTransfersFromJSON = AddressTransactionWithTransfersStxTransfersFromJSON;
  exports.AddressTransactionWithTransfersStxTransfersFromJSONTyped = AddressTransactionWithTransfersStxTransfersFromJSONTyped;
  exports.AddressTransactionWithTransfersStxTransfersToJSON = AddressTransactionWithTransfersStxTransfersToJSON;
  exports.AddressTransactionWithTransfersToJSON = AddressTransactionWithTransfersToJSON;
  exports.AddressTransactionWithTransfersValueFromJSON = AddressTransactionWithTransfersValueFromJSON;
  exports.AddressTransactionWithTransfersValueFromJSONTyped = AddressTransactionWithTransfersValueFromJSONTyped;
  exports.AddressTransactionWithTransfersValueToJSON = AddressTransactionWithTransfersValueToJSON;
  exports.AddressTransactionsListResponseFromJSON = AddressTransactionsListResponseFromJSON;
  exports.AddressTransactionsListResponseFromJSONTyped = AddressTransactionsListResponseFromJSONTyped;
  exports.AddressTransactionsListResponseToJSON = AddressTransactionsListResponseToJSON;
  exports.AddressTransactionsWithTransfersListResponseFromJSON = AddressTransactionsWithTransfersListResponseFromJSON;
  exports.AddressTransactionsWithTransfersListResponseFromJSONTyped = AddressTransactionsWithTransfersListResponseFromJSONTyped;
  exports.AddressTransactionsWithTransfersListResponseToJSON = AddressTransactionsWithTransfersListResponseToJSON;
  exports.AddressUnlockScheduleFromJSON = AddressUnlockScheduleFromJSON;
  exports.AddressUnlockScheduleFromJSONTyped = AddressUnlockScheduleFromJSONTyped;
  exports.AddressUnlockScheduleToJSON = AddressUnlockScheduleToJSON;
  exports.BASE_PATH = BASE_PATH;
  exports.BaseAPI = BaseAPI;
  exports.BlobApiResponse = BlobApiResponse;
  exports.BlockFromJSON = BlockFromJSON;
  exports.BlockFromJSONTyped = BlockFromJSONTyped;
  exports.BlockListResponseFromJSON = BlockListResponseFromJSON;
  exports.BlockListResponseFromJSONTyped = BlockListResponseFromJSONTyped;
  exports.BlockListResponseToJSON = BlockListResponseToJSON;
  exports.BlockToJSON = BlockToJSON;
  exports.BlocksApi = BlocksApi;
  exports.BnsErrorFromJSON = BnsErrorFromJSON;
  exports.BnsErrorFromJSONTyped = BnsErrorFromJSONTyped;
  exports.BnsErrorToJSON = BnsErrorToJSON;
  exports.BnsGetAllNamespacesResponseFromJSON = BnsGetAllNamespacesResponseFromJSON;
  exports.BnsGetAllNamespacesResponseFromJSONTyped = BnsGetAllNamespacesResponseFromJSONTyped;
  exports.BnsGetAllNamespacesResponseToJSON = BnsGetAllNamespacesResponseToJSON;
  exports.BnsGetNameInfoResponseFromJSON = BnsGetNameInfoResponseFromJSON;
  exports.BnsGetNameInfoResponseFromJSONTyped = BnsGetNameInfoResponseFromJSONTyped;
  exports.BnsGetNameInfoResponseToJSON = BnsGetNameInfoResponseToJSON;
  exports.BnsGetNamePriceResponseFromJSON = BnsGetNamePriceResponseFromJSON;
  exports.BnsGetNamePriceResponseFromJSONTyped = BnsGetNamePriceResponseFromJSONTyped;
  exports.BnsGetNamePriceResponseToJSON = BnsGetNamePriceResponseToJSON;
  exports.BnsGetNamespacePriceResponseFromJSON = BnsGetNamespacePriceResponseFromJSON;
  exports.BnsGetNamespacePriceResponseFromJSONTyped = BnsGetNamespacePriceResponseFromJSONTyped;
  exports.BnsGetNamespacePriceResponseToJSON = BnsGetNamespacePriceResponseToJSON;
  exports.BnsNamesOwnByAddressResponseFromJSON = BnsNamesOwnByAddressResponseFromJSON;
  exports.BnsNamesOwnByAddressResponseFromJSONTyped = BnsNamesOwnByAddressResponseFromJSONTyped;
  exports.BnsNamesOwnByAddressResponseToJSON = BnsNamesOwnByAddressResponseToJSON;
  exports.BurnchainRewardFromJSON = BurnchainRewardFromJSON;
  exports.BurnchainRewardFromJSONTyped = BurnchainRewardFromJSONTyped;
  exports.BurnchainRewardListResponseFromJSON = BurnchainRewardListResponseFromJSON;
  exports.BurnchainRewardListResponseFromJSONTyped = BurnchainRewardListResponseFromJSONTyped;
  exports.BurnchainRewardListResponseToJSON = BurnchainRewardListResponseToJSON;
  exports.BurnchainRewardSlotHolderFromJSON = BurnchainRewardSlotHolderFromJSON;
  exports.BurnchainRewardSlotHolderFromJSONTyped = BurnchainRewardSlotHolderFromJSONTyped;
  exports.BurnchainRewardSlotHolderListResponseFromJSON = BurnchainRewardSlotHolderListResponseFromJSON;
  exports.BurnchainRewardSlotHolderListResponseFromJSONTyped = BurnchainRewardSlotHolderListResponseFromJSONTyped;
  exports.BurnchainRewardSlotHolderListResponseToJSON = BurnchainRewardSlotHolderListResponseToJSON;
  exports.BurnchainRewardSlotHolderToJSON = BurnchainRewardSlotHolderToJSON;
  exports.BurnchainRewardToJSON = BurnchainRewardToJSON;
  exports.BurnchainRewardsTotalFromJSON = BurnchainRewardsTotalFromJSON;
  exports.BurnchainRewardsTotalFromJSONTyped = BurnchainRewardsTotalFromJSONTyped;
  exports.BurnchainRewardsTotalToJSON = BurnchainRewardsTotalToJSON;
  exports.COLLECTION_FORMATS = COLLECTION_FORMATS;
  exports.ChainTipFromJSON = ChainTipFromJSON;
  exports.ChainTipFromJSONTyped = ChainTipFromJSONTyped;
  exports.ChainTipToJSON = ChainTipToJSON;
  exports.Configuration = Configuration;
  exports.ContractInterfaceResponseFromJSON = ContractInterfaceResponseFromJSON;
  exports.ContractInterfaceResponseFromJSONTyped = ContractInterfaceResponseFromJSONTyped;
  exports.ContractInterfaceResponseToJSON = ContractInterfaceResponseToJSON;
  exports.ContractListResponseFromJSON = ContractListResponseFromJSON;
  exports.ContractListResponseFromJSONTyped = ContractListResponseFromJSONTyped;
  exports.ContractListResponseToJSON = ContractListResponseToJSON;
  exports.ContractSourceResponseFromJSON = ContractSourceResponseFromJSON;
  exports.ContractSourceResponseFromJSONTyped = ContractSourceResponseFromJSONTyped;
  exports.ContractSourceResponseToJSON = ContractSourceResponseToJSON;
  exports.CoreNodeInfoResponseFromJSON = CoreNodeInfoResponseFromJSON;
  exports.CoreNodeInfoResponseFromJSONTyped = CoreNodeInfoResponseFromJSONTyped;
  exports.CoreNodeInfoResponseToJSON = CoreNodeInfoResponseToJSON;
  exports.CoreNodePoxResponseFromJSON = CoreNodePoxResponseFromJSON;
  exports.CoreNodePoxResponseFromJSONTyped = CoreNodePoxResponseFromJSONTyped;
  exports.CoreNodePoxResponseToJSON = CoreNodePoxResponseToJSON;
  exports.FaucetsApi = FaucetsApi;
  exports.FeeRateFromJSON = FeeRateFromJSON;
  exports.FeeRateFromJSONTyped = FeeRateFromJSONTyped;
  exports.FeeRateRequestFromJSON = FeeRateRequestFromJSON;
  exports.FeeRateRequestFromJSONTyped = FeeRateRequestFromJSONTyped;
  exports.FeeRateRequestToJSON = FeeRateRequestToJSON;
  exports.FeeRateToJSON = FeeRateToJSON;
  exports.FeesApi = FeesApi;
  exports.FungibleTokenMetadataFromJSON = FungibleTokenMetadataFromJSON;
  exports.FungibleTokenMetadataFromJSONTyped = FungibleTokenMetadataFromJSONTyped;
  exports.FungibleTokenMetadataToJSON = FungibleTokenMetadataToJSON;
  exports.FungibleTokensApi = FungibleTokensApi;
  exports.FungibleTokensMetadataListFromJSON = FungibleTokensMetadataListFromJSON;
  exports.FungibleTokensMetadataListFromJSONTyped = FungibleTokensMetadataListFromJSONTyped;
  exports.FungibleTokensMetadataListToJSON = FungibleTokensMetadataListToJSON;
  exports.GetRawTransactionResultFromJSON = GetRawTransactionResultFromJSON;
  exports.GetRawTransactionResultFromJSONTyped = GetRawTransactionResultFromJSONTyped;
  exports.GetRawTransactionResultToJSON = GetRawTransactionResultToJSON;
  exports.GetStxSupplyLegacyFormatResponseFromJSON = GetStxSupplyLegacyFormatResponseFromJSON;
  exports.GetStxSupplyLegacyFormatResponseFromJSONTyped = GetStxSupplyLegacyFormatResponseFromJSONTyped;
  exports.GetStxSupplyLegacyFormatResponseToJSON = GetStxSupplyLegacyFormatResponseToJSON;
  exports.GetStxSupplyResponseFromJSON = GetStxSupplyResponseFromJSON;
  exports.GetStxSupplyResponseFromJSONTyped = GetStxSupplyResponseFromJSONTyped;
  exports.GetStxSupplyResponseToJSON = GetStxSupplyResponseToJSON;
  exports.InboundStxTransferFromJSON = InboundStxTransferFromJSON;
  exports.InboundStxTransferFromJSONTyped = InboundStxTransferFromJSONTyped;
  exports.InboundStxTransferToJSON = InboundStxTransferToJSON;
  exports.InfoApi = InfoApi;
  exports.InlineObject1FromJSON = InlineObject1FromJSON;
  exports.InlineObject1FromJSONTyped = InlineObject1FromJSONTyped;
  exports.InlineObject1ToJSON = InlineObject1ToJSON;
  exports.InlineObjectFromJSON = InlineObjectFromJSON;
  exports.InlineObjectFromJSONTyped = InlineObjectFromJSONTyped;
  exports.InlineObjectToJSON = InlineObjectToJSON;
  exports.JSONApiResponse = JSONApiResponse;
  exports.MapEntryResponseFromJSON = MapEntryResponseFromJSON;
  exports.MapEntryResponseFromJSONTyped = MapEntryResponseFromJSONTyped;
  exports.MapEntryResponseToJSON = MapEntryResponseToJSON;
  exports.MempoolTransactionListResponseFromJSON = MempoolTransactionListResponseFromJSON;
  exports.MempoolTransactionListResponseFromJSONTyped = MempoolTransactionListResponseFromJSONTyped;
  exports.MempoolTransactionListResponseToJSON = MempoolTransactionListResponseToJSON;
  exports.MempoolTransactionStatsResponseFromJSON = MempoolTransactionStatsResponseFromJSON;
  exports.MempoolTransactionStatsResponseFromJSONTyped = MempoolTransactionStatsResponseFromJSONTyped;
  exports.MempoolTransactionStatsResponseToJSON = MempoolTransactionStatsResponseToJSON;
  exports.MempoolTransactionStatsResponseTxAgesFromJSON = MempoolTransactionStatsResponseTxAgesFromJSON;
  exports.MempoolTransactionStatsResponseTxAgesFromJSONTyped = MempoolTransactionStatsResponseTxAgesFromJSONTyped;
  exports.MempoolTransactionStatsResponseTxAgesToJSON = MempoolTransactionStatsResponseTxAgesToJSON;
  exports.MempoolTransactionStatsResponseTxByteSizesFromJSON = MempoolTransactionStatsResponseTxByteSizesFromJSON;
  exports.MempoolTransactionStatsResponseTxByteSizesFromJSONTyped = MempoolTransactionStatsResponseTxByteSizesFromJSONTyped;
  exports.MempoolTransactionStatsResponseTxByteSizesToJSON = MempoolTransactionStatsResponseTxByteSizesToJSON;
  exports.MempoolTransactionStatsResponseTxSimpleFeeAveragesFromJSON = MempoolTransactionStatsResponseTxSimpleFeeAveragesFromJSON;
  exports.MempoolTransactionStatsResponseTxSimpleFeeAveragesFromJSONTyped = MempoolTransactionStatsResponseTxSimpleFeeAveragesFromJSONTyped;
  exports.MempoolTransactionStatsResponseTxSimpleFeeAveragesToJSON = MempoolTransactionStatsResponseTxSimpleFeeAveragesToJSON;
  exports.MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSON = MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSON;
  exports.MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSONTyped = MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferFromJSONTyped;
  exports.MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferToJSON = MempoolTransactionStatsResponseTxSimpleFeeAveragesTokenTransferToJSON;
  exports.MempoolTransactionStatsResponseTxTypeCountsFromJSON = MempoolTransactionStatsResponseTxTypeCountsFromJSON;
  exports.MempoolTransactionStatsResponseTxTypeCountsFromJSONTyped = MempoolTransactionStatsResponseTxTypeCountsFromJSONTyped;
  exports.MempoolTransactionStatsResponseTxTypeCountsToJSON = MempoolTransactionStatsResponseTxTypeCountsToJSON;
  exports.MicroblockFromJSON = MicroblockFromJSON;
  exports.MicroblockFromJSONTyped = MicroblockFromJSONTyped;
  exports.MicroblockListResponseFromJSON = MicroblockListResponseFromJSON;
  exports.MicroblockListResponseFromJSONTyped = MicroblockListResponseFromJSONTyped;
  exports.MicroblockListResponseToJSON = MicroblockListResponseToJSON;
  exports.MicroblockToJSON = MicroblockToJSON;
  exports.MicroblocksApi = MicroblocksApi;
  exports.NamesApi = NamesApi;
  exports.NetworkBlockTimeResponseFromJSON = NetworkBlockTimeResponseFromJSON;
  exports.NetworkBlockTimeResponseFromJSONTyped = NetworkBlockTimeResponseFromJSONTyped;
  exports.NetworkBlockTimeResponseToJSON = NetworkBlockTimeResponseToJSON;
  exports.NetworkBlockTimesResponseFromJSON = NetworkBlockTimesResponseFromJSON;
  exports.NetworkBlockTimesResponseFromJSONTyped = NetworkBlockTimesResponseFromJSONTyped;
  exports.NetworkBlockTimesResponseToJSON = NetworkBlockTimesResponseToJSON;
  exports.NetworkIdentifierFromJSON = NetworkIdentifierFromJSON;
  exports.NetworkIdentifierFromJSONTyped = NetworkIdentifierFromJSONTyped;
  exports.NetworkIdentifierToJSON = NetworkIdentifierToJSON;
  exports.NftEventFromJSON = NftEventFromJSON;
  exports.NftEventFromJSONTyped = NftEventFromJSONTyped;
  exports.NftEventToJSON = NftEventToJSON;
  exports.NonFungibleTokenHistoryEventListFromJSON = NonFungibleTokenHistoryEventListFromJSON;
  exports.NonFungibleTokenHistoryEventListFromJSONTyped = NonFungibleTokenHistoryEventListFromJSONTyped;
  exports.NonFungibleTokenHistoryEventListToJSON = NonFungibleTokenHistoryEventListToJSON;
  exports.NonFungibleTokenHoldingsListFromJSON = NonFungibleTokenHoldingsListFromJSON;
  exports.NonFungibleTokenHoldingsListFromJSONTyped = NonFungibleTokenHoldingsListFromJSONTyped;
  exports.NonFungibleTokenHoldingsListToJSON = NonFungibleTokenHoldingsListToJSON;
  exports.NonFungibleTokenMetadataFromJSON = NonFungibleTokenMetadataFromJSON;
  exports.NonFungibleTokenMetadataFromJSONTyped = NonFungibleTokenMetadataFromJSONTyped;
  exports.NonFungibleTokenMetadataToJSON = NonFungibleTokenMetadataToJSON;
  exports.NonFungibleTokenMintListFromJSON = NonFungibleTokenMintListFromJSON;
  exports.NonFungibleTokenMintListFromJSONTyped = NonFungibleTokenMintListFromJSONTyped;
  exports.NonFungibleTokenMintListToJSON = NonFungibleTokenMintListToJSON;
  exports.NonFungibleTokensApi = NonFungibleTokensApi;
  exports.NonFungibleTokensMetadataListFromJSON = NonFungibleTokensMetadataListFromJSON;
  exports.NonFungibleTokensMetadataListFromJSONTyped = NonFungibleTokensMetadataListFromJSONTyped;
  exports.NonFungibleTokensMetadataListToJSON = NonFungibleTokensMetadataListToJSON;
  exports.OtherTransactionIdentifierFromJSON = OtherTransactionIdentifierFromJSON;
  exports.OtherTransactionIdentifierFromJSONTyped = OtherTransactionIdentifierFromJSONTyped;
  exports.OtherTransactionIdentifierToJSON = OtherTransactionIdentifierToJSON;
  exports.PostCoreNodeTransactionsErrorFromJSON = PostCoreNodeTransactionsErrorFromJSON;
  exports.PostCoreNodeTransactionsErrorFromJSONTyped = PostCoreNodeTransactionsErrorFromJSONTyped;
  exports.PostCoreNodeTransactionsErrorToJSON = PostCoreNodeTransactionsErrorToJSON;
  exports.ReadOnlyFunctionArgsFromJSON = ReadOnlyFunctionArgsFromJSON;
  exports.ReadOnlyFunctionArgsFromJSONTyped = ReadOnlyFunctionArgsFromJSONTyped;
  exports.ReadOnlyFunctionArgsToJSON = ReadOnlyFunctionArgsToJSON;
  exports.ReadOnlyFunctionSuccessResponseFromJSON = ReadOnlyFunctionSuccessResponseFromJSON;
  exports.ReadOnlyFunctionSuccessResponseFromJSONTyped = ReadOnlyFunctionSuccessResponseFromJSONTyped;
  exports.ReadOnlyFunctionSuccessResponseToJSON = ReadOnlyFunctionSuccessResponseToJSON;
  exports.RequiredError = RequiredError;
  exports.RosettaAccountBalanceRequestFromJSON = RosettaAccountBalanceRequestFromJSON;
  exports.RosettaAccountBalanceRequestFromJSONTyped = RosettaAccountBalanceRequestFromJSONTyped;
  exports.RosettaAccountBalanceRequestToJSON = RosettaAccountBalanceRequestToJSON;
  exports.RosettaAccountBalanceResponseCoinIdentifierFromJSON = RosettaAccountBalanceResponseCoinIdentifierFromJSON;
  exports.RosettaAccountBalanceResponseCoinIdentifierFromJSONTyped = RosettaAccountBalanceResponseCoinIdentifierFromJSONTyped;
  exports.RosettaAccountBalanceResponseCoinIdentifierToJSON = RosettaAccountBalanceResponseCoinIdentifierToJSON;
  exports.RosettaAccountBalanceResponseFromJSON = RosettaAccountBalanceResponseFromJSON;
  exports.RosettaAccountBalanceResponseFromJSONTyped = RosettaAccountBalanceResponseFromJSONTyped;
  exports.RosettaAccountBalanceResponseMetadataFromJSON = RosettaAccountBalanceResponseMetadataFromJSON;
  exports.RosettaAccountBalanceResponseMetadataFromJSONTyped = RosettaAccountBalanceResponseMetadataFromJSONTyped;
  exports.RosettaAccountBalanceResponseMetadataToJSON = RosettaAccountBalanceResponseMetadataToJSON;
  exports.RosettaAccountBalanceResponseToJSON = RosettaAccountBalanceResponseToJSON;
  exports.RosettaAccountFromJSON = RosettaAccountFromJSON;
  exports.RosettaAccountFromJSONTyped = RosettaAccountFromJSONTyped;
  exports.RosettaAccountIdentifierFromJSON = RosettaAccountIdentifierFromJSON;
  exports.RosettaAccountIdentifierFromJSONTyped = RosettaAccountIdentifierFromJSONTyped;
  exports.RosettaAccountIdentifierToJSON = RosettaAccountIdentifierToJSON;
  exports.RosettaAccountToJSON = RosettaAccountToJSON;
  exports.RosettaAmountFromJSON = RosettaAmountFromJSON;
  exports.RosettaAmountFromJSONTyped = RosettaAmountFromJSONTyped;
  exports.RosettaAmountToJSON = RosettaAmountToJSON;
  exports.RosettaApi = RosettaApi;
  exports.RosettaBlockFromJSON = RosettaBlockFromJSON;
  exports.RosettaBlockFromJSONTyped = RosettaBlockFromJSONTyped;
  exports.RosettaBlockMetadata1FromJSON = RosettaBlockMetadata1FromJSON;
  exports.RosettaBlockMetadata1FromJSONTyped = RosettaBlockMetadata1FromJSONTyped;
  exports.RosettaBlockMetadata1ToJSON = RosettaBlockMetadata1ToJSON;
  exports.RosettaBlockMetadataFromJSON = RosettaBlockMetadataFromJSON;
  exports.RosettaBlockMetadataFromJSONTyped = RosettaBlockMetadataFromJSONTyped;
  exports.RosettaBlockMetadataToJSON = RosettaBlockMetadataToJSON;
  exports.RosettaBlockRequestFromJSON = RosettaBlockRequestFromJSON;
  exports.RosettaBlockRequestFromJSONTyped = RosettaBlockRequestFromJSONTyped;
  exports.RosettaBlockRequestToJSON = RosettaBlockRequestToJSON;
  exports.RosettaBlockResponseFromJSON = RosettaBlockResponseFromJSON;
  exports.RosettaBlockResponseFromJSONTyped = RosettaBlockResponseFromJSONTyped;
  exports.RosettaBlockResponseToJSON = RosettaBlockResponseToJSON;
  exports.RosettaBlockToJSON = RosettaBlockToJSON;
  exports.RosettaBlockTransactionRequestFromJSON = RosettaBlockTransactionRequestFromJSON;
  exports.RosettaBlockTransactionRequestFromJSONTyped = RosettaBlockTransactionRequestFromJSONTyped;
  exports.RosettaBlockTransactionRequestToJSON = RosettaBlockTransactionRequestToJSON;
  exports.RosettaBlockTransactionResponseFromJSON = RosettaBlockTransactionResponseFromJSON;
  exports.RosettaBlockTransactionResponseFromJSONTyped = RosettaBlockTransactionResponseFromJSONTyped;
  exports.RosettaBlockTransactionResponseToJSON = RosettaBlockTransactionResponseToJSON;
  exports.RosettaCoinChangeFromJSON = RosettaCoinChangeFromJSON;
  exports.RosettaCoinChangeFromJSONTyped = RosettaCoinChangeFromJSONTyped;
  exports.RosettaCoinChangeToJSON = RosettaCoinChangeToJSON;
  exports.RosettaCoinFromJSON = RosettaCoinFromJSON;
  exports.RosettaCoinFromJSONTyped = RosettaCoinFromJSONTyped;
  exports.RosettaCoinToJSON = RosettaCoinToJSON;
  exports.RosettaConstructionCombineRequestFromJSON = RosettaConstructionCombineRequestFromJSON;
  exports.RosettaConstructionCombineRequestFromJSONTyped = RosettaConstructionCombineRequestFromJSONTyped;
  exports.RosettaConstructionCombineRequestToJSON = RosettaConstructionCombineRequestToJSON;
  exports.RosettaConstructionCombineResponseFromJSON = RosettaConstructionCombineResponseFromJSON;
  exports.RosettaConstructionCombineResponseFromJSONTyped = RosettaConstructionCombineResponseFromJSONTyped;
  exports.RosettaConstructionCombineResponseToJSON = RosettaConstructionCombineResponseToJSON;
  exports.RosettaConstructionDeriveRequestFromJSON = RosettaConstructionDeriveRequestFromJSON;
  exports.RosettaConstructionDeriveRequestFromJSONTyped = RosettaConstructionDeriveRequestFromJSONTyped;
  exports.RosettaConstructionDeriveRequestToJSON = RosettaConstructionDeriveRequestToJSON;
  exports.RosettaConstructionDeriveResponseFromJSON = RosettaConstructionDeriveResponseFromJSON;
  exports.RosettaConstructionDeriveResponseFromJSONTyped = RosettaConstructionDeriveResponseFromJSONTyped;
  exports.RosettaConstructionDeriveResponseToJSON = RosettaConstructionDeriveResponseToJSON;
  exports.RosettaConstructionHashRequestFromJSON = RosettaConstructionHashRequestFromJSON;
  exports.RosettaConstructionHashRequestFromJSONTyped = RosettaConstructionHashRequestFromJSONTyped;
  exports.RosettaConstructionHashRequestToJSON = RosettaConstructionHashRequestToJSON;
  exports.RosettaConstructionHashResponseFromJSON = RosettaConstructionHashResponseFromJSON;
  exports.RosettaConstructionHashResponseFromJSONTyped = RosettaConstructionHashResponseFromJSONTyped;
  exports.RosettaConstructionHashResponseToJSON = RosettaConstructionHashResponseToJSON;
  exports.RosettaConstructionMetadataRequestFromJSON = RosettaConstructionMetadataRequestFromJSON;
  exports.RosettaConstructionMetadataRequestFromJSONTyped = RosettaConstructionMetadataRequestFromJSONTyped;
  exports.RosettaConstructionMetadataRequestToJSON = RosettaConstructionMetadataRequestToJSON;
  exports.RosettaConstructionMetadataResponseFromJSON = RosettaConstructionMetadataResponseFromJSON;
  exports.RosettaConstructionMetadataResponseFromJSONTyped = RosettaConstructionMetadataResponseFromJSONTyped;
  exports.RosettaConstructionMetadataResponseMetadataFromJSON = RosettaConstructionMetadataResponseMetadataFromJSON;
  exports.RosettaConstructionMetadataResponseMetadataFromJSONTyped = RosettaConstructionMetadataResponseMetadataFromJSONTyped;
  exports.RosettaConstructionMetadataResponseMetadataToJSON = RosettaConstructionMetadataResponseMetadataToJSON;
  exports.RosettaConstructionMetadataResponseToJSON = RosettaConstructionMetadataResponseToJSON;
  exports.RosettaConstructionParseRequestFromJSON = RosettaConstructionParseRequestFromJSON;
  exports.RosettaConstructionParseRequestFromJSONTyped = RosettaConstructionParseRequestFromJSONTyped;
  exports.RosettaConstructionParseRequestToJSON = RosettaConstructionParseRequestToJSON;
  exports.RosettaConstructionParseResponseFromJSON = RosettaConstructionParseResponseFromJSON;
  exports.RosettaConstructionParseResponseFromJSONTyped = RosettaConstructionParseResponseFromJSONTyped;
  exports.RosettaConstructionParseResponseToJSON = RosettaConstructionParseResponseToJSON;
  exports.RosettaConstructionPayloadResponseFromJSON = RosettaConstructionPayloadResponseFromJSON;
  exports.RosettaConstructionPayloadResponseFromJSONTyped = RosettaConstructionPayloadResponseFromJSONTyped;
  exports.RosettaConstructionPayloadResponseToJSON = RosettaConstructionPayloadResponseToJSON;
  exports.RosettaConstructionPayloadsRequestFromJSON = RosettaConstructionPayloadsRequestFromJSON;
  exports.RosettaConstructionPayloadsRequestFromJSONTyped = RosettaConstructionPayloadsRequestFromJSONTyped;
  exports.RosettaConstructionPayloadsRequestToJSON = RosettaConstructionPayloadsRequestToJSON;
  exports.RosettaConstructionPreprocessRequestFromJSON = RosettaConstructionPreprocessRequestFromJSON;
  exports.RosettaConstructionPreprocessRequestFromJSONTyped = RosettaConstructionPreprocessRequestFromJSONTyped;
  exports.RosettaConstructionPreprocessRequestToJSON = RosettaConstructionPreprocessRequestToJSON;
  exports.RosettaConstructionPreprocessResponseFromJSON = RosettaConstructionPreprocessResponseFromJSON;
  exports.RosettaConstructionPreprocessResponseFromJSONTyped = RosettaConstructionPreprocessResponseFromJSONTyped;
  exports.RosettaConstructionPreprocessResponseToJSON = RosettaConstructionPreprocessResponseToJSON;
  exports.RosettaConstructionSubmitRequestFromJSON = RosettaConstructionSubmitRequestFromJSON;
  exports.RosettaConstructionSubmitRequestFromJSONTyped = RosettaConstructionSubmitRequestFromJSONTyped;
  exports.RosettaConstructionSubmitRequestToJSON = RosettaConstructionSubmitRequestToJSON;
  exports.RosettaConstructionSubmitResponseFromJSON = RosettaConstructionSubmitResponseFromJSON;
  exports.RosettaConstructionSubmitResponseFromJSONTyped = RosettaConstructionSubmitResponseFromJSONTyped;
  exports.RosettaConstructionSubmitResponseToJSON = RosettaConstructionSubmitResponseToJSON;
  exports.RosettaCurrencyFromJSON = RosettaCurrencyFromJSON;
  exports.RosettaCurrencyFromJSONTyped = RosettaCurrencyFromJSONTyped;
  exports.RosettaCurrencyToJSON = RosettaCurrencyToJSON;
  exports.RosettaErrorDetailsFromJSON = RosettaErrorDetailsFromJSON;
  exports.RosettaErrorDetailsFromJSONTyped = RosettaErrorDetailsFromJSONTyped;
  exports.RosettaErrorDetailsToJSON = RosettaErrorDetailsToJSON;
  exports.RosettaErrorFromJSON = RosettaErrorFromJSON;
  exports.RosettaErrorFromJSONTyped = RosettaErrorFromJSONTyped;
  exports.RosettaErrorNoDetailsFromJSON = RosettaErrorNoDetailsFromJSON;
  exports.RosettaErrorNoDetailsFromJSONTyped = RosettaErrorNoDetailsFromJSONTyped;
  exports.RosettaErrorNoDetailsToJSON = RosettaErrorNoDetailsToJSON;
  exports.RosettaErrorToJSON = RosettaErrorToJSON;
  exports.RosettaGenesisBlockIdentifierFromJSON = RosettaGenesisBlockIdentifierFromJSON;
  exports.RosettaGenesisBlockIdentifierFromJSONTyped = RosettaGenesisBlockIdentifierFromJSONTyped;
  exports.RosettaGenesisBlockIdentifierToJSON = RosettaGenesisBlockIdentifierToJSON;
  exports.RosettaMaxFeeAmountFromJSON = RosettaMaxFeeAmountFromJSON;
  exports.RosettaMaxFeeAmountFromJSONTyped = RosettaMaxFeeAmountFromJSONTyped;
  exports.RosettaMaxFeeAmountToJSON = RosettaMaxFeeAmountToJSON;
  exports.RosettaMempoolRequestFromJSON = RosettaMempoolRequestFromJSON;
  exports.RosettaMempoolRequestFromJSONTyped = RosettaMempoolRequestFromJSONTyped;
  exports.RosettaMempoolRequestToJSON = RosettaMempoolRequestToJSON;
  exports.RosettaMempoolResponseFromJSON = RosettaMempoolResponseFromJSON;
  exports.RosettaMempoolResponseFromJSONTyped = RosettaMempoolResponseFromJSONTyped;
  exports.RosettaMempoolResponseToJSON = RosettaMempoolResponseToJSON;
  exports.RosettaMempoolTransactionRequestFromJSON = RosettaMempoolTransactionRequestFromJSON;
  exports.RosettaMempoolTransactionRequestFromJSONTyped = RosettaMempoolTransactionRequestFromJSONTyped;
  exports.RosettaMempoolTransactionRequestToJSON = RosettaMempoolTransactionRequestToJSON;
  exports.RosettaMempoolTransactionResponseFromJSON = RosettaMempoolTransactionResponseFromJSON;
  exports.RosettaMempoolTransactionResponseFromJSONTyped = RosettaMempoolTransactionResponseFromJSONTyped;
  exports.RosettaMempoolTransactionResponseToJSON = RosettaMempoolTransactionResponseToJSON;
  exports.RosettaNetworkListResponseFromJSON = RosettaNetworkListResponseFromJSON;
  exports.RosettaNetworkListResponseFromJSONTyped = RosettaNetworkListResponseFromJSONTyped;
  exports.RosettaNetworkListResponseSubNetworkIdentifierFromJSON = RosettaNetworkListResponseSubNetworkIdentifierFromJSON;
  exports.RosettaNetworkListResponseSubNetworkIdentifierFromJSONTyped = RosettaNetworkListResponseSubNetworkIdentifierFromJSONTyped;
  exports.RosettaNetworkListResponseSubNetworkIdentifierMetadataFromJSON = RosettaNetworkListResponseSubNetworkIdentifierMetadataFromJSON;
  exports.RosettaNetworkListResponseSubNetworkIdentifierMetadataFromJSONTyped = RosettaNetworkListResponseSubNetworkIdentifierMetadataFromJSONTyped;
  exports.RosettaNetworkListResponseSubNetworkIdentifierMetadataToJSON = RosettaNetworkListResponseSubNetworkIdentifierMetadataToJSON;
  exports.RosettaNetworkListResponseSubNetworkIdentifierToJSON = RosettaNetworkListResponseSubNetworkIdentifierToJSON;
  exports.RosettaNetworkListResponseToJSON = RosettaNetworkListResponseToJSON;
  exports.RosettaNetworkOptionsResponseAllowFromJSON = RosettaNetworkOptionsResponseAllowFromJSON;
  exports.RosettaNetworkOptionsResponseAllowFromJSONTyped = RosettaNetworkOptionsResponseAllowFromJSONTyped;
  exports.RosettaNetworkOptionsResponseAllowToJSON = RosettaNetworkOptionsResponseAllowToJSON;
  exports.RosettaNetworkOptionsResponseFromJSON = RosettaNetworkOptionsResponseFromJSON;
  exports.RosettaNetworkOptionsResponseFromJSONTyped = RosettaNetworkOptionsResponseFromJSONTyped;
  exports.RosettaNetworkOptionsResponseToJSON = RosettaNetworkOptionsResponseToJSON;
  exports.RosettaNetworkOptionsResponseVersionFromJSON = RosettaNetworkOptionsResponseVersionFromJSON;
  exports.RosettaNetworkOptionsResponseVersionFromJSONTyped = RosettaNetworkOptionsResponseVersionFromJSONTyped;
  exports.RosettaNetworkOptionsResponseVersionToJSON = RosettaNetworkOptionsResponseVersionToJSON;
  exports.RosettaNetworkStatusResponseFromJSON = RosettaNetworkStatusResponseFromJSON;
  exports.RosettaNetworkStatusResponseFromJSONTyped = RosettaNetworkStatusResponseFromJSONTyped;
  exports.RosettaNetworkStatusResponseToJSON = RosettaNetworkStatusResponseToJSON;
  exports.RosettaOldestBlockIdentifierFromJSON = RosettaOldestBlockIdentifierFromJSON;
  exports.RosettaOldestBlockIdentifierFromJSONTyped = RosettaOldestBlockIdentifierFromJSONTyped;
  exports.RosettaOldestBlockIdentifierToJSON = RosettaOldestBlockIdentifierToJSON;
  exports.RosettaOperationFromJSON = RosettaOperationFromJSON;
  exports.RosettaOperationFromJSONTyped = RosettaOperationFromJSONTyped;
  exports.RosettaOperationIdentifierFromJSON = RosettaOperationIdentifierFromJSON;
  exports.RosettaOperationIdentifierFromJSONTyped = RosettaOperationIdentifierFromJSONTyped;
  exports.RosettaOperationIdentifierToJSON = RosettaOperationIdentifierToJSON;
  exports.RosettaOperationStatusFromJSON = RosettaOperationStatusFromJSON;
  exports.RosettaOperationStatusFromJSONTyped = RosettaOperationStatusFromJSONTyped;
  exports.RosettaOperationStatusToJSON = RosettaOperationStatusToJSON;
  exports.RosettaOperationToJSON = RosettaOperationToJSON;
  exports.RosettaOptionsFromJSON = RosettaOptionsFromJSON;
  exports.RosettaOptionsFromJSONTyped = RosettaOptionsFromJSONTyped;
  exports.RosettaOptionsRequestFromJSON = RosettaOptionsRequestFromJSON;
  exports.RosettaOptionsRequestFromJSONTyped = RosettaOptionsRequestFromJSONTyped;
  exports.RosettaOptionsRequestToJSON = RosettaOptionsRequestToJSON;
  exports.RosettaOptionsToJSON = RosettaOptionsToJSON;
  exports.RosettaParentBlockIdentifierFromJSON = RosettaParentBlockIdentifierFromJSON;
  exports.RosettaParentBlockIdentifierFromJSONTyped = RosettaParentBlockIdentifierFromJSONTyped;
  exports.RosettaParentBlockIdentifierToJSON = RosettaParentBlockIdentifierToJSON;
  exports.RosettaPeersFromJSON = RosettaPeersFromJSON;
  exports.RosettaPeersFromJSONTyped = RosettaPeersFromJSONTyped;
  exports.RosettaPeersToJSON = RosettaPeersToJSON;
  exports.RosettaPublicKeyFromJSON = RosettaPublicKeyFromJSON;
  exports.RosettaPublicKeyFromJSONTyped = RosettaPublicKeyFromJSONTyped;
  exports.RosettaPublicKeyToJSON = RosettaPublicKeyToJSON;
  exports.RosettaRelatedOperationFromJSON = RosettaRelatedOperationFromJSON;
  exports.RosettaRelatedOperationFromJSONTyped = RosettaRelatedOperationFromJSONTyped;
  exports.RosettaRelatedOperationToJSON = RosettaRelatedOperationToJSON;
  exports.RosettaSignatureFromJSON = RosettaSignatureFromJSON;
  exports.RosettaSignatureFromJSONTyped = RosettaSignatureFromJSONTyped;
  exports.RosettaSignatureToJSON = RosettaSignatureToJSON;
  exports.RosettaStatusRequestFromJSON = RosettaStatusRequestFromJSON;
  exports.RosettaStatusRequestFromJSONTyped = RosettaStatusRequestFromJSONTyped;
  exports.RosettaStatusRequestToJSON = RosettaStatusRequestToJSON;
  exports.RosettaSubAccountFromJSON = RosettaSubAccountFromJSON;
  exports.RosettaSubAccountFromJSONTyped = RosettaSubAccountFromJSONTyped;
  exports.RosettaSubAccountToJSON = RosettaSubAccountToJSON;
  exports.RosettaSyncStatusFromJSON = RosettaSyncStatusFromJSON;
  exports.RosettaSyncStatusFromJSONTyped = RosettaSyncStatusFromJSONTyped;
  exports.RosettaSyncStatusToJSON = RosettaSyncStatusToJSON;
  exports.RosettaTransactionFromJSON = RosettaTransactionFromJSON;
  exports.RosettaTransactionFromJSONTyped = RosettaTransactionFromJSONTyped;
  exports.RosettaTransactionToJSON = RosettaTransactionToJSON;
  exports.RunFaucetResponseFromJSON = RunFaucetResponseFromJSON;
  exports.RunFaucetResponseFromJSONTyped = RunFaucetResponseFromJSONTyped;
  exports.RunFaucetResponseToJSON = RunFaucetResponseToJSON;
  exports.SearchApi = SearchApi;
  exports.ServerStatusResponseFromJSON = ServerStatusResponseFromJSON;
  exports.ServerStatusResponseFromJSONTyped = ServerStatusResponseFromJSONTyped;
  exports.ServerStatusResponseToJSON = ServerStatusResponseToJSON;
  exports.SigningPayloadFromJSON = SigningPayloadFromJSON;
  exports.SigningPayloadFromJSONTyped = SigningPayloadFromJSONTyped;
  exports.SigningPayloadToJSON = SigningPayloadToJSON;
  exports.SmartContractFromJSON = SmartContractFromJSON;
  exports.SmartContractFromJSONTyped = SmartContractFromJSONTyped;
  exports.SmartContractToJSON = SmartContractToJSON;
  exports.SmartContractsApi = SmartContractsApi;
  exports.StackingRewardsApi = StackingRewardsApi;
  exports.StacksApiSocketClient = StacksApiSocketClient;
  exports.StacksApiWebSocketClient = StacksApiWebSocketClient;
  exports.StxBalanceFromJSON = StxBalanceFromJSON;
  exports.StxBalanceFromJSONTyped = StxBalanceFromJSONTyped;
  exports.StxBalanceToJSON = StxBalanceToJSON;
  exports.TargetBlockTimeFromJSON = TargetBlockTimeFromJSON;
  exports.TargetBlockTimeFromJSONTyped = TargetBlockTimeFromJSONTyped;
  exports.TargetBlockTimeToJSON = TargetBlockTimeToJSON;
  exports.TextApiResponse = TextApiResponse;
  exports.TransactionEventsResponseFromJSON = TransactionEventsResponseFromJSON;
  exports.TransactionEventsResponseFromJSONTyped = TransactionEventsResponseFromJSONTyped;
  exports.TransactionEventsResponseToJSON = TransactionEventsResponseToJSON;
  exports.TransactionFeeEstimateRequestFromJSON = TransactionFeeEstimateRequestFromJSON;
  exports.TransactionFeeEstimateRequestFromJSONTyped = TransactionFeeEstimateRequestFromJSONTyped;
  exports.TransactionFeeEstimateRequestToJSON = TransactionFeeEstimateRequestToJSON;
  exports.TransactionFeeEstimateResponseEstimatedCostFromJSON = TransactionFeeEstimateResponseEstimatedCostFromJSON;
  exports.TransactionFeeEstimateResponseEstimatedCostFromJSONTyped = TransactionFeeEstimateResponseEstimatedCostFromJSONTyped;
  exports.TransactionFeeEstimateResponseEstimatedCostToJSON = TransactionFeeEstimateResponseEstimatedCostToJSON;
  exports.TransactionFeeEstimateResponseEstimationsFromJSON = TransactionFeeEstimateResponseEstimationsFromJSON;
  exports.TransactionFeeEstimateResponseEstimationsFromJSONTyped = TransactionFeeEstimateResponseEstimationsFromJSONTyped;
  exports.TransactionFeeEstimateResponseEstimationsToJSON = TransactionFeeEstimateResponseEstimationsToJSON;
  exports.TransactionFeeEstimateResponseFromJSON = TransactionFeeEstimateResponseFromJSON;
  exports.TransactionFeeEstimateResponseFromJSONTyped = TransactionFeeEstimateResponseFromJSONTyped;
  exports.TransactionFeeEstimateResponseToJSON = TransactionFeeEstimateResponseToJSON;
  exports.TransactionIdentifierFromJSON = TransactionIdentifierFromJSON;
  exports.TransactionIdentifierFromJSONTyped = TransactionIdentifierFromJSONTyped;
  exports.TransactionIdentifierToJSON = TransactionIdentifierToJSON;
  exports.TransactionResultsFromJSON = TransactionResultsFromJSON;
  exports.TransactionResultsFromJSONTyped = TransactionResultsFromJSONTyped;
  exports.TransactionResultsToJSON = TransactionResultsToJSON;
  exports.TransactionsApi = TransactionsApi;
  exports.UnanchoredTransactionListResponseFromJSON = UnanchoredTransactionListResponseFromJSON;
  exports.UnanchoredTransactionListResponseFromJSONTyped = UnanchoredTransactionListResponseFromJSONTyped;
  exports.UnanchoredTransactionListResponseToJSON = UnanchoredTransactionListResponseToJSON;
  exports.VoidApiResponse = VoidApiResponse;
  exports.canConsumeForm = canConsumeForm;
  exports.connectWebSocketClient = connectWebSocketClient;
  exports.exists = exists;
  exports.mapValues = mapValues;
  exports.querystring = querystring;

}));
//# sourceMappingURL=index.umd.js.map
