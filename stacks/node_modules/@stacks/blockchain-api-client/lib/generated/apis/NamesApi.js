"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Stacks Blockchain API
 * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
 *
 * The version of the OpenAPI document: STACKS_API_VERSION
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamesApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class NamesApi extends runtime.BaseAPI {
    /**
     * Retrieves the list of subdomains for a specific name
     * Get Name Subdomains
     */
    async fetchSubdomainsListForNameRaw(requestParameters, initOverrides) {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling fetchSubdomainsListForName.');
        }
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/v1/names/{name}/subdomains`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response);
    }
    /**
     * Retrieves the list of subdomains for a specific name
     * Get Name Subdomains
     */
    async fetchSubdomainsListForName(requestParameters, initOverrides) {
        const response = await this.fetchSubdomainsListForNameRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves a user’s raw zone file. This only works for RFC-compliant zone files. This method returns an error for names that have non-standard zone files.
     * Get Zone File
     */
    async fetchZoneFileRaw(requestParameters, initOverrides) {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling fetchZoneFile.');
        }
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/v1/names/{name}/zonefile`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response);
    }
    /**
     * Retrieves a user’s raw zone file. This only works for RFC-compliant zone files. This method returns an error for names that have non-standard zone files.
     * Get Zone File
     */
    async fetchZoneFile(requestParameters, initOverrides) {
        const response = await this.fetchZoneFileRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves a list of all names known to the node.
     * Get All Names
     */
    async getAllNamesRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/v1/names`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response);
    }
    /**
     * Retrieves a list of all names known to the node.
     * Get All Names
     */
    async getAllNames(requestParameters, initOverrides) {
        const response = await this.getAllNamesRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves a list of all namespaces known to the node.
     * Get All Namespaces
     */
    async getAllNamespacesRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/v1/namespaces`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.BnsGetAllNamespacesResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves a list of all namespaces known to the node.
     * Get All Namespaces
     */
    async getAllNamespaces(initOverrides) {
        const response = await this.getAllNamespacesRaw(initOverrides);
        return await response.value();
    }
    /**
     * Retrieves the historical zonefile specified by the username and zone hash.
     * Get Historical Zone File
     */
    async getHistoricalZoneFileRaw(requestParameters, initOverrides) {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling getHistoricalZoneFile.');
        }
        if (requestParameters.zoneFileHash === null || requestParameters.zoneFileHash === undefined) {
            throw new runtime.RequiredError('zoneFileHash', 'Required parameter requestParameters.zoneFileHash was null or undefined when calling getHistoricalZoneFile.');
        }
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/v1/names/{name}/zonefile/{zoneFileHash}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"zoneFileHash"}}`, encodeURIComponent(String(requestParameters.zoneFileHash))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response);
    }
    /**
     * Retrieves the historical zonefile specified by the username and zone hash.
     * Get Historical Zone File
     */
    async getHistoricalZoneFile(requestParameters, initOverrides) {
        const response = await this.getHistoricalZoneFileRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves details of a given name including the `address`, `status` and last transaction id - `last_txid`.
     * Get Name Details
     */
    async getNameInfoRaw(requestParameters, initOverrides) {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling getNameInfo.');
        }
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/v1/names/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.BnsGetNameInfoResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves details of a given name including the `address`, `status` and last transaction id - `last_txid`.
     * Get Name Details
     */
    async getNameInfo(requestParameters, initOverrides) {
        const response = await this.getNameInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves the price of a name. The `amount` given will be in the smallest possible units of the currency.
     * Get Name Price
     */
    async getNamePriceRaw(requestParameters, initOverrides) {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling getNamePrice.');
        }
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/v2/prices/names/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.BnsGetNamePriceResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves the price of a name. The `amount` given will be in the smallest possible units of the currency.
     * Get Name Price
     */
    async getNamePrice(requestParameters, initOverrides) {
        const response = await this.getNamePriceRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves a list of names owned by the address provided.
     * Get Names Owned by Address
     */
    async getNamesOwnedByAddressRaw(requestParameters, initOverrides) {
        if (requestParameters.blockchain === null || requestParameters.blockchain === undefined) {
            throw new runtime.RequiredError('blockchain', 'Required parameter requestParameters.blockchain was null or undefined when calling getNamesOwnedByAddress.');
        }
        if (requestParameters.address === null || requestParameters.address === undefined) {
            throw new runtime.RequiredError('address', 'Required parameter requestParameters.address was null or undefined when calling getNamesOwnedByAddress.');
        }
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/v1/addresses/{blockchain}/{address}`.replace(`{${"blockchain"}}`, encodeURIComponent(String(requestParameters.blockchain))).replace(`{${"address"}}`, encodeURIComponent(String(requestParameters.address))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.BnsNamesOwnByAddressResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves a list of names owned by the address provided.
     * Get Names Owned by Address
     */
    async getNamesOwnedByAddress(requestParameters, initOverrides) {
        const response = await this.getNamesOwnedByAddressRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves a list of names within a given namespace.
     * Get Namespace Names
     */
    async getNamespaceNamesRaw(requestParameters, initOverrides) {
        if (requestParameters.tld === null || requestParameters.tld === undefined) {
            throw new runtime.RequiredError('tld', 'Required parameter requestParameters.tld was null or undefined when calling getNamespaceNames.');
        }
        const queryParameters = {};
        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/v1/namespaces/{tld}/names`.replace(`{${"tld"}}`, encodeURIComponent(String(requestParameters.tld))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response);
    }
    /**
     * Retrieves a list of names within a given namespace.
     * Get Namespace Names
     */
    async getNamespaceNames(requestParameters, initOverrides) {
        const response = await this.getNamespaceNamesRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves the price of a namespace. The `amount` given will be in the smallest possible units of the currency.
     * Get Namespace Price
     */
    async getNamespacePriceRaw(requestParameters, initOverrides) {
        if (requestParameters.tld === null || requestParameters.tld === undefined) {
            throw new runtime.RequiredError('tld', 'Required parameter requestParameters.tld was null or undefined when calling getNamespacePrice.');
        }
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/v2/prices/namespaces/{tld}`.replace(`{${"tld"}}`, encodeURIComponent(String(requestParameters.tld))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.BnsGetNamespacePriceResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves the price of a namespace. The `amount` given will be in the smallest possible units of the currency.
     * Get Namespace Price
     */
    async getNamespacePrice(requestParameters, initOverrides) {
        const response = await this.getNamespacePriceRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
exports.NamesApi = NamesApi;
//# sourceMappingURL=NamesApi.js.map