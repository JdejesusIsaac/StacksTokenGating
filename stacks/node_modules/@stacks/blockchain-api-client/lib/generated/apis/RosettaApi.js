"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Stacks Blockchain API
 * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
 *
 * The version of the OpenAPI document: STACKS_API_VERSION
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RosettaApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class RosettaApi extends runtime.BaseAPI {
    /**
     * An AccountBalanceRequest is utilized to make a balance request on the /account/balance endpoint. If the block_identifier is populated, a historical balance query should be performed.
     * Get an Account Balance
     */
    async rosettaAccountBalanceRaw(requestParameters, initOverrides) {
        if (requestParameters.rosettaAccountBalanceRequest === null || requestParameters.rosettaAccountBalanceRequest === undefined) {
            throw new runtime.RequiredError('rosettaAccountBalanceRequest', 'Required parameter requestParameters.rosettaAccountBalanceRequest was null or undefined when calling rosettaAccountBalance.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/rosetta/v1/account/balance`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.RosettaAccountBalanceRequestToJSON)(requestParameters.rosettaAccountBalanceRequest),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.RosettaAccountBalanceResponseFromJSON)(jsonValue));
    }
    /**
     * An AccountBalanceRequest is utilized to make a balance request on the /account/balance endpoint. If the block_identifier is populated, a historical balance query should be performed.
     * Get an Account Balance
     */
    async rosettaAccountBalance(requestParameters, initOverrides) {
        const response = await this.rosettaAccountBalanceRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves the Block information for a given block identifier including a list of all transactions in the block.
     * Get a Block
     */
    async rosettaBlockRaw(requestParameters, initOverrides) {
        if (requestParameters.rosettaBlockRequest === null || requestParameters.rosettaBlockRequest === undefined) {
            throw new runtime.RequiredError('rosettaBlockRequest', 'Required parameter requestParameters.rosettaBlockRequest was null or undefined when calling rosettaBlock.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/rosetta/v1/block`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.RosettaBlockRequestToJSON)(requestParameters.rosettaBlockRequest),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.RosettaBlockResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves the Block information for a given block identifier including a list of all transactions in the block.
     * Get a Block
     */
    async rosettaBlock(requestParameters, initOverrides) {
        const response = await this.rosettaBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves a Transaction included in a block that is not returned in a BlockResponse.
     * Get a Block Transaction
     */
    async rosettaBlockTransactionRaw(requestParameters, initOverrides) {
        if (requestParameters.rosettaBlockTransactionRequest === null || requestParameters.rosettaBlockTransactionRequest === undefined) {
            throw new runtime.RequiredError('rosettaBlockTransactionRequest', 'Required parameter requestParameters.rosettaBlockTransactionRequest was null or undefined when calling rosettaBlockTransaction.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/rosetta/v1/block/transaction`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.RosettaBlockTransactionRequestToJSON)(requestParameters.rosettaBlockTransactionRequest),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.RosettaBlockTransactionResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves a Transaction included in a block that is not returned in a BlockResponse.
     * Get a Block Transaction
     */
    async rosettaBlockTransaction(requestParameters, initOverrides) {
        const response = await this.rosettaBlockTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Take unsigned transaction and signature, combine both and return signed transaction. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Create Network Transaction from Signatures
     */
    async rosettaConstructionCombineRaw(requestParameters, initOverrides) {
        if (requestParameters.rosettaConstructionCombineRequest === null || requestParameters.rosettaConstructionCombineRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionCombineRequest', 'Required parameter requestParameters.rosettaConstructionCombineRequest was null or undefined when calling rosettaConstructionCombine.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/rosetta/v1/construction/combine`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.RosettaConstructionCombineRequestToJSON)(requestParameters.rosettaConstructionCombineRequest),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.RosettaConstructionCombineResponseFromJSON)(jsonValue));
    }
    /**
     * Take unsigned transaction and signature, combine both and return signed transaction. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Create Network Transaction from Signatures
     */
    async rosettaConstructionCombine(requestParameters, initOverrides) {
        const response = await this.rosettaConstructionCombineRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves the Account Identifier information based on a Public Key for a given network
     * Derive an AccountIdentifier from a PublicKey
     */
    async rosettaConstructionDeriveRaw(requestParameters, initOverrides) {
        if (requestParameters.rosettaConstructionDeriveRequest === null || requestParameters.rosettaConstructionDeriveRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionDeriveRequest', 'Required parameter requestParameters.rosettaConstructionDeriveRequest was null or undefined when calling rosettaConstructionDerive.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/rosetta/v1/construction/derive`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.RosettaConstructionDeriveRequestToJSON)(requestParameters.rosettaConstructionDeriveRequest),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.RosettaConstructionDeriveResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves the Account Identifier information based on a Public Key for a given network
     * Derive an AccountIdentifier from a PublicKey
     */
    async rosettaConstructionDerive(requestParameters, initOverrides) {
        const response = await this.rosettaConstructionDeriveRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves the network-specific transaction hash for a signed transaction.
     * Get the Hash of a Signed Transaction
     */
    async rosettaConstructionHashRaw(requestParameters, initOverrides) {
        if (requestParameters.rosettaConstructionHashRequest === null || requestParameters.rosettaConstructionHashRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionHashRequest', 'Required parameter requestParameters.rosettaConstructionHashRequest was null or undefined when calling rosettaConstructionHash.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/rosetta/v1/construction/hash`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.RosettaConstructionHashRequestToJSON)(requestParameters.rosettaConstructionHashRequest),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.RosettaConstructionHashResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves the network-specific transaction hash for a signed transaction.
     * Get the Hash of a Signed Transaction
     */
    async rosettaConstructionHash(requestParameters, initOverrides) {
        const response = await this.rosettaConstructionHashRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * To Do
     * Get Metadata for Transaction Construction
     */
    async rosettaConstructionMetadataRaw(requestParameters, initOverrides) {
        if (requestParameters.rosettaConstructionMetadataRequest === null || requestParameters.rosettaConstructionMetadataRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionMetadataRequest', 'Required parameter requestParameters.rosettaConstructionMetadataRequest was null or undefined when calling rosettaConstructionMetadata.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/rosetta/v1/construction/metadata`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.RosettaConstructionMetadataRequestToJSON)(requestParameters.rosettaConstructionMetadataRequest),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.RosettaConstructionMetadataResponseFromJSON)(jsonValue));
    }
    /**
     * To Do
     * Get Metadata for Transaction Construction
     */
    async rosettaConstructionMetadata(requestParameters, initOverrides) {
        const response = await this.rosettaConstructionMetadataRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * TODO
     * Parse a Transaction
     */
    async rosettaConstructionParseRaw(requestParameters, initOverrides) {
        if (requestParameters.rosettaConstructionParseRequest === null || requestParameters.rosettaConstructionParseRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionParseRequest', 'Required parameter requestParameters.rosettaConstructionParseRequest was null or undefined when calling rosettaConstructionParse.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/rosetta/v1/construction/parse`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.RosettaConstructionParseRequestToJSON)(requestParameters.rosettaConstructionParseRequest),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.RosettaConstructionParseResponseFromJSON)(jsonValue));
    }
    /**
     * TODO
     * Parse a Transaction
     */
    async rosettaConstructionParse(requestParameters, initOverrides) {
        const response = await this.rosettaConstructionParseRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Generate an unsigned transaction from operations and metadata. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Generate an Unsigned Transaction and Signing Payloads
     */
    async rosettaConstructionPayloadsRaw(requestParameters, initOverrides) {
        if (requestParameters.rosettaConstructionPayloadsRequest === null || requestParameters.rosettaConstructionPayloadsRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionPayloadsRequest', 'Required parameter requestParameters.rosettaConstructionPayloadsRequest was null or undefined when calling rosettaConstructionPayloads.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/rosetta/v1/construction/payloads`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.RosettaConstructionPayloadsRequestToJSON)(requestParameters.rosettaConstructionPayloadsRequest),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.RosettaConstructionPayloadResponseFromJSON)(jsonValue));
    }
    /**
     * Generate an unsigned transaction from operations and metadata. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Generate an Unsigned Transaction and Signing Payloads
     */
    async rosettaConstructionPayloads(requestParameters, initOverrides) {
        const response = await this.rosettaConstructionPayloadsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * TODO
     * Create a Request to Fetch Metadata
     */
    async rosettaConstructionPreprocessRaw(requestParameters, initOverrides) {
        if (requestParameters.rosettaConstructionPreprocessRequest === null || requestParameters.rosettaConstructionPreprocessRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionPreprocessRequest', 'Required parameter requestParameters.rosettaConstructionPreprocessRequest was null or undefined when calling rosettaConstructionPreprocess.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/rosetta/v1/construction/preprocess`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.RosettaConstructionPreprocessRequestToJSON)(requestParameters.rosettaConstructionPreprocessRequest),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.RosettaConstructionPreprocessResponseFromJSON)(jsonValue));
    }
    /**
     * TODO
     * Create a Request to Fetch Metadata
     */
    async rosettaConstructionPreprocess(requestParameters, initOverrides) {
        const response = await this.rosettaConstructionPreprocessRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Submit a pre-signed transaction to the node. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Submit a Signed Transaction
     */
    async rosettaConstructionSubmitRaw(requestParameters, initOverrides) {
        if (requestParameters.rosettaConstructionSubmitRequest === null || requestParameters.rosettaConstructionSubmitRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionSubmitRequest', 'Required parameter requestParameters.rosettaConstructionSubmitRequest was null or undefined when calling rosettaConstructionSubmit.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/rosetta/v1/construction/submit`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.RosettaConstructionSubmitRequestToJSON)(requestParameters.rosettaConstructionSubmitRequest),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.RosettaConstructionSubmitResponseFromJSON)(jsonValue));
    }
    /**
     * Submit a pre-signed transaction to the node. The examples below are illustrative only. You\'ll need to use your wallet to generate actual values to use them in the request payload.
     * Submit a Signed Transaction
     */
    async rosettaConstructionSubmit(requestParameters, initOverrides) {
        const response = await this.rosettaConstructionSubmitRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves a list of transactions currently in the mempool for a given network.
     * Get All Mempool Transactions
     */
    async rosettaMempoolRaw(requestParameters, initOverrides) {
        if (requestParameters.rosettaMempoolRequest === null || requestParameters.rosettaMempoolRequest === undefined) {
            throw new runtime.RequiredError('rosettaMempoolRequest', 'Required parameter requestParameters.rosettaMempoolRequest was null or undefined when calling rosettaMempool.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/rosetta/v1/mempool`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.RosettaMempoolRequestToJSON)(requestParameters.rosettaMempoolRequest),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.RosettaMempoolResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves a list of transactions currently in the mempool for a given network.
     * Get All Mempool Transactions
     */
    async rosettaMempool(requestParameters, initOverrides) {
        const response = await this.rosettaMempoolRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves transaction details from the mempool for a given transaction id from a given network.
     * Get a Mempool Transaction
     */
    async rosettaMempoolTransactionRaw(requestParameters, initOverrides) {
        if (requestParameters.rosettaMempoolTransactionRequest === null || requestParameters.rosettaMempoolTransactionRequest === undefined) {
            throw new runtime.RequiredError('rosettaMempoolTransactionRequest', 'Required parameter requestParameters.rosettaMempoolTransactionRequest was null or undefined when calling rosettaMempoolTransaction.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/rosetta/v1/mempool/transaction`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.RosettaMempoolTransactionRequestToJSON)(requestParameters.rosettaMempoolTransactionRequest),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.RosettaMempoolTransactionResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves transaction details from the mempool for a given transaction id from a given network.
     * Get a Mempool Transaction
     */
    async rosettaMempoolTransaction(requestParameters, initOverrides) {
        const response = await this.rosettaMempoolTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves a list of NetworkIdentifiers that the Rosetta server supports.
     * Get List of Available Networks
     */
    async rosettaNetworkListRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/rosetta/v1/network/list`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.RosettaNetworkListResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves a list of NetworkIdentifiers that the Rosetta server supports.
     * Get List of Available Networks
     */
    async rosettaNetworkList(initOverrides) {
        const response = await this.rosettaNetworkListRaw(initOverrides);
        return await response.value();
    }
    /**
     * Retrieves the version information and allowed network-specific types for a NetworkIdentifier. Any NetworkIdentifier returned by /network/list should be accessible here. Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network.
     * Get Network Options
     */
    async rosettaNetworkOptionsRaw(requestParameters, initOverrides) {
        if (requestParameters.rosettaOptionsRequest === null || requestParameters.rosettaOptionsRequest === undefined) {
            throw new runtime.RequiredError('rosettaOptionsRequest', 'Required parameter requestParameters.rosettaOptionsRequest was null or undefined when calling rosettaNetworkOptions.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/rosetta/v1/network/options`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.RosettaOptionsRequestToJSON)(requestParameters.rosettaOptionsRequest),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.RosettaNetworkOptionsResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves the version information and allowed network-specific types for a NetworkIdentifier. Any NetworkIdentifier returned by /network/list should be accessible here. Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network.
     * Get Network Options
     */
    async rosettaNetworkOptions(requestParameters, initOverrides) {
        const response = await this.rosettaNetworkOptionsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves the current status of the network requested. Any NetworkIdentifier returned by /network/list should be accessible here.
     * Get Network Status
     */
    async rosettaNetworkStatusRaw(requestParameters, initOverrides) {
        if (requestParameters.rosettaStatusRequest === null || requestParameters.rosettaStatusRequest === undefined) {
            throw new runtime.RequiredError('rosettaStatusRequest', 'Required parameter requestParameters.rosettaStatusRequest was null or undefined when calling rosettaNetworkStatus.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const response = await this.request({
            path: `/rosetta/v1/network/status`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, models_1.RosettaStatusRequestToJSON)(requestParameters.rosettaStatusRequest),
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.RosettaNetworkStatusResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves the current status of the network requested. Any NetworkIdentifier returned by /network/list should be accessible here.
     * Get Network Status
     */
    async rosettaNetworkStatus(requestParameters, initOverrides) {
        const response = await this.rosettaNetworkStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
exports.RosettaApi = RosettaApi;
//# sourceMappingURL=RosettaApi.js.map