"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Stacks Blockchain API
 * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
 *
 * The version of the OpenAPI document: STACKS_API_VERSION
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonFungibleTokensApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class NonFungibleTokensApi extends runtime.BaseAPI {
    /**
     * Retrieves metadata for non fungible tokens for a given contract id. More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non fungible tokens metadata for contract ID
     */
    async getContractNftMetadataRaw(requestParameters, initOverrides) {
        if (requestParameters.contractId === null || requestParameters.contractId === undefined) {
            throw new runtime.RequiredError('contractId', 'Required parameter requestParameters.contractId was null or undefined when calling getContractNftMetadata.');
        }
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/tokens/{contractId}/nft/metadata`.replace(`{${"contractId"}}`, encodeURIComponent(String(requestParameters.contractId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.NonFungibleTokenMetadataFromJSON)(jsonValue));
    }
    /**
     * Retrieves metadata for non fungible tokens for a given contract id. More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non fungible tokens metadata for contract ID
     */
    async getContractNftMetadata(requestParameters, initOverrides) {
        const response = await this.getContractNftMetadataRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves all events relevant to a Non-Fungible Token. Useful to determine the ownership history of a particular asset.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non-Fungible Token history
     */
    async getNftHistoryRaw(requestParameters, initOverrides) {
        if (requestParameters.assetIdentifier === null || requestParameters.assetIdentifier === undefined) {
            throw new runtime.RequiredError('assetIdentifier', 'Required parameter requestParameters.assetIdentifier was null or undefined when calling getNftHistory.');
        }
        if (requestParameters.value === null || requestParameters.value === undefined) {
            throw new runtime.RequiredError('value', 'Required parameter requestParameters.value was null or undefined when calling getNftHistory.');
        }
        const queryParameters = {};
        if (requestParameters.assetIdentifier !== undefined) {
            queryParameters['asset_identifier'] = requestParameters.assetIdentifier;
        }
        if (requestParameters.value !== undefined) {
            queryParameters['value'] = requestParameters.value;
        }
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }
        if (requestParameters.unanchored !== undefined) {
            queryParameters['unanchored'] = requestParameters.unanchored;
        }
        if (requestParameters.txMetadata !== undefined) {
            queryParameters['tx_metadata'] = requestParameters.txMetadata;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/tokens/nft/history`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.NonFungibleTokenHistoryEventListFromJSON)(jsonValue));
    }
    /**
     * Retrieves all events relevant to a Non-Fungible Token. Useful to determine the ownership history of a particular asset.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non-Fungible Token history
     */
    async getNftHistory(requestParameters, initOverrides) {
        const response = await this.getNftHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves the list of Non-Fungible Tokens owned by the given principal (STX address or Smart Contract ID). Results can be filtered by one or more asset identifiers and can include metadata about the transaction that made the principal own each token.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non-Fungible Token holdings
     */
    async getNftHoldingsRaw(requestParameters, initOverrides) {
        if (requestParameters.principal === null || requestParameters.principal === undefined) {
            throw new runtime.RequiredError('principal', 'Required parameter requestParameters.principal was null or undefined when calling getNftHoldings.');
        }
        const queryParameters = {};
        if (requestParameters.principal !== undefined) {
            queryParameters['principal'] = requestParameters.principal;
        }
        if (requestParameters.assetIdentifiers) {
            queryParameters['asset_identifiers'] = requestParameters.assetIdentifiers;
        }
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }
        if (requestParameters.unanchored !== undefined) {
            queryParameters['unanchored'] = requestParameters.unanchored;
        }
        if (requestParameters.txMetadata !== undefined) {
            queryParameters['tx_metadata'] = requestParameters.txMetadata;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/tokens/nft/holdings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.NonFungibleTokenHoldingsListFromJSON)(jsonValue));
    }
    /**
     * Retrieves the list of Non-Fungible Tokens owned by the given principal (STX address or Smart Contract ID). Results can be filtered by one or more asset identifiers and can include metadata about the transaction that made the principal own each token.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non-Fungible Token holdings
     */
    async getNftHoldings(requestParameters, initOverrides) {
        const response = await this.getNftHoldingsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves a list of non fungible tokens with their metadata. More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non fungible tokens metadata list
     */
    async getNftMetadataListRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/tokens/nft/metadata`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.NonFungibleTokensMetadataListFromJSON)(jsonValue));
    }
    /**
     * Retrieves a list of non fungible tokens with their metadata. More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non fungible tokens metadata list
     */
    async getNftMetadataList(requestParameters, initOverrides) {
        const response = await this.getNftMetadataListRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves all mint events for a Non-Fungible Token asset class. Useful to determine which NFTs of a particular collection have been claimed.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non-Fungible Token mints
     */
    async getNftMintsRaw(requestParameters, initOverrides) {
        if (requestParameters.assetIdentifier === null || requestParameters.assetIdentifier === undefined) {
            throw new runtime.RequiredError('assetIdentifier', 'Required parameter requestParameters.assetIdentifier was null or undefined when calling getNftMints.');
        }
        const queryParameters = {};
        if (requestParameters.assetIdentifier !== undefined) {
            queryParameters['asset_identifier'] = requestParameters.assetIdentifier;
        }
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }
        if (requestParameters.unanchored !== undefined) {
            queryParameters['unanchored'] = requestParameters.unanchored;
        }
        if (requestParameters.txMetadata !== undefined) {
            queryParameters['tx_metadata'] = requestParameters.txMetadata;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/tokens/nft/mints`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.NonFungibleTokenMintListFromJSON)(jsonValue));
    }
    /**
     * Retrieves all mint events for a Non-Fungible Token asset class. Useful to determine which NFTs of a particular collection have been claimed.  More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-nfts).
     * Non-Fungible Token mints
     */
    async getNftMints(requestParameters, initOverrides) {
        const response = await this.getNftMintsRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
exports.NonFungibleTokensApi = NonFungibleTokensApi;
//# sourceMappingURL=NonFungibleTokensApi.js.map