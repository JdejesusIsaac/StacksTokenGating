"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Stacks Blockchain API
 * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
 *
 * The version of the OpenAPI document: STACKS_API_VERSION
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetNetworkBlockTimeByNetworkNetworkEnum = exports.InfoApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class InfoApi extends runtime.BaseAPI {
    /**
     * Retrieves information about the Core API including the server version
     * Get Core API info
     */
    async getCoreApiInfoRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/v2/info`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.CoreNodeInfoResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves information about the Core API including the server version
     * Get Core API info
     */
    async getCoreApiInfo(initOverrides) {
        const response = await this.getCoreApiInfoRaw(initOverrides);
        return await response.value();
    }
    /**
     * Retrieves the target block time for a given network. The network can be mainnet or testnet. The block time is hardcoded and will change throughout the implementation phases of the testnet.
     * Get a given network\'s target block time
     */
    async getNetworkBlockTimeByNetworkRaw(requestParameters, initOverrides) {
        if (requestParameters.network === null || requestParameters.network === undefined) {
            throw new runtime.RequiredError('network', 'Required parameter requestParameters.network was null or undefined when calling getNetworkBlockTimeByNetwork.');
        }
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/info/network_block_time/{network}`.replace(`{${"network"}}`, encodeURIComponent(String(requestParameters.network))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.NetworkBlockTimeResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves the target block time for a given network. The network can be mainnet or testnet. The block time is hardcoded and will change throughout the implementation phases of the testnet.
     * Get a given network\'s target block time
     */
    async getNetworkBlockTimeByNetwork(requestParameters, initOverrides) {
        const response = await this.getNetworkBlockTimeByNetworkRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves the target block times for mainnet and testnet. The block time is hardcoded and will change throughout the implementation phases of the testnet.
     * Get the network target block time
     */
    async getNetworkBlockTimesRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/info/network_block_times`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.NetworkBlockTimesResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves the target block times for mainnet and testnet. The block time is hardcoded and will change throughout the implementation phases of the testnet.
     * Get the network target block time
     */
    async getNetworkBlockTimes(initOverrides) {
        const response = await this.getNetworkBlockTimesRaw(initOverrides);
        return await response.value();
    }
    /**
     * Retrieves Proof-of-Transfer (PoX) information. Can be used for Stacking.
     * Get Proof-of-Transfer details
     */
    async getPoxInfoRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/v2/pox`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.CoreNodePoxResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves Proof-of-Transfer (PoX) information. Can be used for Stacking.
     * Get Proof-of-Transfer details
     */
    async getPoxInfo(initOverrides) {
        const response = await this.getPoxInfoRaw(initOverrides);
        return await response.value();
    }
    /**
     * Retrieves the running status of the Stacks Blockchain API, including the server version and current chain tip information.
     * API status
     */
    async getStatusRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.ServerStatusResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves the running status of the Stacks Blockchain API, including the server version and current chain tip information.
     * API status
     */
    async getStatus(initOverrides) {
        const response = await this.getStatusRaw(initOverrides);
        return await response.value();
    }
    /**
     * Retrieves the total and unlocked STX supply. More information on Stacking can be found [here] (https://docs.stacks.co/understand-stacks/stacking). **Note:** This uses the estimated future total supply for the year 2050.
     * Get total and unlocked STX supply
     */
    async getStxSupplyRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.height !== undefined) {
            queryParameters['height'] = requestParameters.height;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/stx_supply`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.GetStxSupplyResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves the total and unlocked STX supply. More information on Stacking can be found [here] (https://docs.stacks.co/understand-stacks/stacking). **Note:** This uses the estimated future total supply for the year 2050.
     * Get total and unlocked STX supply
     */
    async getStxSupply(requestParameters, initOverrides) {
        const response = await this.getStxSupplyRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves the STX tokens currently in circulation that have been unlocked as plain text.
     * Get circulating STX supply in plain text format
     */
    async getStxSupplyCirculatingPlainRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/stx_supply/circulating/plain`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.TextApiResponse(response);
    }
    /**
     * Retrieves the STX tokens currently in circulation that have been unlocked as plain text.
     * Get circulating STX supply in plain text format
     */
    async getStxSupplyCirculatingPlain(initOverrides) {
        const response = await this.getStxSupplyCirculatingPlainRaw(initOverrides);
        return await response.value();
    }
    /**
     * Retrieves the total supply for STX tokens as plain text. **Note:** this uses the estimated future total supply for the year 2050.
     * Get total STX supply in plain text format
     */
    async getStxSupplyTotalSupplyPlainRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/stx_supply/total/plain`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.TextApiResponse(response);
    }
    /**
     * Retrieves the total supply for STX tokens as plain text. **Note:** this uses the estimated future total supply for the year 2050.
     * Get total STX supply in plain text format
     */
    async getStxSupplyTotalSupplyPlain(initOverrides) {
        const response = await this.getStxSupplyTotalSupplyPlainRaw(initOverrides);
        return await response.value();
    }
    /**
     * Retrieves total supply of STX tokens including those currently in circulation that have been unlocked. **Note:** this uses the estimated future total supply for the year 2050.
     * Get total and unlocked STX supply (results formatted the same as the legacy 1.0 API)
     */
    async getTotalStxSupplyLegacyFormatRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.height !== undefined) {
            queryParameters['height'] = requestParameters.height;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/stx_supply/legacy_format`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.GetStxSupplyLegacyFormatResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves total supply of STX tokens including those currently in circulation that have been unlocked. **Note:** this uses the estimated future total supply for the year 2050.
     * Get total and unlocked STX supply (results formatted the same as the legacy 1.0 API)
     */
    async getTotalStxSupplyLegacyFormat(requestParameters, initOverrides) {
        const response = await this.getTotalStxSupplyLegacyFormatRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
exports.InfoApi = InfoApi;
/**
    * @export
    * @enum {string}
    */
var GetNetworkBlockTimeByNetworkNetworkEnum;
(function (GetNetworkBlockTimeByNetworkNetworkEnum) {
    GetNetworkBlockTimeByNetworkNetworkEnum["testnet"] = "testnet";
    GetNetworkBlockTimeByNetworkNetworkEnum["mainnet"] = "mainnet";
})(GetNetworkBlockTimeByNetworkNetworkEnum = exports.GetNetworkBlockTimeByNetworkNetworkEnum || (exports.GetNetworkBlockTimeByNetworkNetworkEnum = {}));
//# sourceMappingURL=InfoApi.js.map