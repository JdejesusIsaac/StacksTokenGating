"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Stacks Blockchain API
 * Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a>
 *
 * The version of the OpenAPI document: STACKS_API_VERSION
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetTransactionListTypeEnum = exports.GetFilteredEventsTypeEnum = exports.TransactionsApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class TransactionsApi extends runtime.BaseAPI {
    /**
     * Retrieves all transactions for a given address that are currently in mempool
     * Transactions for address
     */
    async getAddressMempoolTransactionsRaw(requestParameters, initOverrides) {
        if (requestParameters.address === null || requestParameters.address === undefined) {
            throw new runtime.RequiredError('address', 'Required parameter requestParameters.address was null or undefined when calling getAddressMempoolTransactions.');
        }
        const queryParameters = {};
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }
        if (requestParameters.unanchored !== undefined) {
            queryParameters['unanchored'] = requestParameters.unanchored;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/address/{address}/mempool`.replace(`{${"address"}}`, encodeURIComponent(String(requestParameters.address))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.MempoolTransactionListResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves all transactions for a given address that are currently in mempool
     * Transactions for address
     */
    async getAddressMempoolTransactions(requestParameters, initOverrides) {
        const response = await this.getAddressMempoolTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves all recently-broadcast transactions that have been dropped from the mempool.  Transactions are dropped from the mempool if:  * they were stale and awaiting garbage collection or,  * were expensive,  or  * were replaced with a new fee
     * Get dropped mempool transactions
     */
    async getDroppedMempoolTransactionListRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/tx/mempool/dropped`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.MempoolTransactionListResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves all recently-broadcast transactions that have been dropped from the mempool.  Transactions are dropped from the mempool if:  * they were stale and awaiting garbage collection or,  * were expensive,  or  * were replaced with a new fee
     * Get dropped mempool transactions
     */
    async getDroppedMempoolTransactionList(requestParameters, initOverrides) {
        const response = await this.getDroppedMempoolTransactionListRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves the list of events filtered by principal (STX address or Smart Contract ID), transaction id or event types. The list of event types is (\'smart_contract_log\', \'stx_lock\', \'stx_asset\', \'fungible_token_asset\', \'non_fungible_token_asset\').
     * Transaction Events
     */
    async getFilteredEventsRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.txId !== undefined) {
            queryParameters['tx_id'] = requestParameters.txId;
        }
        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }
        if (requestParameters.type) {
            queryParameters['type'] = requestParameters.type;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/tx/events`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.TransactionEventsResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves the list of events filtered by principal (STX address or Smart Contract ID), transaction id or event types. The list of event types is (\'smart_contract_log\', \'stx_lock\', \'stx_asset\', \'fungible_token_asset\', \'non_fungible_token_asset\').
     * Transaction Events
     */
    async getFilteredEvents(requestParameters, initOverrides) {
        const response = await this.getFilteredEventsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves all transactions that have been recently broadcast to the mempool. These are pending transactions awaiting confirmation.  If you need to monitor new transactions, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates.
     * Get mempool transactions
     */
    async getMempoolTransactionListRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.senderAddress !== undefined) {
            queryParameters['sender_address'] = requestParameters.senderAddress;
        }
        if (requestParameters.recipientAddress !== undefined) {
            queryParameters['recipient_address'] = requestParameters.recipientAddress;
        }
        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }
        if (requestParameters.unanchored !== undefined) {
            queryParameters['unanchored'] = requestParameters.unanchored;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/tx/mempool`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.MempoolTransactionListResponseFromJSON)(jsonValue));
    }
    /**
     * Retrieves all transactions that have been recently broadcast to the mempool. These are pending transactions awaiting confirmation.  If you need to monitor new transactions, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates.
     * Get mempool transactions
     */
    async getMempoolTransactionList(requestParameters, initOverrides) {
        const response = await this.getMempoolTransactionListRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Queries for transactions counts, age (by block height), fees (simple average), and size. All results broken down by transaction type and percentiles (p25, p50, p75, p95).
     * Get statistics for mempool transactions
     */
    async getMempoolTransactionStatsRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/tx/mempool/stats`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.MempoolTransactionStatsResponseFromJSON)(jsonValue));
    }
    /**
     * Queries for transactions counts, age (by block height), fees (simple average), and size. All results broken down by transaction type and percentiles (p25, p50, p75, p95).
     * Get statistics for mempool transactions
     */
    async getMempoolTransactionStats(initOverrides) {
        const response = await this.getMempoolTransactionStatsRaw(initOverrides);
        return await response.value();
    }
    /**
     * Retrieves a hex encoded serialized transaction for a given ID
     * Get Raw Transaction
     */
    async getRawTransactionByIdRaw(requestParameters, initOverrides) {
        if (requestParameters.txId === null || requestParameters.txId === undefined) {
            throw new runtime.RequiredError('txId', 'Required parameter requestParameters.txId was null or undefined when calling getRawTransactionById.');
        }
        const queryParameters = {};
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/tx/{tx_id}/raw`.replace(`{${"tx_id"}}`, encodeURIComponent(String(requestParameters.txId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.GetRawTransactionResultFromJSON)(jsonValue));
    }
    /**
     * Retrieves a hex encoded serialized transaction for a given ID
     * Get Raw Transaction
     */
    async getRawTransactionById(requestParameters, initOverrides) {
        const response = await this.getRawTransactionByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves transaction details for a given transaction ID  `import type { Transaction } from \'@stacks/stacks-blockchain-api-types\';`
     * Get transaction
     */
    async getTransactionByIdRaw(requestParameters, initOverrides) {
        if (requestParameters.txId === null || requestParameters.txId === undefined) {
            throw new runtime.RequiredError('txId', 'Required parameter requestParameters.txId was null or undefined when calling getTransactionById.');
        }
        const queryParameters = {};
        if (requestParameters.eventOffset !== undefined) {
            queryParameters['event_offset'] = requestParameters.eventOffset;
        }
        if (requestParameters.eventLimit !== undefined) {
            queryParameters['event_limit'] = requestParameters.eventLimit;
        }
        if (requestParameters.unanchored !== undefined) {
            queryParameters['unanchored'] = requestParameters.unanchored;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/tx/{tx_id}`.replace(`{${"tx_id"}}`, encodeURIComponent(String(requestParameters.txId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response);
    }
    /**
     * Retrieves transaction details for a given transaction ID  `import type { Transaction } from \'@stacks/stacks-blockchain-api-types\';`
     * Get transaction
     */
    async getTransactionById(requestParameters, initOverrides) {
        const response = await this.getTransactionByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves all recently mined transactions  If using TypeScript, import typings for this response from our types package:  `import type { TransactionResults } from \'@stacks/stacks-blockchain-api-types\';`
     * Get recent transactions
     */
    async getTransactionListRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }
        if (requestParameters.type) {
            queryParameters['type'] = requestParameters.type;
        }
        if (requestParameters.unanchored !== undefined) {
            queryParameters['unanchored'] = requestParameters.unanchored;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/tx`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.TransactionResultsFromJSON)(jsonValue));
    }
    /**
     * Retrieves all recently mined transactions  If using TypeScript, import typings for this response from our types package:  `import type { TransactionResults } from \'@stacks/stacks-blockchain-api-types\';`
     * Get recent transactions
     */
    async getTransactionList(requestParameters, initOverrides) {
        const response = await this.getTransactionListRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves a list of all transactions within a block for a given block hash.
     * Transactions by block hash
     */
    async getTransactionsByBlockHashRaw(requestParameters, initOverrides) {
        if (requestParameters.blockHash === null || requestParameters.blockHash === undefined) {
            throw new runtime.RequiredError('blockHash', 'Required parameter requestParameters.blockHash was null or undefined when calling getTransactionsByBlockHash.');
        }
        const queryParameters = {};
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/tx/block/{block_hash}`.replace(`{${"block_hash"}}`, encodeURIComponent(String(requestParameters.blockHash))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.TransactionResultsFromJSON)(jsonValue));
    }
    /**
     * Retrieves a list of all transactions within a block for a given block hash.
     * Transactions by block hash
     */
    async getTransactionsByBlockHash(requestParameters, initOverrides) {
        const response = await this.getTransactionsByBlockHashRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves all transactions within a block at a given height
     * Transactions by block height
     */
    async getTransactionsByBlockHeightRaw(requestParameters, initOverrides) {
        if (requestParameters.height === null || requestParameters.height === undefined) {
            throw new runtime.RequiredError('height', 'Required parameter requestParameters.height was null or undefined when calling getTransactionsByBlockHeight.');
        }
        const queryParameters = {};
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }
        if (requestParameters.unanchored !== undefined) {
            queryParameters['unanchored'] = requestParameters.unanchored;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/tx/block_height/{height}`.replace(`{${"height"}}`, encodeURIComponent(String(requestParameters.height))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue) => (0, models_1.TransactionResultsFromJSON)(jsonValue));
    }
    /**
     * Retrieves all transactions within a block at a given height
     * Transactions by block height
     */
    async getTransactionsByBlockHeight(requestParameters, initOverrides) {
        const response = await this.getTransactionsByBlockHeightRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieves a list of transactions for a given list of transaction IDs  If using TypeScript, import typings for this response from our types package:  `import type { Transaction } from \'@stacks/stacks-blockchain-api-types\';`
     * Get list of details for transactions
     */
    async getTxListDetailsRaw(requestParameters, initOverrides) {
        if (requestParameters.txId === null || requestParameters.txId === undefined) {
            throw new runtime.RequiredError('txId', 'Required parameter requestParameters.txId was null or undefined when calling getTxListDetails.');
        }
        const queryParameters = {};
        if (requestParameters.txId) {
            queryParameters['tx_id'] = requestParameters.txId;
        }
        if (requestParameters.eventOffset !== undefined) {
            queryParameters['event_offset'] = requestParameters.eventOffset;
        }
        if (requestParameters.eventLimit !== undefined) {
            queryParameters['event_limit'] = requestParameters.eventLimit;
        }
        if (requestParameters.unanchored !== undefined) {
            queryParameters['unanchored'] = requestParameters.unanchored;
        }
        const headerParameters = {};
        const response = await this.request({
            path: `/extended/v1/tx/multiple`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);
        return new runtime.JSONApiResponse(response);
    }
    /**
     * Retrieves a list of transactions for a given list of transaction IDs  If using TypeScript, import typings for this response from our types package:  `import type { Transaction } from \'@stacks/stacks-blockchain-api-types\';`
     * Get list of details for transactions
     */
    async getTxListDetails(requestParameters, initOverrides) {
        const response = await this.getTxListDetailsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Broadcasts raw transactions on the network. You can use the [@stacks/transactions](https://github.com/blockstack/stacks.js) project to generate a raw transaction payload.
     * Broadcast raw transaction
     */
    async postCoreNodeTransactionsRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/octet-stream';
        const response = await this.request({
            path: `/v2/transactions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body,
        }, initOverrides);
        return new runtime.TextApiResponse(response);
    }
    /**
     * Broadcasts raw transactions on the network. You can use the [@stacks/transactions](https://github.com/blockstack/stacks.js) project to generate a raw transaction payload.
     * Broadcast raw transaction
     */
    async postCoreNodeTransactions(requestParameters, initOverrides) {
        const response = await this.postCoreNodeTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
exports.TransactionsApi = TransactionsApi;
/**
    * @export
    * @enum {string}
    */
var GetFilteredEventsTypeEnum;
(function (GetFilteredEventsTypeEnum) {
    GetFilteredEventsTypeEnum["smart_contract_log"] = "smart_contract_log";
    GetFilteredEventsTypeEnum["stx_lock"] = "stx_lock";
    GetFilteredEventsTypeEnum["stx_asset"] = "stx_asset";
    GetFilteredEventsTypeEnum["fungible_token_asset"] = "fungible_token_asset";
    GetFilteredEventsTypeEnum["non_fungible_token_asset"] = "non_fungible_token_asset";
})(GetFilteredEventsTypeEnum = exports.GetFilteredEventsTypeEnum || (exports.GetFilteredEventsTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var GetTransactionListTypeEnum;
(function (GetTransactionListTypeEnum) {
    GetTransactionListTypeEnum["coinbase"] = "coinbase";
    GetTransactionListTypeEnum["token_transfer"] = "token_transfer";
    GetTransactionListTypeEnum["smart_contract"] = "smart_contract";
    GetTransactionListTypeEnum["contract_call"] = "contract_call";
    GetTransactionListTypeEnum["poison_microblock"] = "poison_microblock";
})(GetTransactionListTypeEnum = exports.GetTransactionListTypeEnum || (exports.GetTransactionListTypeEnum = {}));
//# sourceMappingURL=TransactionsApi.js.map