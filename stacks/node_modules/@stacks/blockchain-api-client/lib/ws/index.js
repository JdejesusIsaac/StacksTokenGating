"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.connectWebSocketClient = exports.StacksApiWebSocketClient = void 0;
const JsonRpcLite = require("jsonrpc-lite");
const eventemitter3_1 = require("eventemitter3");
const runtime_1 = require("../generated/runtime");
class StacksApiWebSocketClient {
    constructor(webSocket) {
        this.idCursor = 0;
        this.pendingRequests = new Map();
        this.eventEmitter = new eventemitter3_1.EventEmitter();
        this.webSocket = webSocket;
        webSocket.addEventListener('message', event => {
            const parsed = JsonRpcLite.parse(event.data);
            const rpcObjects = Array.isArray(parsed) ? parsed : [parsed];
            rpcObjects.forEach(obj => {
                if (obj.type === "notification" /* notification */) {
                    this.handleNotification(obj.payload);
                }
                else if (obj.type === "success" /* success */) {
                    const req = this.pendingRequests.get(obj.payload.id);
                    if (req) {
                        this.pendingRequests.delete(obj.payload.id);
                        req.resolve(obj.payload.result);
                    }
                }
                else if (obj.type === "error" /* error */) {
                    const req = this.pendingRequests.get(obj.payload.id);
                    if (req) {
                        this.pendingRequests.delete(obj.payload.id);
                        req.reject(obj.payload.error);
                    }
                }
            });
        });
    }
    static async connect(url = runtime_1.BASE_PATH) {
        // `ws://${addr}/extended/v1/ws`;
        let urlObj;
        try {
            urlObj = new URL(url);
        }
        catch (_error) {
            urlObj = new URL(`ws://${url}`);
        }
        if (urlObj.protocol === 'https:') {
            urlObj.protocol = 'wss:';
        }
        else if (urlObj.protocol === 'http:') {
            urlObj.protocol = 'ws:';
        }
        if (urlObj.pathname === '/') {
            urlObj.pathname = '/extended/v1/ws';
        }
        const webSocket = await new Promise((resolve, reject) => {
            const webSocket = new (createWebSocket())(urlObj.toString());
            webSocket.onopen = () => resolve(webSocket);
            webSocket.onerror = error => reject(error);
        });
        return new StacksApiWebSocketClient(webSocket);
    }
    handleNotification(data) {
        const method = data.method;
        switch (method) {
            case 'tx_update':
                this.eventEmitter.emit('txUpdate', data.params);
                break;
            case 'address_tx_update':
                this.eventEmitter.emit('addressTxUpdate', data.params);
                break;
            case 'address_balance_update':
                this.eventEmitter.emit('addressBalanceUpdate', data.params);
                break;
            case 'block':
                this.eventEmitter.emit('block', data.params);
                break;
            case 'microblock':
                this.eventEmitter.emit('microblock', data.params);
                break;
            case 'mempool':
                this.eventEmitter.emit('mempool', data.params);
                break;
            case 'nft_event':
                this.eventEmitter.emit('nftEventUpdate', data.params);
                break;
            case 'nft_asset_event':
                this.eventEmitter.emit('nftAssetEventUpdate', data.params);
                break;
            case 'nft_collection_event':
                this.eventEmitter.emit('nftCollectionEventUpdate', data.params);
                break;
        }
    }
    rpcCall(method, params) {
        const rpcReq = JsonRpcLite.request(++this.idCursor, method, params);
        return new Promise((resolve, reject) => {
            this.pendingRequests.set(rpcReq.id, { resolve, reject });
            this.webSocket.send(rpcReq.serialize());
        });
    }
    async subscribeBlocks(update) {
        const params = { event: 'block' };
        await this.rpcCall('subscribe', params);
        const listener = (event) => {
            update(event);
        };
        this.eventEmitter.addListener('block', listener);
        return {
            unsubscribe: () => {
                this.eventEmitter.removeListener('block', listener);
                return this.rpcCall('unsubscribe', params);
            },
        };
    }
    async subscribeMicroblocks(update) {
        const params = { event: 'microblock' };
        await this.rpcCall('subscribe', params);
        const listener = (event) => {
            update(event);
        };
        this.eventEmitter.addListener('microblock', listener);
        return {
            unsubscribe: () => {
                this.eventEmitter.removeListener('microblock', listener);
                return this.rpcCall('unsubscribe', params);
            },
        };
    }
    async subscribeMempool(update) {
        const params = { event: 'mempool' };
        await this.rpcCall('subscribe', params);
        const listener = (event) => {
            update(event);
        };
        this.eventEmitter.addListener('mempool', listener);
        return {
            unsubscribe: () => {
                this.eventEmitter.removeListener('mempool', listener);
                return this.rpcCall('unsubscribe', params);
            },
        };
    }
    async subscribeTxUpdates(txId, update) {
        const params = { event: 'tx_update', tx_id: txId };
        const subscribed = await this.rpcCall('subscribe', params);
        const listener = (event) => {
            if (event.tx_id === subscribed.tx_id) {
                update(event);
            }
        };
        this.eventEmitter.addListener('txUpdate', listener);
        return {
            unsubscribe: () => {
                this.eventEmitter.removeListener('txUpdate', listener);
                return this.rpcCall('unsubscribe', params);
            },
        };
    }
    async subscribeAddressTransactions(address, update) {
        const params = { event: 'address_tx_update', address };
        const subscribed = await this.rpcCall('subscribe', params);
        const listener = (event) => {
            if (event.address === subscribed.address) {
                update(event);
            }
        };
        this.eventEmitter.addListener('addressTxUpdate', listener);
        return {
            unsubscribe: () => {
                this.eventEmitter.removeListener('addressTxUpdate', listener);
                return this.rpcCall('unsubscribe', params);
            },
        };
    }
    async subscribeAddressBalanceUpdates(address, update) {
        const params = {
            event: 'address_balance_update',
            address,
        };
        const subscribed = await this.rpcCall('subscribe', params);
        const listener = (event) => {
            if (event.address === subscribed.address) {
                update(event);
            }
        };
        this.eventEmitter.addListener('addressBalanceUpdate', listener);
        return {
            unsubscribe: () => {
                this.eventEmitter.removeListener('addressBalanceUpdate', listener);
                return this.rpcCall('unsubscribe', params);
            },
        };
    }
    async subscribeNftEventUpdates(update) {
        const params = {
            event: 'nft_event',
        };
        await this.rpcCall('subscribe', params);
        const listener = (event) => {
            update(event);
        };
        this.eventEmitter.addListener('nftEventUpdate', listener);
        return {
            unsubscribe: () => {
                this.eventEmitter.removeListener('nftEventUpdate', listener);
                return this.rpcCall('unsubscribe', params);
            },
        };
    }
    async subscribeNftAssetEventUpdates(assetIdentifier, value, update) {
        const params = {
            event: 'nft_asset_event',
            asset_identifier: assetIdentifier,
            value,
        };
        const subscribed = await this.rpcCall('subscribe', params);
        const listener = (event) => {
            if (event.asset_identifier === subscribed.asset_identifier && event.value.hex === subscribed.value) {
                update(event);
            }
        };
        this.eventEmitter.addListener('nftAssetEventUpdate', listener);
        return {
            unsubscribe: () => {
                this.eventEmitter.removeListener('nftAssetEventUpdate', listener);
                return this.rpcCall('unsubscribe', params);
            },
        };
    }
    async subscribeNftCollectionEventUpdates(assetIdentifier, update) {
        const params = {
            event: 'nft_collection_event',
            asset_identifier: assetIdentifier,
        };
        const subscribed = await this.rpcCall('subscribe', params);
        const listener = (event) => {
            if (event.asset_identifier === subscribed.asset_identifier) {
                update(event);
            }
        };
        this.eventEmitter.addListener('nftCollectionEventUpdate', listener);
        return {
            unsubscribe: () => {
                this.eventEmitter.removeListener('nftCollectionEventUpdate', listener);
                return this.rpcCall('unsubscribe', params);
            },
        };
    }
}
exports.StacksApiWebSocketClient = StacksApiWebSocketClient;
async function connectWebSocketClient(url = runtime_1.BASE_PATH) {
    return StacksApiWebSocketClient.connect(url);
}
exports.connectWebSocketClient = connectWebSocketClient;
/**
 * Simple isomorphic WebSocket class lookup.
 * Uses global WebSocket (browsers) if available, otherwise, uses the Node.js `ws` lib.
 */
function createWebSocket() {
    if (typeof WebSocket !== 'undefined') {
        return WebSocket;
    }
    else if (typeof global !== 'undefined' && global.WebSocket) {
        return global.WebSocket;
    }
    else if (typeof window !== 'undefined' && window.WebSocket) {
        return window.WebSocket;
    }
    else if (typeof self !== 'undefined' && self.WebSocket) {
        return self.WebSocket;
    }
    else {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return require('ws');
    }
}
//# sourceMappingURL=index.js.map